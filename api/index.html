<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/SymbolicUtils.jl/libs/highlight/github.min.css"> <link rel=stylesheet  href="/SymbolicUtils.jl/css/franklin.css"> <link rel=stylesheet  href="/SymbolicUtils.jl/css/tufte.css"> <link rel=stylesheet  href="/SymbolicUtils.jl/css/custom.css"> <link rel=stylesheet  href="/SymbolicUtils.jl/css/latex.css"> <link rel=stylesheet  href="/SymbolicUtils.jl/css/adjust.css"> <title>SymbolicUtils.jl — API</title> <h1><a href="/SymbolicUtils.jl/">SymbolicUtils.jl</a></h1> <div id=layout > <div id=menu > <ul> <li><a href="/SymbolicUtils.jl/">Manual</a> <li><a href="/SymbolicUtils.jl/interface/">Interfacing</a> <li><a href="/SymbolicUtils.jl/api/">API</a> </ul> </div> <div id=main > <div class=franklin-content ><h1 id=api_reference ><a href="#api_reference">API Reference</a></h1> <div class=franklin-toc ><ol><li><a href="#api_reference">API Reference</a><ol><li><a href="#symbols_and_terms">Symbols and Terms</a><li><a href="#interfacing">Interfacing</a><li><a href="#rewriters">Rewriters</a><li><a href="#simplify">Simplify</a><li><a href="#utilities">Utilities</a></ol></ol></div> <h2 id=symbols_and_terms ><a href="#symbols_and_terms">Symbols and Terms</a></h2> <div class=docstring > <h2 class=doc-header  id="@syms"> <a href="#@syms">@syms</a> <div class=doc-type >macro</div></h2> <div class=doc-content ><pre><code class=language-julia >@syms <lhs_expr>[::T1] <lhs_expr>[::T2]...</code></pre>
<p>For instance:</p>
<pre><code class=language-julia >@syms foo::Real bar baz(x, y::Real)::Complex</code></pre>
<p>Create one or more variables. <code>&lt;lhs_expr&gt;</code> can be just a symbol in which case it will be the name of the variable, or a function call in which case a function-like variable which has the same name as the function being called. The Sym type, or in the case of a function-like Sym, the output type of calling the function can be set using the <code>::T</code> syntax.</p>
<h1 id=examples ><a href="#examples">Examples:</a></h1>
<ul>
<li><p><code>@syms foo bar::Real baz::Int</code> will create</p>

</ul>
<p>variable <code>foo</code> of symtype <code>Number</code> &#40;the default&#41;, <code>bar</code> of symtype <code>Real</code> and <code>baz</code> of symtype <code>Int</code>
<ul>
<li><p><code>@syms f&#40;x&#41; g&#40;y::Real, x&#41;::Int h&#40;a::Int, f&#40;b&#41;&#41;</code> creates 1-arg <code>f</code> 2-arg <code>g</code></p>

</ul>
<p>and 2 arg <code>f</code>. The second argument to <code>h</code> must be a one argument function-like variable. So, <code>h&#40;1, g&#41;</code> will fail and <code>h&#40;1, f&#41;</code> will work.</div>
  </div>

  <div class=docstring >
      <h2 class=doc-header  id=Sym >
        <a href="#Sym">Sym</a>
        <div class=doc-type >type</div></h2>
      <div class=doc-content ><pre><code class=language-julia >Sym{T}(name::Symbol)</code></pre>
<p>A named variable of type <code>T</code>. Type <code>T</code> can be <code>FnType&#123;X,Y&#125;</code> which means the variable is a function with the type signature X -&gt; Y where <code>X</code> is a tuple type of arguments and <code>Y</code> is any type.</div>
  </div>

  <div class=docstring >
      <h2 class=doc-header  id=symtype >
        <a href="#symtype">symtype</a>
        <div class=doc-type >fn</div></h2>
      <div class=doc-content ><pre><code class=language-julia >symtype(x)</code></pre>
<p>The supposed type of values in the domain of x. Tracing tools can use this type to pick the right method to run or analyse code.</p>
<p>This defaults to <code>typeof&#40;x&#41;</code> if <code>x</code> is numeric, or <code>Any</code> otherwise. For the types defined in this package, namely <code>T&lt;:Symbolic&#123;S&#125;</code> it is <code>S</code>.</p>
<p>Define this for your symbolic types if you want <code>simplify</code> to apply rules specific to numbers &#40;such as commutativity of multiplication&#41;. Or such rules that may be implemented in the future.</div>
  </div>

  <div class=docstring >
      <h2 class=doc-header  id=Term >
        <a href="#Term">Term</a>
        <div class=doc-type >type</div></h2>
      <div class=doc-content ><pre><code class=language-julia >Term{T}(f, args::AbstractArray)</code></pre>
<p>or     Term&#40;f, args::AbstractArray&#41;</p>
<p>Symbolic expression representing the result of calling <code>f&#40;args...&#41;</code>.</p>
<ul>
<li><p><code>operation&#40;t::Term&#41;</code> returns <code>f</code></p>

<li><p><code>arguments&#40;t::Term&#41;</code> returns <code>args</code></p>

<li><p><code>symtype&#40;t::Term&#41;</code> returns <code>T</code></p>

</ul>
<p>If <code>T</code> is not provided during construction, it is queried by calling <code>SymbolicUtils.promote_symtype&#40;f, map&#40;symtype, args&#41;...&#41;</code>.</p>
<p>See <a href="#promote_symtype">promote_symtype</a></div>
  </div>

  <div class=docstring >
      <h2 class=doc-header  id=promote_symtype >
        <a href="#promote_symtype">promote_symtype</a>
        <div class=doc-type >fn</div></h2>
      <div class=doc-content ><pre><code class=language-julia >promote_symtype(f, Ts...)</code></pre>
<p>The result of applying <code>f</code> to arguments of <a href="#symtype"><code>symtype</code></a> <code>Ts...</code>
<pre><code class=language-julia >julia> promote_symtype(+, Real, Real)
Real

julia> promote_symtype(+, Complex, Real)
Number

julia> @syms f(x)::Complex
(f(::Number)::Complex,)

julia> promote_symtype(f, Number)
Complex</code></pre>
<p>When constructing <a href="#Term"><code>Term</code></a>s without an explicit symtype, <code>promote_symtype</code> is used to figure out the symtype of the Term.</p>
<code>promote_symtype&#40;f::Sym&#123;FnType&#123;X,Y&#125;&#125;, arg_symtypes...&#41;</code>
<p>The output symtype of applying variable <code>f</code> to arugments of symtype <code>arg_symtypes...</code>. if the arguments are of the wrong type then this function will error.</div>
  </div>

<h2 id=interfacing ><a href="#interfacing">Interfacing</a></h2>
  <div class=docstring >
      <h2 class=doc-header  id=to_symbolic >
        <a href="#to_symbolic">to_symbolic</a>
        <div class=doc-type >fn</div></h2>
      <div class=doc-content ><pre><code class=language-julia >to_symbolic(x)</code></pre>
<p>Convert <code>x</code> to a <code>Symbolic</code> type, using the <code>istree</code>, <code>operation</code>, <code>arguments</code>, and optionally <code>symtype</code> if available.</div>
  </div>

  <div class=docstring >
      <h2 class=doc-header  id=istree >
        <a href="#istree">istree</a>
        <div class=doc-type >fn</div></h2>
      <div class=doc-content ><pre><code class=language-julia >istree(x::T)</code></pre>
<p>Check if <code>x</code> represents an expression tree. If returns true, it will be assumed that <code>operation&#40;::T&#41;</code> and <code>arguments&#40;::T&#41;</code> methods are defined. Definining these three should allow use of <code>simplify</code> on custom types. Optionally <code>symtype&#40;x&#41;</code> can be defined to return the expected type of the symbolic expression.</div>
  </div>

  <div class=docstring >
      <h2 class=doc-header  id=operation >
        <a href="#operation">operation</a>
        <div class=doc-type >fn</div></h2>
      <div class=doc-content ><pre><code class=language-julia >operation(x::T)</code></pre>
<p>Returns the operation &#40;a function object&#41; performed by an expression tree. Called only if <code>istree&#40;::T&#41;</code> is true. Part of the API required for <code>simplify</code> to work. Other required methods are <code>arguments</code> and <code>istree</code></div>
  </div>

  <div class=docstring >
      <h2 class=doc-header  id=arguments >
        <a href="#arguments">arguments</a>
        <div class=doc-type >fn</div></h2>
      <div class=doc-content ><pre><code class=language-julia >arguments(x::T)</code></pre>
<p>Returns the arguments &#40;a <code>Vector</code>&#41; for an expression tree. Called only if <code>istree&#40;x&#41;</code> is <code>true</code>. Part of the API required for <code>simplify</code> to work. Other required methods are <code>operation</code> and <code>istree</code></div>
  </div>

<h2 id=rewriters ><a href="#rewriters">Rewriters</a></h2>
  <div class=docstring >
      <h2 class=doc-header  id="@rule">
        <a href="#@rule">@rule</a>
        <div class=doc-type >macro</div></h2>
      <div class=doc-content ><pre><code class=language-julia >@rule LHS => RHS</code></pre>
<p>Creates a <code>Rule</code> object. A rule object is callable, and  takes an expression and rewrites it if it matches the LHS pattern to the RHS pattern, returns <code>nothing</code> otherwise. The rule language is described below.</p>
<p>LHS can be any possibly nested function call expression where any of the arugments can optionally be a Slot &#40;<code>~x</code>&#41; or a Segment &#40;<code>~~x</code>&#41; &#40;described below&#41;.</p>
<p>If an expression matches LHS entirely, then it is rewritten to the pattern in the RHS Segment &#40;<code>~x</code>&#41; and slot variables &#40;<code>~~x</code>&#41; on the RHS will substitute the result of the matches found for these variables in the LHS.</p>
<p><strong>Slot</strong>:</p>
<p>A Slot variable is written as <code>~x</code> and matches a single expression. <code>x</code> is the name of the variable. If a slot appears more than once in an LHS expression then expression matched at every such location must be equal &#40;as shown by <code>isequal</code>&#41;.</p>
<p><em>Example:</em></p>
<p>Simple rule to turn any <code>sin</code> into <code>cos</code>:</p>
<pre><code class=language-julia >julia> @syms a b c
(a, b, c)

julia> r = @rule sin(~x) => cos(~x)
sin(~x) => cos(~x)

julia> r(sin(1+a))
cos((1 + a))</code></pre>
<p>A rule with 2 segment variables</p>
<pre><code class=language-julia >julia> r = @rule ~x - ~y => ~x + (-(~y))
~x - ~y => ~x + -(~y)

julia> r(a-2b)
(a + (-(2 * b)))</code></pre>
<p>A rule that matches two of the same expressions:</p>
<pre><code class=language-julia >julia> r = @rule sin(~x)^2 + cos(~x)^2 => 1
sin(~x) ^ 2 + cos(~x) ^ 2 => 1

julia> r(sin(2a)^2 + cos(2a)^2)
1

julia> r(sin(2a)^2 + cos(a)^2)
# nothing</code></pre>
<p><strong>Segment</strong>:</p>
<p>A Segment variable is written as <code>~~x</code> and matches zero or more expressions in the function call.</p>
<p><em>Example:</em></p>
<p>This implements the distributive property of multiplication: <code>&#43;&#40;~~ys&#41;</code> matches expressions like <code>a &#43; b</code>, <code>a&#43;b&#43;c</code> and so on. On the RHS <code>~~ys</code> presents as any old julia array.</p>
<pre><code class=language-julia >julia> r = @rule ~x * +((~~ys)) => sum(map(y-> ~x * y, ~~ys));

julia> r(2 * (a+b+c))
((2 * a) + (2 * b) + (2 * c))</code></pre>
<p><strong>Predicates</strong>:</p>
<p>Predicates can be used on both <code>~x</code> and <code>~~x</code> by using the <code>~x::f</code> or <code>~~x::f</code>. Here <code>f</code> can be any julia function. In the case of a slot the function gets a single matched subexpression, in the case of segment, it gets an array of matched expressions.</p>
<p>The predicate should return <code>true</code> if the current match is acceptable, and <code>false</code> otherwise.</p>
<pre><code class=language-julia >julia> two_πs(x::Number) = abs(round(x/(2π)) - x/(2π)) < 10^-9
two_πs (generic function with 1 method)

julia> two_πs(x) = false
two_πs (generic function with 2 methods)

julia> r = @rule sin(~~x + ~y::two_πs + ~~z) => sin(+(~~x..., ~~z...))
sin(~(~x) + ~(y::two_πs) + ~(~z)) => sin(+(~(~x)..., ~(~z)...))

julia> r(sin(a+3π))

julia> r(sin(a+6π))
sin(a)

julia> r(sin(a+6π+c))
sin((a + c))</code></pre>
<p>Predicate function gets an array of values if attached to a segment variable &#40;<code>~~x</code>&#41;.</p>
<p><strong>Context</strong>:</p>
<p><em>In predicates</em>: Contextual predicates are functions wrapped in the <code>Contextual</code> type. The function is called with 2 arguments: the expression and a context object passed during a call to the Rule object &#40;maybe done by passing a context to <code>simplify</code> or a <code>RuleSet</code> object&#41;.</p>
<p>The function can use the inputs however it wants, and must return a boolean indicating whether the predicate holds or not.</p>
<p><em>In the consequent pattern</em>: Use <code>&#40;@ctx&#41;</code> to access the context object on the right hand side of an expression.</div>
  </div>

  <div class=docstring >
      <h2 class=doc-header  id=Rewriters >
        <a href="#Rewriters">module</a>
        <div class=doc-type ></div></h2>
      <div class=doc-content ><p>A rewriter is any function which takes an expression and returns an expression or <code>nothing</code>. If <code>nothing</code> is returned that means there was no changes applicable to the input expression.</p>
<p>The <code>SymbolicUtils.Rewriters</code> module contains some types which create and transform rewriters.</p>
<ul>
<li><p><code>Empty&#40;&#41;</code> is a rewriter which always returns <code>nothing</code></p>

<li><p><code>Chain&#40;itr&#41;</code> chain an iterator of rewriters into a single rewriter which applies  each chained rewriter in the given order.  If a rewriter returns <code>nothing</code> this is treated as a no-change.</p>

<li><p><code>RestartedChain&#40;itr&#41;</code> like <code>Chain&#40;itr&#41;</code> but restarts on the first successful application  of one of the chained rewriters.</p>

<li><p><code>Prewalk&#40;rw; threaded&#61;false, thread_cutoff&#61;100&#41;</code> returns a rewriter which does a pre-order  traversal of a given expression and applies the rewriter <code>rw</code>. <code>threaded&#61;true</code> will  use multi threading for traversal. <code>thread_cutoff</code> is the minimum number of nodes  in a subtree which should be walked in a threaded spawn.</p>

<li><p><code>Postwalk&#40;rw; threaded&#61;false, thread_cutoff&#61;100&#41;</code> similarly does post-order traversal.</p>

<li><p><code>IfElse&#40;cond, rw1, rw2&#41;</code> runs the <code>cond</code> function on the input, applies <code>rw1</code> if cond  returns true, <code>rw2</code> if it retuns false</p>

<li><p><code>If&#40;cond, rw&#41;</code> is the same as <code>IfElse&#40;cond, rw, Empty&#40;&#41;&#41;</code></p>

<li><p><code>PassThrough&#40;rw&#41;</code> returns a rewriter which if <code>rw&#40;x&#41;</code> returns <code>nothing</code> will instead  return <code>x</code> otherwise will return <code>rw&#40;x&#41;</code>.</p>

</ul>
</div>
  </div>

<h2 id=simplify ><a href="#simplify">Simplify</a></h2>
  <div class=docstring >
      <h2 class=doc-header  id=simplify >
        <a href="#simplify">simplify</a>
        <div class=doc-type >fn</div></h2>
      <div class=doc-content ><p>simplify&#40;x; rewriter&#61;default<em>simplifier&#40;&#41;,             threaded&#61;false,             polynorm&#61;true,             thread</em>subtree_cutoff&#61;100&#41;</p>
<p>Simplify an expression &#40;<code>x</code>&#41; by applying <code>rewriter</code> until there are no changes. <code>polynorm&#61;true</code> applies <code>polynormalize</code> in the beginning of each fixpoint iteration.</p>
</div>
  </div>

  <div class=docstring >
      <h2 class=doc-header  id=substitute >
        <a href="#substitute">substitute</a>
        <div class=doc-type >fn</div></h2>
      <div class=doc-content ><pre><code class=language-julia >substitute(expr, dict)</code></pre>
<p>substitute any subexpression that matches a key in <code>dict</code> with the corresponding value.</div>
  </div>

<h2 id=utilities ><a href="#utilities">Utilities</a></h2>
  <div class=docstring >
      <h2 class=doc-header  id="@timerewrite">
        <a href="#@timerewrite">@timerewrite</a>
        <div class=doc-type >macro</div></h2>
      <div class=doc-content ><pre><code class=language-julia >@timerewrite expr</code></pre>
<p>If <code>expr</code> calls <code>simplify</code> or a <code>RuleSet</code> object, track the amount of time it spent on applying each rule and pretty print the timing.</p>
<p>This uses <a href="https://github.com/KristofferC/TimerOutputs.jl">TimerOutputs.jl</a>.</p>
<h2 id=example ><a href="#example">Example:</a></h2>
<pre><code class=language-julia >julia> expr = foldr(*, rand([a,b,c,d], 100))
(a ^ 26) * (b ^ 30) * (c ^ 16) * (d ^ 28)

julia> @timerewrite simplify(expr)
 ────────────────────────────────────────────────────────────────────────────────────────────────
                                                         Time                   Allocations
                                                 ──────────────────────   ───────────────────────
                Tot / % measured:                     340ms / 15.3%           92.2MiB / 10.8%

 Section                                 ncalls     time   %tot     avg     alloc   %tot      avg
 ────────────────────────────────────────────────────────────────────────────────────────────────
 ACRule((~y) ^ ~n * ~y => (~y) ^ (~n ...    667   11.1ms  21.3%  16.7μs   2.66MiB  26.8%  4.08KiB
   RHS                                       92    277μs  0.53%  3.01μs   14.4KiB  0.14%     160B
 ACRule((~x) ^ ~n * (~x) ^ ~m => (~x)...    575   7.63ms  14.6%  13.3μs   1.83MiB  18.4%  3.26KiB
 (*)(~(~(x::!issortedₑ))) => sort_arg...    831   6.31ms  12.1%  7.59μs    738KiB  7.26%     910B
   RHS                                      164   3.03ms  5.81%  18.5μs    250KiB  2.46%  1.52KiB
   ...
   ...
 ────────────────────────────────────────────────────────────────────────────────────────────────
(a ^ 26) * (b ^ 30) * (c ^ 16) * (d ^ 28)</code></pre></div>
  </div>
<div class=page-foot >
  <div class=copyright >
      &copy; Shashi Gowda, Yingbo Ma and Mason Protter. Last modified: June 20, 2020. <br> Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a>.
  </div>
</div>
</div>
        </div> 
    </div> 
    
    
        <script src="/SymbolicUtils.jl/libs/highlight/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();hljs.configure({tabReplace: '    '});</script>