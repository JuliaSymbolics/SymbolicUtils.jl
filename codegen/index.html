<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
   <link rel="stylesheet" href="/libs/highlight/github.min.css">
   
  <link rel="stylesheet" href="/css/franklin.css">
<link rel="stylesheet" href="/css/poole_hyde.css">
<link rel="stylesheet" href="/css/custom.css">
<!-- style adjustments -->
<style>
  html {font-size: 17px;}
  .franklin-content {position: relative; padding-left: 8%; padding-right: 5%;}
  @media (min-width: 940px) {
    .franklin-content {width: 100%; margin-left: auto; margin-right: auto;}
  }
  @media (max-width: 768px) {
    .franklin-content {padding-left: 6%; padding-right: 6%;}
  }
</style>
<link rel="icon" href="/assets/favicon.png">

   <title>SymbolicUtils.jl — Code generation</title>  
</head>
<body>
<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1 class="sidebar-title"><a href="/">SymbolicUtils<span style="opacity:0.4">.jl</span></a></h1>
      <br>
    </div>
    <style>
@media (min-width: 768px) {
    .sidebar-nav {
    }
}
    .sidebar .container.sidebar-sticky {
        top: 4rem;
    }
    .sidebar-nav .sidebar-nav-item.active {
        box-sizing: border-box;
        border-bottom: 1px #f1f1f1 solid;
        margin-right: -1em;
        margin-left: -0.5em;
        padding-left: 0.5em;
        color: white;
        font-weight: normal !important;
    }
    .sidebar-nav .sidebar-nav-item {
        color: #cccccc;
        margin: 0.25em 0;
    }
    </style>
    <nav class="sidebar-nav" style="opacity: 0.9">
      <a class="sidebar-nav-item " href="/">Getting Started</a>
      <a class="sidebar-nav-item " href="/representation/">Term representation</a>
      <a class="sidebar-nav-item " href="/rewrite/">Term Rewriting</a>
      <a class="sidebar-nav-item " href="/interface/">Interfacing</a>
      <a class="sidebar-nav-item active" href="/codegen/">Code generation</a>
      <a class="sidebar-nav-item " href="/api/">API documentation</a>
    </nav>

  </div>
  <div style="font-size: 0.85em; bottom: 3em; position: fixed">
      <a href="https://github.com/JuliaSymbolics/SymbolicUtils.jl">Go to GitHub repository &rarr;</a> <br>  <br>

      <a href="https://julialang.org/"><img src="https://raw.githubusercontent.com/JuliaLang/julia-logo-graphics/master/images/julia-logo-dark.svg" height="32" style="display: inline-block; margin-bottom: -8px; opacity: 0.7">
          powered.</a>
  </div>
</div>
<div class="content container">

<!-- Content appended here -->
<div class="franklin-content"><h1 id="code_generation"><a href="#code_generation" class="header-anchor">Code generation</a></h1>
<p><strong>Note: this feature is experimental and the API might change frequently</strong></p>
<p><code>toexpr&#40;ex&#41;</code> turns any expression &#40;<code>ex</code>&#41; into the equivalent <code>Expr</code> which is suitable for <code>eval</code>. The <code>SymbolicUtils.Code</code> module provides some combinators which provides the ability to construct more complex expressions than just function calls. These include:</p>
<ul>
<li><p>Let blocks</p>
</li>
<li><p>Functions with arguments and keyword arguments</p>
<ul>
<li><p>Functions with arguments which are to be de-structured</p>
</li>
</ul>
</li>
<li><p>Expressions that set array elements in-place</p>
</li>
<li><p>Expressions that create an array similar in type to a reference array &#40;currently supports <code>Array</code>, <code>StaticArrays.SArray</code>, and <code>LabelledArrays.SLArray</code>&#41;</p>
</li>
<li><p>Expressions that create sparse arrays</p>
</li>
</ul>
<p><strong>Do <code>using SymbolicUtils.Code</code> to get the following bindings</strong></p>
<h2 id="toexpr"><a href="#toexpr" class="header-anchor"><code>toexpr</code></a></h2>
  <div class="docstring">
      <h2 class="doc-header" id="toexpr">
        <a href="#toexpr">toexpr</a>
        <div class="doc-type"></div></h2>
      <div class="doc-content"><pre><code class="julia hljs">toexpr(ex, [st,])</code></pre>
<p>Convert a symbolic expression into an <code>Expr</code>, suitable to be passed into <code>eval</code>.</p>
<p>For example,</p>
<pre><code class="julia hljs">julia&gt; <span class="hljs-meta">@syms</span> a b
(a, b)

julia&gt; toexpr(a+b)
:((+)(a, b))

julia&gt; toexpr(a+b) |&gt; dump
<span class="hljs-built_in">Expr</span>
  head: <span class="hljs-built_in">Symbol</span> call
  args: <span class="hljs-built_in">Array</span>{<span class="hljs-built_in">Any</span>}((<span class="hljs-number">3</span>,))
    <span class="hljs-number">1</span>: + (<span class="hljs-keyword">function</span> of type typeof(+))
    <span class="hljs-number">2</span>: <span class="hljs-built_in">Symbol</span> a
    <span class="hljs-number">3</span>: <span class="hljs-built_in">Symbol</span> b</code></pre>
<p>Note that the function is an actual function object.</p>
<p>For more complex expressions, see other code-related combinators,</p>
<p>Namely <code>Assignment</code>, <code>Let</code>, <code>Func</code>, <code>SetArray</code>, <code>MakeArray</code>, <code>MakeSparseArray</code> and <code>MakeTuple</code>.</p>
<p>To make your own type convertible to Expr using <code>toexpr</code> define <code>toexpr&#40;x, st&#41;</code> and forward the state <code>st</code> in internal calls to <code>toexpr</code>. <code>st</code> is state used to know when to leave something like <code>y&#40;t&#41;</code> as it is or when to make it <code>var&quot;y&#40;t&#41;&quot;</code>. E.g. when <code>y&#40;t&#41;</code> is itself the argument of a function rather than <code>y</code>.</p>
</div>
  </div>

<h2 id="code_combinators"><a href="#code_combinators" class="header-anchor">Code Combinators</a></h2>
<p>These are all exported when you do <code>using SymbolicUtils.Code</code></p>
  <div class="docstring">
      <h2 class="doc-header" id="Assignment">
        <a href="#Assignment">Assignment</a>
        <div class="doc-type"></div></h2>
      <div class="doc-content"><pre><code class="julia hljs">Assignment(lhs, rhs)</code></pre>
<p>An assignment expression. Shorthand <code>lhs ← rhs</code> &#40;<code>\leftarrow</code>&#41;</p>
</div>
  </div>

  <div class="docstring">
      <h2 class="doc-header" id="Let">
        <a href="#Let">Let</a>
        <div class="doc-type"></div></h2>
      <div class="doc-content"><pre><code class="julia hljs">Let(assignments, body[, let_block])</code></pre>
<p>A Let block.</p>
<ul>
<li><p><code>assignments</code> is a vector of <code>Assignment</code>s</p>
</li>
<li><p><code>body</code> is the body of the let block</p>
</li>
<li><p><code>let_block</code> boolean &#40;default&#61;true&#41; – do not create a let block if false.</p>
</li>
</ul>
</div>
  </div>

  <div class="docstring">
      <h2 class="doc-header" id="Func">
        <a href="#Func">Func</a>
        <div class="doc-type"></div></h2>
      <div class="doc-content"><pre><code class="julia hljs">Func(args, kwargs, body[, pre])</code></pre>
<p>A function.</p>
<ul>
<li><p><code>args</code> is a vector of expressions</p>
</li>
<li><p><code>kwargs</code> is a vector of <code>Assignment</code>s</p>
</li>
<li><p><code>body</code> is the body of the function</p>
</li>
<li><p><code>pre</code> a vector of expressions to be prepended to the function body,  for example, it could be <code>&#91;Expr&#40;:meta, :inline&#41;, Expr&#40;:meta, :propagate_inbounds&#41;&#93;</code>  to create an <code>@inline @propagate_inbounds</code> function definition.</p>
</li>
</ul>
<p><strong>Special features in <code>args</code></strong>:</p>
<ul>
<li><p>args can contain <code>DestructuredArgs</code></p>
</li>
<li><p>call expressions</p>
</li>
</ul>
<p>For example,</p>
<pre><code class="julia hljs">julia&gt; <span class="hljs-meta">@syms</span> a b c t f(d) x(t) y(t) z(t)
(a, b, c, t, f(::<span class="hljs-built_in">Number</span>)::<span class="hljs-built_in">Number</span>, x(::<span class="hljs-built_in">Number</span>)::<span class="hljs-built_in">Number</span>, y(::<span class="hljs-built_in">Number</span>)::<span class="hljs-built_in">Number</span>, z(::<span class="hljs-built_in">Number</span>)::<span class="hljs-built_in">Number</span>)

julia&gt; func = Func([a,x(t), DestructuredArgs([b, y(t)]), f], <span class="hljs-comment"># args</span>
                   [c ← <span class="hljs-number">2</span>, z(t) ← <span class="hljs-number">42</span>], <span class="hljs-comment"># kwargs</span>
                   f((a + b + c) / x(t) + y(t) + z(t)));

julia&gt; toexpr(func)
:(<span class="hljs-keyword">function</span> (a, <span class="hljs-string">var&quot;x(t)&quot;</span>, <span class="hljs-string">var&quot;##arg#255&quot;</span>, f; c = <span class="hljs-number">2</span>, <span class="hljs-string">var&quot;z(t)&quot;</span> = <span class="hljs-number">42</span>)
      <span class="hljs-keyword">let</span> b = <span class="hljs-string">var&quot;##arg#255&quot;</span>[<span class="hljs-number">1</span>], <span class="hljs-string">var&quot;y(t)&quot;</span> = <span class="hljs-string">var&quot;##arg#255&quot;</span>[<span class="hljs-number">2</span>]
          f((+)(<span class="hljs-string">var&quot;y(t)&quot;</span>, <span class="hljs-string">var&quot;z(t)&quot;</span>, (*)((+)(a, b, c), (inv)(<span class="hljs-string">var&quot;x(t)&quot;</span>))))
      <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span>)</code></pre>
<ul>
<li><p>the second argument is a <code>DestructuredArgs</code>, in the <code>Expr</code> form, it is given a random name, and is expected to receive a vector or tuple of size 2 containing the values of <code>b</code> and <code>y&#40;t&#41;</code>. The let block that is automatically generated &quot;destructures&quot; these arguments.</p>
</li>
<li><p><code>x&#40;t&#41;</code> and <code>y&#40;t&#41;</code> have been replaced with <code>var&quot;x&#40;t&#41;&quot;</code> and <code>var&quot;y&#40;t&#41;&quot;</code> symbols throughout</p>
</li>
</ul>
<p>the generated Expr. This makes sure that we are not actually calling the expressions <code>x&#40;t&#41;</code> or <code>y&#40;t&#41;</code> but instead passing the right values in place of the whole expression.</p>
<ul>
<li><p><code>f</code> is also a function-like symbol, same as <code>x</code> and <code>y</code>, but since the <code>args</code> array contains <code>f</code> as itself rather than as say, <code>f&#40;t&#41;</code>, it does not become a <code>var&quot;f&#40;t&#41;&quot;</code>. The generated function expects a function of one argument to be passed in the position of <code>f</code>.</p>
</li>
</ul>
<p>An example invocation of this function is:</p>
<pre><code class="julia hljs">julia&gt; executable = eval(toexpr(func))
<span class="hljs-comment">#10 (generic function with 1 method)</span>

julia&gt; executable(<span class="hljs-number">1</span>, <span class="hljs-number">2.0</span>, [<span class="hljs-number">2</span>,<span class="hljs-number">3.0</span>], x-&gt;string(x); <span class="hljs-string">var&quot;z(t)&quot;</span> = sqrt(<span class="hljs-number">42</span>))
<span class="hljs-string">&quot;11.98074069840786&quot;</span></code></pre>
</div>
  </div>

  <div class="docstring">
      <h2 class="doc-header" id="SpawnFetch">
        <a href="#SpawnFetch">SpawnFetch</a>
        <div class="doc-type"></div></h2>
      <div class="doc-content"><pre><code class="julia hljs">SpawnFetch{ParallelType}(funcs [, args], reduce)</code></pre>
<p>Run every expression in <code>funcs</code> in its own task, the expression should be a <code>Func</code> object and is passed to <code>Threads.Task&#40;f&#41;</code>. If <code>Func</code> takes arguments, then the arguments must be passed in as <code>args</code>–a vector of vector of arguments to each function in <code>funcs</code>. We don&#39;t use <code>@spawn</code> in order to support RuntimeGeneratedFunctions which disallow closures, instead we interpolate these functions or closures as smaller RuntimeGeneratedFunctions.</p>
<p><code>reduce</code> function is used to combine the results of executing <code>exprs</code>. A SpawnFetch expression returns the reduced result.</p>
<p>Use <code>Symbolics.MultithreadedForm</code> ParallelType from the Symbolics.jl package to get the RuntimeGeneratedFunction version SpawnFetch.</p>
<p><code>ParallelType</code> can be used to define more parallelism types SymbolicUtils supports <code>Multithreaded</code> type. Which spawns threaded tasks.</p>
</div>
  </div>

  <div class="docstring">
      <h2 class="doc-header" id="SetArray">
        <a href="#SetArray">SetArray</a>
        <div class="doc-type"></div></h2>
      <div class="doc-content"><pre><code class="julia hljs">SetArray(inbounds, arr, elems)</code></pre>
<p>An expression representing setting of elements of <code>arr</code>.</p>
<p>By default, every element of <code>elems</code> is copied over to <code>arr</code>,</p>
<p>but if <code>elems</code> contains <code>AtIndex&#40;i, val&#41;</code> objects, then <code>arr&#91;i&#93; &#61; val</code> is performed in its place.</p>
<p><code>inbounds</code> is a boolean flag, <code>true</code> surrounds the resulting expression in an <code>@inbounds</code>.</p>
</div>
  </div>

  <div class="docstring">
      <h2 class="doc-header" id="MakeArray">
        <a href="#MakeArray">MakeArray</a>
        <div class="doc-type"></div></h2>
      <div class="doc-content"><pre><code class="julia hljs">MakeArray(elems, similarto, [output_eltype=<span class="hljs-literal">nothing</span>])</code></pre>
<p>An expression which constructs an array.</p>
<ul>
<li><p><code>elems</code> is the output array</p>
</li>
<li><p><code>similarto</code> can either be a type, or some symbol that is an array whose type needs to  be emulated. If <code>similarto</code> is a StaticArrays.SArray, then the output array is also  created as an <code>SArray</code>, similarly, an <code>Array</code> will result in an <code>Array</code>, and a <code>LabelledArrays.SLArray</code> will result in a labelled static array.</p>
</li>
<li><p><code>output_eltype</code>: if set, then forces the element type of the output array to be this.  by default, the output type is inferred automatically.</p>
</li>
</ul>
<p>You can define:</p>
<pre><code class="julia hljs"><span class="hljs-meta">@inline</span> <span class="hljs-keyword">function</span> create_array(A::<span class="hljs-built_in">Type</span>{&lt;:MyArray},a
                              ::<span class="hljs-built_in">Nothing</span>, d::<span class="hljs-built_in">Val</span>{dims}, elems...) <span class="hljs-keyword">where</span> dims

<span class="hljs-comment"># and</span>

<span class="hljs-meta">@inlline</span> <span class="hljs-keyword">function</span> create_array(::<span class="hljs-built_in">Type</span>{&lt;:MyArray}, T, ::<span class="hljs-built_in">Val</span>{dims}, elems...) <span class="hljs-keyword">where</span> dims</code></pre>
<p>which creates an array of size <code>dims</code> using the elements <code>elems</code> and eltype <code>T</code>, to allow <code>MakeArray</code> to create arrays similarto <code>MyArray</code>s.</p>
</div>
  </div>

  <div class="docstring">
      <h2 class="doc-header" id="MakeSparseArray">
        <a href="#MakeSparseArray">MakeSparseArray</a>
        <div class="doc-type"></div></h2>
      <div class="doc-content"><pre><code class="julia hljs">MakeSpaseArray(array)</code></pre>
<p>An expression which creates a <code>SparseMatrixCSC</code> or a <code>SparseVector</code>.</p>
<p>The generated expression contains the sparsity information of <code>array</code>,</p>
<p>it only creates the <code>nzval</code> field at run time.</p>
</div>
  </div>

  <div class="docstring">
      <h2 class="doc-header" id="MakeTuple">
        <a href="#MakeTuple">MakeTuple</a>
        <div class="doc-type"></div></h2>
      <div class="doc-content"><pre><code class="julia hljs">MakeTuple(tup)</code></pre>
<p>Make a Tuple from a tuple of expressions.</p>
</div>
  </div>

  <div class="docstring">
      <h2 class="doc-header" id="LiteralExpr">
        <a href="#LiteralExpr">LiteralExpr</a>
        <div class="doc-type"></div></h2>
      <div class="doc-content"><pre><code class="julia hljs">LiteralExpr(ex)</code></pre>
<p>Literally <code>ex</code>, an <code>Expr</code>. <code>toexpr</code> on <code>LiteralExpr</code> recursively calls <code>toexpr</code> on any interpolated symbolic expressions.</p>
</div>
  </div>

<div class="page-foot">
  <div class="copyright">
    &copy; Shashi Gowda, Yingbo Ma, Mason Protter. Last modified: June 15, 2022. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and <a href="https://github.com/tlienart/PkgPage.jl">PkgPage.jl</a>.
  </div>
</div>
</div><!-- CONTENT ENDS HERE -->
    </div>  <!-- div: content container -->
    
    <script>
        var els =  document.querySelectorAll(".language-julia")
        for (var i=0, l = els.length; i < l; i++) {
            var el = els[i]
            var out = el.parentNode.nextSibling
            if (out.tagName === "PRE") {
                out.className = out.className + " code-output"
            }
        }
    </script>
    
        


    
  </body>
</html>
