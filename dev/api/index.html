<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · SymbolicUtils.jl</title><meta name="title" content="API Reference · SymbolicUtils.jl"/><meta property="og:title" content="API Reference · SymbolicUtils.jl"/><meta property="twitter:title" content="API Reference · SymbolicUtils.jl"/><meta name="description" content="Documentation for SymbolicUtils.jl."/><meta property="og:description" content="Documentation for SymbolicUtils.jl."/><meta property="twitter:description" content="Documentation for SymbolicUtils.jl."/><meta property="og:url" content="https://docs.sciml.ai/SymbolicUtils/stable/api/"/><meta property="twitter:url" content="https://docs.sciml.ai/SymbolicUtils/stable/api/"/><link rel="canonical" href="https://docs.sciml.ai/SymbolicUtils/stable/api/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SymbolicUtils.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">SymbolicUtils.jl — Symbolic programming in Julia</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../manual/variants/">Variant structure and types</a></li><li><a class="tocitem" href="../manual/rewrite/">Term Rewriting</a></li><li><a class="tocitem" href="../manual/interface/">Interfacing with SymbolicUtils.jl</a></li><li><a class="tocitem" href="../manual/codegen/">Code generation</a></li><li><a class="tocitem" href="../manual/caching/">Caching recursive functions</a></li><li><a class="tocitem" href="../manual/recursive_utils/">Recursive utility functions</a></li></ul></li><li class="is-active"><a class="tocitem" href>API Reference</a><ul class="internal"><li><a class="tocitem" href="#Symbols-and-Terms"><span>Symbols and Terms</span></a></li><li><a class="tocitem" href="#Rewriting-System"><span>Rewriting System</span></a></li><li><a class="tocitem" href="#Simplification-and-Transformation"><span>Simplification and Transformation</span></a></li><li><a class="tocitem" href="#Polynomial-Forms"><span>Polynomial Forms</span></a></li></ul></li><li><a class="tocitem" href="../upgrade/">Upgrade to SymbolicUtils v1</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/master/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><h2 id="Symbols-and-Terms"><a class="docs-heading-anchor" href="#Symbols-and-Terms">Symbols and Terms</a><a id="Symbols-and-Terms-1"></a><a class="docs-heading-anchor-permalink" href="#Symbols-and-Terms" title="Permalink"></a></h2><h3 id="Creating-Symbols-and-Terms"><a class="docs-heading-anchor" href="#Creating-Symbols-and-Terms">Creating Symbols and Terms</a><a id="Creating-Symbols-and-Terms-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-Symbols-and-Terms" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="SymbolicUtils.@syms-api"><a class="docstring-binding" href="#SymbolicUtils.@syms-api"><code>SymbolicUtils.@syms</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@syms &lt;lhs_expr&gt;[::T1] &lt;lhs_expr&gt;[::T2]...</code></pre><p>For instance:</p><pre><code class="language-julia hljs">@syms foo::Real bar baz(x, y::Real)::Complex</code></pre><p>Create one or more variables. <code>&lt;lhs_expr&gt;</code> can be just a symbol in which case it will be the name of the variable, or a function call in which case a function-like variable which has the same name as the function being called. The Sym type, or in the case of a function-like Sym, the output type of calling the function can be set using the <code>::T</code> syntax.</p><p><strong>Examples:</strong></p><ul><li><code>@syms foo bar::Real baz::Int</code> will create variable <code>foo</code> of symtype <code>Number</code> (the default), <code>bar</code> of symtype <code>Real</code> and <code>baz</code> of symtype <code>Int</code></li><li><code>@syms f(x) g(y::Real, x)::Int h(a::Int, f(b))</code> creates 1-arg <code>f</code> 2-arg <code>g</code> and 2 arg <code>h</code>. The second argument to <code>h</code> must be a one argument function-like variable. So, <code>h(1, g)</code> will fail and <code>h(1, f)</code> will work.</li></ul><p><strong>Formal syntax</strong></p><p>Following is a semi-formal CFG of the syntax accepted by this macro:</p><pre><code class="language-python hljs"># any variable accepted by this macro must be a `var`.
# `var` can represent a quantity (`value`) or a function `(fn)`.
var = value | fn
# A `value` is represented as a name followed by a suffix
value = name suffix
# A `name` can be a valid Julia identifier
name = ident |
# Or it can be an interpolated variable, in which case `ident` is assumed to refer to
# a variable in the current scope of type `Symbol` containing the name of this variable.
# Note that in this case the created symbolic variable will be bound to a randomized
# Julia identifier.
       &quot;$&quot; ident |
# Or it can be of the form `Foo.Bar.baz` referencing a value accessible as `Foo.Bar.baz`
# in the current scope.
       getproperty_literal
getproperty_literal = ident &quot;.&quot; getproperty_literal | ident &quot;.&quot; ident
# The `suffix` can be empty (no suffix) which defaults the type to `Number`
suffix = &quot;&quot; |
# or it can be a type annotation (setting the type of the prefix). The shape of the result
# is inferred from the type as best it can be. In particular, `Array{T, N}` is inferred
# to have shape `Unknown(N)`.
         &quot;::&quot; type |
# or it can be a shape annotation, which sets the shape to the one specified by `ranges`.
# The type defaults to `Array{Number, length(ranges)}`
         &quot;[&quot; ranges &quot;]&quot; |
# lastly, it can be a combined shape and type annotation. Here, the type annotation
# sets the `eltype` of the symbolic array.
         &quot;[&quot; ranges &quot;]::&quot; type
# `ranges` is either a single `range` or a single range followed by one or more `ranges`.
ranges = range | range &quot;,&quot; ranges
# A `range` is simply two bounds separated by a colon, as standard Julia ranges work.
# The range must be non-empty. Each bound can be a literal integer or an identifier
# representing an integer in the current scope.
range = (int | ident) &quot;:&quot; (int | ident) |
# Alternatively, a range can be a Julia expression that evaluates to a range. All identifiers
# used in `expr` are assumed to exist in the current scope.
        expr |
# Alternatively, a range can be a Julia expression evaluating to an iterable of ranges,
# followed by the splat operator.
        expr &quot;...&quot;
# A function is represented by a function-call syntax `fncall` followed by the `suffix`
# above. The type and shape from `suffix` represent the type and shape of the value
# returned by the symbolic function.
fn = fncall suffix
# a function call is a call `head` followed by a parenthesized list of arguments.
fncall = head &quot;(&quot; args &quot;)&quot;
# A function call head can be a name, representing the name of the symbolic function.
head = ident |
# Alternatively, it can be a parenthesized type-annotated name, where the type annotation
# represents the intended supertype of the function. In other words, if this symbolic
# function were to be replaced by an &quot;actual&quot; function, the type-annotation constrains the
# type of the &quot;actual&quot; function.
       &quot;(&quot; ident &quot;::&quot; type &quot;)&quot;
# Arguments to a function is a list of one or more arguments
args = arg | arg &quot;,&quot; args
# An argument can take the syntax of a variable (which means we can represent functions of
# functions of functions of...). The type of the variable constrains the type of the
# corresponding argument of the function. The name and shape information is discarded.
arg = var |
# Or an argument can be an unnamed type-annotation, which constrains the type without
# requiring a name.
      &quot;::&quot; type |
# Or an argument can be the identifier `..`, which is used as a stand-in for `Vararg{Any}`
      &quot;..&quot; |
# Or an argument can be a type-annotated `..`, representing `Vararg{type}`. Note that this
# and the previous version of `arg` can only be the last element in `args` due to Julia&#39;s
# `Tuple` semantics.
      &quot;(..)::&quot; type |
# Or an argument can be a Julia expression followed by a splat operator. This assumes the
# expression evaluates to an iterable of symbolic variables whose `symtype` should be used
# as the argument types. Note that `expr` may be evaluated multiple times in the macro
# expansion.
      expr &quot;...&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/3ff2817fbbc02db556e01d31e647a20c057fd0a3/src/syms.jl#L1-L102">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SymbolicUtils.term-api"><a class="docstring-binding" href="#SymbolicUtils.term-api"><code>SymbolicUtils.term</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">term(f, args...; vartype = SymReal, type = promote_symtype(f, symtype.(args)...), shape = promote_shape(f, SymbolicUtils.shape.(args)...))</code></pre><p>Create a symbolic term with operation <code>f</code> and arguments <code>args</code>.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: The operation or function head of the term</li><li><code>args...</code>: The arguments to the operation</li><li><code>vartype</code>: The variant type for the term (default: <code>SymReal</code>)</li><li><code>type</code>: The symbolic type of the term. If not provided, it is inferred using <code>promote_symtype</code> on the function and argument types.</li><li><code>shape</code>: The shape of the term. If not provided, it is inferred using <code>promote_shape</code> on the function and argument shapes.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @syms x y
(x, y)

julia&gt; term(+, x, y)
x + y

julia&gt; term(sin, x)
sin(x)

julia&gt; term(^, x, 2)
x^2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/3ff2817fbbc02db556e01d31e647a20c057fd0a3/src/types.jl#L752-L778">source</a></section></details></article><h3 id="Metadata"><a class="docs-heading-anchor" href="#Metadata">Metadata</a><a id="Metadata-1"></a><a class="docs-heading-anchor-permalink" href="#Metadata" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="SymbolicUtils.hasmetadata"><a class="docstring-binding" href="#SymbolicUtils.hasmetadata"><code>SymbolicUtils.hasmetadata</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">hasmetadata(s::Symbolic, ctx)</code></pre><p>Check if a symbolic expression has metadata for a given context.</p><p><strong>Arguments</strong></p><ul><li><code>s::Symbolic</code>: The symbolic expression to check</li><li><code>ctx</code>: The metadata context key (typically a DataType)</li></ul><p><strong>Returns</strong></p><ul><li><code>true</code> if the expression has metadata for the given context, <code>false</code> otherwise</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @syms x
x

julia&gt; hasmetadata(x, Float64)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/3ff2817fbbc02db556e01d31e647a20c057fd0a3/src/types.jl#L790-L810">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SymbolicUtils.getmetadata"><a class="docstring-binding" href="#SymbolicUtils.getmetadata"><code>SymbolicUtils.getmetadata</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">getmetadata(s::Symbolic, ctx)</code></pre><p>Retrieve metadata associated with a symbolic expression for a given context.</p><p><strong>Arguments</strong></p><ul><li><code>s::Symbolic</code>: The symbolic expression</li><li><code>ctx</code>: The metadata context key (typically a DataType)</li></ul><p><strong>Returns</strong></p><p>The metadata value associated with the given context</p><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code> if the expression does not have metadata for the given context</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @syms x::Float64
x

julia&gt; getmetadata(x, symtype)  # Get the type metadata
Float64</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/3ff2817fbbc02db556e01d31e647a20c057fd0a3/src/types.jl#L815-L838">source</a></section><section><div><pre><code class="language-julia hljs">getmetadata(s::Symbolic, ctx, default)</code></pre><p>Retrieve metadata associated with a symbolic expression for a given context, returning a default value if not found.</p><p><strong>Arguments</strong></p><ul><li><code>s::Symbolic</code>: The symbolic expression</li><li><code>ctx</code>: The metadata context key (typically a DataType)</li><li><code>default</code>: The default value to return if metadata is not found</li></ul><p><strong>Returns</strong></p><p>The metadata value associated with the given context, or <code>default</code> if not found</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @syms x
x

julia&gt; getmetadata(x, Float64, &quot;no type&quot;)
&quot;no type&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/3ff2817fbbc02db556e01d31e647a20c057fd0a3/src/types.jl#L848-L870">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SymbolicUtils.setmetadata"><a class="docstring-binding" href="#SymbolicUtils.setmetadata"><code>SymbolicUtils.setmetadata</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">setmetadata(s::Symbolic, ctx::DataType, val)</code></pre><p>Set metadata for a symbolic expression in a given context.</p><p><strong>Arguments</strong></p><ul><li><code>s::Symbolic</code>: The symbolic expression</li><li><code>ctx::DataType</code>: The metadata context key</li><li><code>val</code>: The metadata value to set</li></ul><p><strong>Returns</strong></p><p>A new symbolic expression with the updated metadata</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @syms x
x

julia&gt; x_with_meta = setmetadata(x, Float64, &quot;custom value&quot;)
x

julia&gt; getmetadata(x_with_meta, Float64)
&quot;custom value&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/3ff2817fbbc02db556e01d31e647a20c057fd0a3/src/types.jl#L900-L924">source</a></section></details></article><h3 id="Type-Promotion"><a class="docs-heading-anchor" href="#Type-Promotion">Type Promotion</a><a id="Type-Promotion-1"></a><a class="docs-heading-anchor-permalink" href="#Type-Promotion" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="SymbolicUtils.promote_symtype-api"><a class="docstring-binding" href="#SymbolicUtils.promote_symtype-api"><code>SymbolicUtils.promote_symtype</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">promote_symtype(f, Ts...) -&gt; DataType
</code></pre><p>The result of applying <code>f</code> to arguments of <a href="../manual/variants/#SymbolicUtils.symtype"><code>SymbolicUtils.symtype</code></a> <code>Ts...</code></p><pre><code class="language-julia-repl hljs">julia&gt; promote_symtype(+, Real, Real)
Real

julia&gt; promote_symtype(+, Complex, Real)
Number

julia&gt; @syms f(x)::Complex
(f(::Number)::Complex,)

julia&gt; promote_symtype(f, Number)
Complex</code></pre><p>When constructing expressions without an explicit symtype, <code>promote_symtype</code> is used to figure out the symtype of the Term.</p><p>It is recommended that all type arguments be annotated with <a href="../manual/variants/#SymbolicUtils.TypeT"><code>SymbolicUtils.TypeT</code></a> and one method be implemented for any combination of <code>f</code> and the number of arguments. For example, one method is implemented for unary <code>-</code> and one method for binary <code>-</code>. Each method has an <code>if..elseif</code> chain to handle possible types. Any call to <code>promote_type</code> should be typeasserted with <code>::TypeT</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/3ff2817fbbc02db556e01d31e647a20c057fd0a3/src/types.jl#L939-L966">source</a></section><section><div><pre><code class="language-julia hljs">promote_symtype(f::FnType{X,Y}, arg_symtypes...)</code></pre><p>The output symtype of applying variable <code>f</code> to arguments of symtype <code>arg_symtypes...</code>. if the arguments are of the wrong type then this function will error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/3ff2817fbbc02db556e01d31e647a20c057fd0a3/src/types.jl#L1043-L1048">source</a></section></details></article><h2 id="Rewriting-System"><a class="docs-heading-anchor" href="#Rewriting-System">Rewriting System</a><a id="Rewriting-System-1"></a><a class="docs-heading-anchor-permalink" href="#Rewriting-System" title="Permalink"></a></h2><h3 id="Rule-Creation"><a class="docs-heading-anchor" href="#Rule-Creation">Rule Creation</a><a id="Rule-Creation-1"></a><a class="docs-heading-anchor-permalink" href="#Rule-Creation" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="SymbolicUtils.@rule"><a class="docstring-binding" href="#SymbolicUtils.@rule"><code>SymbolicUtils.@rule</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@rule LHS =&gt; RHS</code></pre><p>Creates a <code>Rule</code> object. A rule object is callable, and  takes an expression and rewrites it if it matches the LHS pattern to the RHS pattern, returns <code>nothing</code> otherwise. The rule language is described below.</p><p>LHS can be any possibly nested function call expression where any of the arguments can optionally be a Slot (<code>~x</code>), Default Value Slot (<code>~!x</code> also called DefSlot) or a Segment  (<code>~~x</code>) (described below).</p><p>If an expression matches LHS entirely, then it is rewritten to the pattern in the RHS. Slot, DefSlot and Segment variables on the RHS will substitute the result of the matches found for these variables in the LHS.</p><p><strong>Slot</strong>:</p><p>A Slot variable is written as <code>~x</code> and matches a single expression. <code>x</code> is the name of the variable. If a slot appears more than once in an LHS expression then expression matched at every such location must be equal (as shown by <code>isequal</code>).</p><p><em>Example:</em></p><p>Simple rule to turn any <code>sin</code> into <code>cos</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; @syms a b c
(a, b, c)

julia&gt; r = @rule sin(~x) =&gt; cos(~x)
sin(~x) =&gt; cos(~x)

julia&gt; r(sin(1+a))
cos((1 + a))</code></pre><p>A rule with 2 segment variables</p><pre><code class="language-julia-repl hljs">julia&gt; r = @rule sin(~x + ~y) =&gt; sin(~x)*cos(~y) + cos(~x)*sin(~y)
sin(~x + ~y) =&gt; sin(~x) * cos(~y) + cos(~x) * sin(~y)

julia&gt; r(sin(a + b))
cos(a)*sin(b) + sin(a)*cos(b)</code></pre><p>A rule that matches two of the same expressions:</p><pre><code class="language-julia-repl hljs">julia&gt; r = @rule sin(~x)^2 + cos(~x)^2 =&gt; 1
sin(~x) ^ 2 + cos(~x) ^ 2 =&gt; 1

julia&gt; r(sin(2a)^2 + cos(2a)^2)
1

julia&gt; r(sin(2a)^2 + cos(a)^2)
# nothing</code></pre><p><strong>DefSlot</strong>:</p><p>A DefSlot variable is written as <code>~!x</code>. Works like a normal slot, but can also take default values if not present in the expression.</p><p><em>Example in power:</em></p><pre><code class="language-julia-repl hljs">julia&gt; r_pow = @rule (~x)^(~!m) =&gt; ~m
(~x) ^ ~(!m) =&gt; ~m

julia&gt; r_pow(x^2)
2

julia&gt; r_pow(x)
1</code></pre><p><em>Example in sum:</em></p><pre><code class="language-julia-repl hljs">julia&gt; r_sum = @rule ~x + ~!y =&gt; ~y
~x + ~(!y) =&gt; ~y

julia&gt; r_sum(x+2)
x

julia&gt; r_sum(x)
0</code></pre><p>Currently DefSlot is implemented in:</p><table><tr><th style="text-align: right">Operation</th><th style="text-align: right">Default value</th></tr><tr><td style="text-align: right">*</td><td style="text-align: right">1</td></tr><tr><td style="text-align: right">+</td><td style="text-align: right">0</td></tr><tr><td style="text-align: right">2nd argument of ^</td><td style="text-align: right">1</td></tr></table><p><strong>Segment</strong>:</p><p>A Segment variable is written as <code>~~x</code> and matches zero or more expressions in the function call.</p><p><em>Example:</em></p><p>This implements the distributive property of multiplication: <code>+(~~ys)</code> matches expressions like <code>a + b</code>, <code>a+b+c</code> and so on. On the RHS <code>~~ys</code> presents as any old julia array.</p><pre><code class="language-julia-repl hljs">julia&gt; r = @rule ~x * +((~~ys)) =&gt; sum(map(y-&gt; ~x * y, ~~ys));

julia&gt; r(2 * (a+b+c))
((2 * a) + (2 * b) + (2 * c))</code></pre><p><strong>Predicates</strong>:</p><p>There are two kinds of predicates, namely over slot variables and over the whole rule. For the former, predicates can be used on both <code>~x</code> and <code>~~x</code> by using the <code>~x::f</code> or <code>~~x::f</code>. Here <code>f</code> can be any julia function. In the case of a slot the function gets a single matched subexpression, in the case of segment, it gets an array of matched expressions.</p><p>The predicate should return <code>true</code> if the current match is acceptable, and <code>false</code> otherwise.</p><pre><code class="language-julia-repl hljs">julia&gt; two_πs(x::Number) = abs(round(x/(2π)) - x/(2π)) &lt; 10^-9
two_πs (generic function with 1 method)

julia&gt; two_πs(x) = false
two_πs (generic function with 2 methods)

julia&gt; r = @rule sin(~~x + ~y::two_πs + ~~z) =&gt; sin(+(~~x..., ~~z...))
sin(~(~x) + ~(y::two_πs) + ~(~z)) =&gt; sin(+(~(~x)..., ~(~z)...))

julia&gt; r(sin(a+3π))

julia&gt; r(sin(a+6π))
sin(a)

julia&gt; r(sin(a+6π+c))
sin((a + c))</code></pre><p>Predicate function gets an array of values if attached to a segment variable (<code>~~x</code>).</p><p>For the predicate over the whole rule, use <code>@rule &lt;LHS&gt; =&gt; &lt;RHS&gt; where &lt;predicate&gt;</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; @syms a b;

julia&gt; predicate(x) = x === a;

julia&gt; r = @rule ~x =&gt; ~x where predicate(~x);

julia&gt; r(a)
a

julia&gt; r(b) === nothing
true</code></pre><p>Note that this is syntactic sugar and that it is the same as something like <code>@rule ~x =&gt; f(~x) ? ~x : nothing</code>.</p><p><strong>Debugging Rules</strong>: Note that if the RHS is a single tilde <code>~</code>, then the rule returns a a dictionary of all [slot variable, expression matched], this is useful for debugging.</p><p><em>Example:</em></p><pre><code class="language-julia-repl hljs">julia&gt; r = @rule (~x + (~y)^(~m)) =&gt; ~
~x + (~y) ^ ~m =&gt; (~)

julia&gt; r(a + b^2)
Base.ImmutableDict{Symbol, Any} with 5 entries:
  :MATCH =&gt; a + b^2
  :m     =&gt; 2
  :y     =&gt; b
  :x     =&gt; a
  :____  =&gt; nothing</code></pre><p><strong>Context</strong>:</p><p><em>In predicates</em>: Contextual predicates are functions wrapped in the <code>Contextual</code> type. The function is called with 2 arguments: the expression and a context object passed during a call to the Rule object (maybe done by passing a context to <code>simplify</code> or a <code>RuleSet</code> object).</p><p>The function can use the inputs however it wants, and must return a boolean indicating whether the predicate holds or not.</p><p><em>In the consequent pattern</em>: Use <code>(@ctx)</code> to access the context object on the right hand side of an expression.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/3ff2817fbbc02db556e01d31e647a20c057fd0a3/src/rule.jl#L285-L475">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SymbolicUtils.@acrule"><a class="docstring-binding" href="#SymbolicUtils.@acrule"><code>SymbolicUtils.@acrule</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@acrule(lhs =&gt; rhs)</code></pre><p>Create an associative-commutative rule that matches all permutations of the arguments.</p><p>This macro creates a rule that can match patterns regardless of the order of arguments in associative and commutative operations like addition and multiplication.</p><p><strong>Arguments</strong></p><ul><li><code>lhs</code>: The pattern to match (left-hand side)</li><li><code>rhs</code>: The replacement expression (right-hand side)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @syms x y z
(x, y, z)

julia&gt; r = @acrule x + y =&gt; 2x  # Matches both x + y and y + x
ACRule(x + y =&gt; 2x)

julia&gt; r(x + y)
2x

julia&gt; r(y + x)
2x</code></pre><p>See also: <a href="#SymbolicUtils.@rule"><code>@rule</code></a>, <a href="@ref"><code>@ordered_acrule</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/3ff2817fbbc02db556e01d31e647a20c057fd0a3/src/rule.jl#L551-L579">source</a></section></details></article><h3 id="Rewriters"><a class="docs-heading-anchor" href="#Rewriters">Rewriters</a><a id="Rewriters-1"></a><a class="docs-heading-anchor-permalink" href="#Rewriters" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="SymbolicUtils.Rewriters"><a class="docstring-binding" href="#SymbolicUtils.Rewriters"><code>SymbolicUtils.Rewriters</code></a> — <span class="docstring-category">Module</span></summary><section><div><p>A rewriter is any function which takes an expression and returns an expression or <code>nothing</code>. If <code>nothing</code> is returned that means there was no changes applicable to the input expression.</p><p>The <code>Rewriters</code> module contains some types which create and transform rewriters.</p><ul><li><code>Empty()</code> is a rewriter which always returns <code>nothing</code></li><li><code>Chain(itr)</code> chain an iterator of rewriters into a single rewriter which applies  each chained rewriter in the given order.  If a rewriter returns <code>nothing</code> this is treated as a no-change.</li><li><code>RestartedChain(itr)</code> like <code>Chain(itr)</code> but restarts from the first rewriter once on the  first successful application of one of the chained rewriters.</li><li><code>IfElse(cond, rw1, rw2)</code> runs the <code>cond</code> function on the input, applies <code>rw1</code> if cond  returns true, <code>rw2</code> if it returns false</li><li><code>If(cond, rw)</code> is the same as <code>IfElse(cond, rw, Empty())</code></li><li><code>Prewalk(rw; threaded=false, thread_cutoff=100)</code> returns a rewriter which does a pre-order  traversal of a given expression and applies the rewriter <code>rw</code>. Note that if  <code>rw</code> returns <code>nothing</code> when a match is not found, then <code>Prewalk(rw)</code> will  also return nothing unless a match is found at every level of the walk.  <code>threaded=true</code> will use multi threading for traversal. <code>thread_cutoff</code> is  the minimum number of nodes in a subtree which should be walked in a  threaded spawn.</li><li><code>Postwalk(rw; threaded=false, thread_cutoff=100)</code> similarly does post-order traversal.</li><li><code>Fixpoint(rw)</code> returns a rewriter which applies <code>rw</code> repeatedly until there are no changes to be made.</li><li><code>FixpointNoCycle</code> behaves like <a href="#SymbolicUtils.Rewriters.Fixpoint"><code>Fixpoint</code></a> but instead it applies <code>rw</code> repeatedly only while it is returning new results.</li><li><code>PassThrough(rw)</code> returns a rewriter which if <code>rw(x)</code> returns <code>nothing</code> will instead  return <code>x</code> otherwise will return <code>rw(x)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/3ff2817fbbc02db556e01d31e647a20c057fd0a3/src/rewriters.jl#L1-L31">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SymbolicUtils.Rewriters.Empty"><a class="docstring-binding" href="#SymbolicUtils.Rewriters.Empty"><code>SymbolicUtils.Rewriters.Empty</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Empty()</code></pre><p>A rewriter that always returns <code>nothing</code>, indicating no rewrite occurred.</p><p>This is useful as a placeholder or for conditional rewriting patterns.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Empty()(x)
nothing</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/3ff2817fbbc02db556e01d31e647a20c057fd0a3/src/rewriters.jl#L40-L52">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SymbolicUtils.Rewriters.IfElse"><a class="docstring-binding" href="#SymbolicUtils.Rewriters.IfElse"><code>SymbolicUtils.Rewriters.IfElse</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">IfElse(cond, yes, no)</code></pre><p>A conditional rewriter that applies <code>yes</code> if <code>cond(x)</code> is true, otherwise applies <code>no</code>.</p><p><strong>Arguments</strong></p><ul><li><code>cond</code>: A function that returns true or false for the input</li><li><code>yes</code>: The rewriter to apply if the condition is true</li><li><code>no</code>: The rewriter to apply if the condition is false</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; r = IfElse(x -&gt; x &gt; 0, x -&gt; -x, x -&gt; x)
julia&gt; r(5)  # Returns -5
julia&gt; r(-3) # Returns -3</code></pre><p>See also: <a href="#SymbolicUtils.Rewriters.If"><code>If</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/3ff2817fbbc02db556e01d31e647a20c057fd0a3/src/rewriters.jl#L60-L78">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SymbolicUtils.Rewriters.If"><a class="docstring-binding" href="#SymbolicUtils.Rewriters.If"><code>SymbolicUtils.Rewriters.If</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">If(cond, yes)</code></pre><p>A conditional rewriter that applies <code>yes</code> if <code>cond(x)</code> is true, otherwise returns the input unchanged.</p><p>This is equivalent to <code>IfElse(cond, yes, Empty())</code>.</p><p><strong>Arguments</strong></p><ul><li><code>cond</code>: A function that returns true or false for the input</li><li><code>yes</code>: The rewriter to apply if the condition is true</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; r = If(x -&gt; x &gt; 0, x -&gt; -x)
julia&gt; r(5)  # Returns -5
julia&gt; r(-3) # Returns -3 (unchanged)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/3ff2817fbbc02db556e01d31e647a20c057fd0a3/src/rewriters.jl#L91-L108">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SymbolicUtils.Rewriters.Chain"><a class="docstring-binding" href="#SymbolicUtils.Rewriters.Chain"><code>SymbolicUtils.Rewriters.Chain</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Chain(rws; stop_on_match=false)</code></pre><p>Apply a sequence of rewriters to an expression, chaining the results.</p><p>Each rewriter in the chain receives the result of the previous rewriter. If a rewriter returns <code>nothing</code>, the input is passed unchanged to the next rewriter.</p><p><strong>Arguments</strong></p><ul><li><code>rws</code>: A collection of rewriters to apply in sequence</li><li><code>stop_on_match</code>: If true, stop at the first rewriter that produces a change</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; r1 = @rule sin(~x)^2 + cos(~x)^2 =&gt; 1
julia&gt; r2 = @rule sin(2*(~x)) =&gt; 2*sin(~x)*cos(~x)
julia&gt; chain = Chain([r1, r2])
julia&gt; chain(sin(x)^2 + cos(x)^2)  # Returns 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/3ff2817fbbc02db556e01d31e647a20c057fd0a3/src/rewriters.jl#L111-L130">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SymbolicUtils.Rewriters.RestartedChain"><a class="docstring-binding" href="#SymbolicUtils.Rewriters.RestartedChain"><code>SymbolicUtils.Rewriters.RestartedChain</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RestartedChain(rws)</code></pre><p>Apply rewriters in sequence, restarting the chain when any rewriter produces a change.</p><p>When any rewriter in the chain produces a non-nothing result, the entire chain is restarted with that result as the new input.</p><p><strong>Arguments</strong></p><ul><li><code>rws</code>: A collection of rewriters to apply</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; r1 = @rule ~x + ~x =&gt; 2 * ~x
julia&gt; r2 = @rule 2 * ~x =&gt; ~x * 2
julia&gt; chain = RestartedChain([r1, r2])
julia&gt; chain(x + x)  # Applies r1, then restarts and applies r2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/3ff2817fbbc02db556e01d31e647a20c057fd0a3/src/rewriters.jl#L169-L187">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SymbolicUtils.Rewriters.Fixpoint"><a class="docstring-binding" href="#SymbolicUtils.Rewriters.Fixpoint"><code>SymbolicUtils.Rewriters.Fixpoint</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Fixpoint(rw)</code></pre><p>Apply a rewriter repeatedly until a fixed point is reached.</p><p>The rewriter is applied repeatedly until the output equals the input (either by identity or by <code>isequal</code>), indicating a fixed point has been reached.</p><p><strong>Arguments</strong></p><ul><li><code>rw</code>: The rewriter to apply repeatedly</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; r = @rule ~x + ~x =&gt; 2 * ~x
julia&gt; fp = Fixpoint(r)
julia&gt; fp(x + x + x + x)  # Keeps applying until no more changes</code></pre><p>See also: <a href="#SymbolicUtils.Rewriters.FixpointNoCycle"><code>FixpointNoCycle</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/3ff2817fbbc02db556e01d31e647a20c057fd0a3/src/rewriters.jl#L219-L238">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SymbolicUtils.Rewriters.FixpointNoCycle"><a class="docstring-binding" href="#SymbolicUtils.Rewriters.FixpointNoCycle"><code>SymbolicUtils.Rewriters.FixpointNoCycle</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">FixpointNoCycle(rw)</code></pre><p><code>FixpointNoCycle</code> behaves like <a href="#SymbolicUtils.Rewriters.Fixpoint"><code>Fixpoint</code></a>, but returns a rewriter which applies <code>rw</code> repeatedly until  it produces a result that was already produced before, for example,  if the repeated application of <code>rw</code> produces results <code>a, b, c, d, b</code> in order,  <code>FixpointNoCycle</code> stops because <code>b</code> has been already produced. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/3ff2817fbbc02db556e01d31e647a20c057fd0a3/src/rewriters.jl#L256-L264">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SymbolicUtils.Rewriters.Postwalk"><a class="docstring-binding" href="#SymbolicUtils.Rewriters.Postwalk"><code>SymbolicUtils.Rewriters.Postwalk</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Postwalk(rw; threaded=false, thread_cutoff=100, maketerm=maketerm)</code></pre><p>Apply a rewriter to a symbolic expression tree in post-order (bottom-up).</p><p>Post-order traversal visits child nodes before their parents, allowing for simplification of subexpressions before the containing expression.</p><p><strong>Arguments</strong></p><ul><li><code>rw</code>: The rewriter to apply at each node</li><li><code>threaded</code>: If true, use multi-threading for large expressions</li><li><code>thread_cutoff</code>: Minimum node count to trigger threading</li><li><code>maketerm</code>: Function to construct terms (defaults to <code>maketerm</code>)</li><li><code>filter</code>: Function which returns whether to search into a subtree</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; r = @rule ~x + ~x =&gt; 2 * ~x
julia&gt; pw = Postwalk(r)
julia&gt; pw((x + x) * (y + y))  # Simplifies both additions
2x * 2y</code></pre><p>See also: <a href="#SymbolicUtils.Rewriters.Prewalk"><code>Prewalk</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/3ff2817fbbc02db556e01d31e647a20c057fd0a3/src/rewriters.jl#L307-L331">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SymbolicUtils.Rewriters.Prewalk"><a class="docstring-binding" href="#SymbolicUtils.Rewriters.Prewalk"><code>SymbolicUtils.Rewriters.Prewalk</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Prewalk(rw; threaded=false, thread_cutoff=100, maketerm=maketerm)</code></pre><p>Apply a rewriter to a symbolic expression tree in pre-order (top-down).</p><p>Pre-order traversal visits parent nodes before their children, allowing for transformation of the overall structure before processing subexpressions.</p><p><strong>Arguments</strong></p><ul><li><code>rw</code>: The rewriter to apply at each node</li><li><code>threaded</code>: If true, use multi-threading for large expressions</li><li><code>thread_cutoff</code>: Minimum node count to trigger threading</li><li><code>maketerm</code>: Function to construct terms (defaults to <code>maketerm</code>)</li><li><code>filter</code>: Function which returns whether to search into a subtree</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; r = @rule sin(~x) =&gt; cos(~x)
julia&gt; pw = Prewalk(r)
julia&gt; pw(sin(sin(x)))  # Transforms outer sin first
cos(cos(x))</code></pre><p>See also: <a href="#SymbolicUtils.Rewriters.Postwalk"><code>Postwalk</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/3ff2817fbbc02db556e01d31e647a20c057fd0a3/src/rewriters.jl#L336-L360">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SymbolicUtils.Rewriters.PassThrough"><a class="docstring-binding" href="#SymbolicUtils.Rewriters.PassThrough"><code>SymbolicUtils.Rewriters.PassThrough</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PassThrough(rw)</code></pre><p>A rewriter that returns the input unchanged if the wrapped rewriter returns <code>nothing</code>.</p><p>This is useful for making rewriters that preserve the input when no rule applies.</p><p><strong>Arguments</strong></p><ul><li><code>rw</code>: The rewriter to wrap</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; r = @rule sin(~x) =&gt; cos(~x)
julia&gt; pt = PassThrough(r)
julia&gt; pt(sin(x))  # Returns cos(x)
julia&gt; pt(tan(x))  # Returns tan(x) unchanged</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/3ff2817fbbc02db556e01d31e647a20c057fd0a3/src/rewriters.jl#L365-L382">source</a></section></details></article><h2 id="Simplification-and-Transformation"><a class="docs-heading-anchor" href="#Simplification-and-Transformation">Simplification and Transformation</a><a id="Simplification-and-Transformation-1"></a><a class="docs-heading-anchor-permalink" href="#Simplification-and-Transformation" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="SymbolicUtils.simplify"><a class="docstring-binding" href="#SymbolicUtils.simplify"><code>SymbolicUtils.simplify</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">simplify(x; expand=false,
            threaded=false,
            thread_subtree_cutoff=100,
            rewriter=nothing)</code></pre><p>Simplify an expression (<code>x</code>) by applying <code>rewriter</code> until there are no changes. <code>expand=true</code> applies <a href="/api/#expand"><code>expand</code></a> in the beginning of each fixpoint iteration.</p><p>By default, simplify will assume denominators are not zero and allow cancellation in fractions. Pass <code>simplify_fractions=false</code> to prevent this.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/3ff2817fbbc02db556e01d31e647a20c057fd0a3/src/simplify.jl#L2-L15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SymbolicUtils.expand"><a class="docstring-binding" href="#SymbolicUtils.expand"><code>SymbolicUtils.expand</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">expand(expr)</code></pre><p>Expand expressions by distributing multiplication over addition, e.g., <code>a*(b+c)</code> becomes <code>ab+ac</code>.</p><p><code>expand</code> uses replace symbols and non-algebraic expressions by variables of type <code>variable_type</code> to compute the distribution using a specialized sparse multivariate polynomials implementation. <code>variable_type</code> can be any subtype of <code>MultivariatePolynomials.AbstractVariable</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/3ff2817fbbc02db556e01d31e647a20c057fd0a3/src/polyform.jl#L173-L183">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SymbolicUtils.substitute"><a class="docstring-binding" href="#SymbolicUtils.substitute"><code>SymbolicUtils.substitute</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">substitute(expr, dict; fold=Val(false))</code></pre><p>substitute any subexpression that matches a key in <code>dict</code> with the corresponding value. If <code>fold=Val(false)</code>, expressions which can be evaluated won&#39;t be evaluated.</p><pre><code class="language-julia-repl hljs">julia&gt; substitute(1+sqrt(y), Dict(y =&gt; 2), fold=Val(true))
2.414213562373095
julia&gt; substitute(1+sqrt(y), Dict(y =&gt; 2), fold=Val(false))
1 + sqrt(2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/3ff2817fbbc02db556e01d31e647a20c057fd0a3/src/substitute.jl#L247-L260">source</a></section></details></article><h2 id="Polynomial-Forms"><a class="docs-heading-anchor" href="#Polynomial-Forms">Polynomial Forms</a><a id="Polynomial-Forms-1"></a><a class="docs-heading-anchor-permalink" href="#Polynomial-Forms" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="SymbolicUtils.simplify_fractions"><a class="docstring-binding" href="#SymbolicUtils.simplify_fractions"><code>SymbolicUtils.simplify_fractions</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">simplify_fractions(x; polyform=false)</code></pre><p>Find <code>Div</code> nodes and simplify them by cancelling a set of factors of numerators and denominators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/3ff2817fbbc02db556e01d31e647a20c057fd0a3/src/polyform.jl#L467-L472">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SymbolicUtils.quick_cancel"><a class="docstring-binding" href="#SymbolicUtils.quick_cancel"><code>SymbolicUtils.quick_cancel</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">quick_cancel(d)</code></pre><p>Cancel out matching factors from numerator and denominator. This is not as effective as <code>simplify_fractions</code>, for example, it wouldn&#39;t simplify <code>(x^2 + 15 -  8x)  / (x - 5)</code> to <code>(x - 3)</code>. But it will simplify <code>(x - 5)^2*(x - 3) / (x - 5)</code> to <code>(x - 5)*(x - 3)</code>. Has optimized processes for <code>Mul</code> and <code>Pow</code> terms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/3ff2817fbbc02db556e01d31e647a20c057fd0a3/src/polyform.jl#L264-L272">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SymbolicUtils.flatten_fractions"><a class="docstring-binding" href="#SymbolicUtils.flatten_fractions"><code>SymbolicUtils.flatten_fractions</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">flatten_fractions(x)</code></pre><p>Flatten nested fractions that are added together.</p><pre><code class="language-julia-repl hljs">julia&gt; flatten_fractions((1+(1+1/a)/a)/a)
(1 + a + a^2) / (a^3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/3ff2817fbbc02db556e01d31e647a20c057fd0a3/src/polyform.jl#L485-L494">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../manual/recursive_utils/">« Recursive utility functions</a><a class="docs-footer-nextpage" href="../upgrade/">Upgrade to SymbolicUtils v1 »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Tuesday 10 February 2026 10:49">Tuesday 10 February 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
