<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Term representation and simplification · SymbolicUtils.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://docs.sciml.ai/SymbolicUtils/stable/manual/representation/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">SymbolicUtils.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">SymbolicUtils.jl — Symbolic programming in Julia</a></li><li><span class="tocitem">Manual</span><ul><li class="is-active"><a class="tocitem" href>Term representation and simplification</a></li><li><a class="tocitem" href="../rewrite/">Term Rewriting</a></li><li><a class="tocitem" href="../interface/">Interfacing with SymbolicUtils.jl</a></li><li><a class="tocitem" href="../codegen/">Code generation</a></li></ul></li><li><a class="tocitem" href="../../api/">API Reference</a></li><li><a class="tocitem" href="../../upgrade/">Upgrade to SymbolicUtils v1</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Term representation and simplification</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Term representation and simplification</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/master/docs/src/manual/representation.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Term-representation-and-simplification"><a class="docs-heading-anchor" href="#Term-representation-and-simplification">Term representation and simplification</a><a id="Term-representation-and-simplification-1"></a><a class="docs-heading-anchor-permalink" href="#Term-representation-and-simplification" title="Permalink"></a></h1><p>Performance of symbolic simplification depends on the datastructures used to represent terms. Efficient datastructures often have the advantage of automatic simplification, and of efficient storage.</p><p>The most basic term representation simply holds a function call and stores the function and the arguments it is called with. This is done by the <code>Term</code> type in SymbolicUtils. Functions that aren&#39;t commutative or associative, such as <code>sin</code> or <code>hypot</code> are stored as <code>Term</code>s. Commutatative and associative operations like <code>+</code>, <code>*</code>, and their supporting operations like <code>-</code>, <code>/</code> and <code>^</code>, when used on terms of type <code>&lt;:Number</code>, stand to gain from the use of more efficient datastrucutres.</p><p>All term representations must support <code>operation</code> and <code>arguments</code> functions. And they must define <code>istree</code> to return <code>true</code> when called with an instance of the type. Generic term-manipulation programs such as the rule-based rewriter make use of this interface to inspect expressions. In this way, the interface wins back the generality lost by having a zoo of term representations instead of one. (see <a href="/interface/">interface</a> section for more on this.)</p><h3 id="Preliminary-representation-of-arithmetic"><a class="docs-heading-anchor" href="#Preliminary-representation-of-arithmetic">Preliminary representation of arithmetic</a><a id="Preliminary-representation-of-arithmetic-1"></a><a class="docs-heading-anchor-permalink" href="#Preliminary-representation-of-arithmetic" title="Permalink"></a></h3><p>Linear combinations such as <span>$\alpha_1  x_1 + \alpha_2 x_2 +...+ \alpha_n x_n$</span> are represented by <code>Add(Dict(x₁ =&gt; α₁, x₂ =&gt; α₂, ..., xₙ =&gt; αₙ))</code>. Here, any <span>$x_i$</span> may itself be other types mentioned here, except for <code>Add</code>. When an <code>Add</code> is added to an <code>Add</code>, we merge their dictionaries and add up matching coefficients to create a single &quot;flattened&quot; Add.</p><p>Similarly, <span>$x_1^{m_1}x_2^{m_2}...x_{m_n}$</span> is represented by <code>Mul(Dict(x₁ =&gt; m₁, x₂ =&gt; m₂, ..., xₙ =&gt; mₙ))</code>. <span>$x_i$</span> may not themselves be <code>Mul</code>, multiplying a Mul with another Mul returns a &quot;flattened&quot; Mul.</p><p>Note that <code>Add</code> and <code>Mul</code> types perform a preliminary simplification which suffices to simplify numeric expressions to a large extent during construction.</p><p class="math-container">\[p / q\]</p><p>is represented by <code>Div(p, q)</code>. The result of <code>*</code> on <code>Div</code> is maintainted as a <code>Div</code>. For example, <code>Div(p_1, q_1) * Div(p_2, q_2)</code> results in <code>Div(p_1 * p_2, q_1 * q_2)</code> and so on. The effect is, in <code>Div(p, q)</code>, <code>p</code> or <code>q</code> or, if they are Mul, any of their multiplicands is not a Div. So <code>Mul</code>s must always be nested inside a <code>Div</code> and can never show up immediately wrapping it. This rule sets up an expression so that it helps the <code>simplify_fractions</code> procedure described two sections below.</p><h3 id="Polynomial-representation"><a class="docs-heading-anchor" href="#Polynomial-representation">Polynomial representation</a><a id="Polynomial-representation-1"></a><a class="docs-heading-anchor-permalink" href="#Polynomial-representation" title="Permalink"></a></h3><p>Packages like DynamicPolynomials.jl provide representations that are even more efficient than the <code>Add</code> and <code>Mul</code> types mentioned above. They are designed specifically for multi-variate polynomials. They provide common algorithms such as multi-variate polynomial GCD. The restrictions that make it fast also mean some things are not possible: Firstly, DynamicPolynomials can only represent flat polynomials. For example, <code>(x-3)*(x+5)</code> can only be represented as <code>(x^2) + 15 - 8x</code>. Secondly, DynamicPolynomials does not have ways to represent generic Terms such as <code>sin(x-y)</code> in the tree.</p><p>To reconcile these differences while being able to use the efficient algorithms of DynamicPolynomials we have the <code>PolyForm</code> type. This type holds a polynomial and the mappings necessary to present the polynomial as a SymbolicUtils expression (i.e. by defining <code>operation</code> and <code>arguments</code>).  The mappings constructed for the conversion are 1) a bijection from DynamicPolynomials Variable type to a Symbolics <code>Sym</code>, and 2) a mapping from <code>Sym</code>s to non-polynomial terms that the <code>Sym</code>s stand-in for. These terms may themselves contain PolyForm if there are polynomials inside them. The mappings are transiently global, that is, when all references to the mappings go out of scope, they are released and re-created.</p><pre><code class="language-julia hljs">julia&gt; @syms x y
(x, y)

julia&gt; PolyForm((x-3)*(y-5))
x*y + 15 - 5x - 3y</code></pre><p>Terms for which the <code>operation</code> is not <code>+</code>, <code>*</code>, or <code>^</code> are replaced with a generated symbol when representing the polynomial, and a mapping from this new symbol to the original expression it stands-in for is maintained as stated above.</p><pre><code class="language-julia hljs">julia&gt; p = PolyForm((sin(x) + cos(x))^2)
(cos(x)^2) + 2cos(x)*sin(x) + (sin(x)^2)

julia&gt; p.p # this is the actual DynamicPolynomial stored
cos_3658410937268741549² + 2cos_3658410937268741549sin_10720964503106793468 + sin_10720964503106793468²</code></pre><p>By default, polynomials inside non-polynomial terms are not also converted to PolyForm. For example,</p><pre><code class="language-julia hljs">julia&gt; PolyForm(sin((x-3)*(y-5)))
sin((x - 3)*(y - 5))</code></pre><p>But you can pass in the <code>recurse=true</code> keyword argument to do this.</p><pre><code class="language-julia hljs">julia&gt; PolyForm(sin((x-3)*(y-5)), recurse=true)
sin(x*y + 15 - 5x - 3y)</code></pre><p>Polynomials are constructed by first turning symbols and non-polynomial terms into DynamicPolynomials-style variables and then applying the <code>+</code>, <code>*</code>, <code>^</code> operations on these variables. You can control the list of the polynomial operations with the <code>Fs</code> keyword argument. It is a <code>Union</code> type of the functions to apply. For example, let&#39;s say you want to turn terms into polynomials by only applying the <code>+</code> and <code>^</code> operations, and want to preserve <code>*</code> operations as-is, you could pass in <code>Fs=Union{typeof(+), typeof(^)}</code></p><pre><code class="language-julia hljs">julia&gt; PolyForm((x+y)^2*(x-y), Fs=Union{typeof(+), typeof(^)}, recurse=true)
((x - (y))*((x^2) + 2x*y + (y^2)))</code></pre><p>Note that in this case <code>recurse=true</code> was necessary as otherwise the polynomialization would not descend into the <code>*</code> operation as it is now considered a generic operation.</p><h3 id="Simplifying-fractions"><a class="docs-heading-anchor" href="#Simplifying-fractions">Simplifying fractions</a><a id="Simplifying-fractions-1"></a><a class="docs-heading-anchor-permalink" href="#Simplifying-fractions" title="Permalink"></a></h3><p><code>simplify_fractions(expr)</code> recurses through <code>expr</code> finding <code>Div</code>s and simplifying them using polynomial divison.</p><p>First the factors of the numerators and the denominators are converted into PolyForm objects, then numerators and denominators are divided by their respective pairwise GCDs. The conversion of the numerator and denominator into PolyForm is set up so that <code>simplify_fractions</code> does not result in increase in the expression size due to polynomial expansion. Specifically, the factors are individually converted into PolyForm objects, and any powers of polynomial is not expanded, but the divison process repeatedly divides them as many times as the power.</p><pre><code class="language-julia hljs">julia&gt; simplify_fractions((x*y+5x+3y+15)/((x+3)*(x-4)))
(5.0 + y) / (x - 4)

julia&gt; simplify_fractions((x*y+5x+3y+15)^2/((x+3)*(x-4)))
((5.0 + y)*(15 + 5x + x*y + 3y)) / (x - 4)

julia&gt; simplify_fractions(3/(x+3) + x/(x+3))
1

julia&gt; simplify_fractions(sin(x)/cos(x) + cos(x)/sin(x))
(cos(x)^2 + sin(x)^2) / (cos(x)*sin(x))

julia&gt; simplify(ans)
1 / (cos(x)*sin(x))</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« SymbolicUtils.jl — Symbolic programming in Julia</a><a class="docs-footer-nextpage" href="../rewrite/">Term Rewriting »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Thursday 27 July 2023 19:44">Thursday 27 July 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
