<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · SymbolicUtils.jl</title><meta name="title" content="API Reference · SymbolicUtils.jl"/><meta property="og:title" content="API Reference · SymbolicUtils.jl"/><meta property="twitter:title" content="API Reference · SymbolicUtils.jl"/><meta name="description" content="Documentation for SymbolicUtils.jl."/><meta property="og:description" content="Documentation for SymbolicUtils.jl."/><meta property="twitter:description" content="Documentation for SymbolicUtils.jl."/><meta property="og:url" content="https://docs.sciml.ai/SymbolicUtils/stable/api/"/><meta property="twitter:url" content="https://docs.sciml.ai/SymbolicUtils/stable/api/"/><link rel="canonical" href="https://docs.sciml.ai/SymbolicUtils/stable/api/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SymbolicUtils.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">SymbolicUtils.jl — Symbolic programming in Julia</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../manual/representation/">Term representation and simplification</a></li><li><a class="tocitem" href="../manual/rewrite/">Term Rewriting</a></li><li><a class="tocitem" href="../manual/interface/">Interfacing with SymbolicUtils.jl</a></li><li><a class="tocitem" href="../manual/codegen/">Code generation</a></li></ul></li><li class="is-active"><a class="tocitem" href>API Reference</a><ul class="internal"><li><a class="tocitem" href="#Symbols-and-Terms"><span>Symbols and Terms</span></a></li><li><a class="tocitem" href="#Rewriting-System"><span>Rewriting System</span></a></li><li><a class="tocitem" href="#Simplification-and-Transformation"><span>Simplification and Transformation</span></a></li><li><a class="tocitem" href="#Polynomial-Forms"><span>Polynomial Forms</span></a></li><li><a class="tocitem" href="#Code-Generation"><span>Code Generation</span></a></li></ul></li><li><a class="tocitem" href="../upgrade/">Upgrade to SymbolicUtils v1</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/master/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><h2 id="Symbols-and-Terms"><a class="docs-heading-anchor" href="#Symbols-and-Terms">Symbols and Terms</a><a id="Symbols-and-Terms-1"></a><a class="docs-heading-anchor-permalink" href="#Symbols-and-Terms" title="Permalink"></a></h2><h3 id="Creating-Symbols-and-Terms"><a class="docs-heading-anchor" href="#Creating-Symbols-and-Terms">Creating Symbols and Terms</a><a id="Creating-Symbols-and-Terms-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-Symbols-and-Terms" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.@syms" href="#SymbolicUtils.@syms"><code>SymbolicUtils.@syms</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@syms &lt;lhs_expr&gt;[::T1] &lt;lhs_expr&gt;[::T2]...</code></pre><p>For instance:</p><pre><code class="nohighlight hljs">@syms foo::Real bar baz(x, y::Real)::Complex</code></pre><p>Create one or more variables. <code>&lt;lhs_expr&gt;</code> can be just a symbol in which case it will be the name of the variable, or a function call in which case a function-like variable which has the same name as the function being called. The Sym type, or in the case of a function-like Sym, the output type of calling the function can be set using the <code>::T</code> syntax.</p><p><strong>Examples:</strong></p><ul><li><code>@syms foo bar::Real baz::Int</code> will create</li></ul><p>variable <code>foo</code> of symtype <code>Number</code> (the default), <code>bar</code> of symtype <code>Real</code> and <code>baz</code> of symtype <code>Int</code></p><ul><li><code>@syms f(x) g(y::Real, x)::Int h(a::Int, f(b))</code> creates 1-arg <code>f</code> 2-arg <code>g</code></li></ul><p>and 2 arg <code>h</code>. The second argument to <code>h</code> must be a one argument function-like variable. So, <code>h(1, g)</code> will fail and <code>h(1, f)</code> will work.</p><p><strong>Formal syntax</strong></p><p>Following is a semi-formal CFG of the syntax accepted by this macro:</p><pre><code class="language-python hljs"># any variable accepted by this macro must be a `var`.
# `var` can represent a quantity (`value`) or a function `(fn)`.
var = value | fn
# A `value` is represented as a name followed by a suffix
value = name suffix
# A `name` can be a valid Julia identifier
name = ident |
# Or it can be an interpolated variable, in which case `ident` is assumed to refer to
# a variable in the current scope of type `Symbol` containing the name of this variable.
# Note that in this case the created symbolic variable will be bound to a randomized
# Julia identifier.
       &quot;$&quot; ident
# The `suffix` can be empty (no suffix) which defaults the type to `Number`
suffix = &quot;&quot; |
# or it can be a type annotation (setting the type of the prefix). The shape of the result
# is inferred from the type as best it can be. In particular, `Array{T, N}` is inferred
# to have shape `Unknown(N)` and `Array{T}` is inferred to have shape `Unknown(-1)`.
         &quot;::&quot; type |
# or it can be a shape annotation, which sets the shape to the one specified by `ranges`.
# The type defaults to `Array{Number, length(ranges)}`
         &quot;[&quot; ranges &quot;]&quot; |
# lastly, it can be a combined shape and type annotation. Here, the type annotation
# sets the `eltype` of the symbolic array.
         &quot;[&quot; ranges &quot;]::&quot; type
# `ranges` is either a single `range` or a single range followed by one or more `ranges`.
ranges = range | range &quot;,&quot; ranges
# A `range` is simply two bounds separated by a colon, as standard Julia ranges work.
# The range must be non-empty. Each bound can be a literal integer or an identifier
# representing an integer in the current scope.
range = (int | ident) &quot;:&quot; (int | ident) |
# Alternatively, a range can be a Julia expression that evaluates to a range. All identifiers
# used in `expr` are assumed to exist in the current scope.
        expr |
# Alternatively, a range can be a Julia expression evaluating to an iterable of ranges,
# followed by the splat operator.
        expr &quot;...&quot;
# A function is represented by a function-call syntax `fncall` followed by the `suffix`
# above. The type and shape from `suffix` represent the type and shape of the value
# returned by the symbolic function.
fn = fncall suffix
# a function call is a call `head` followed by a parenthesized list of arguments.
fncall = head &quot;(&quot; args &quot;)&quot;
# A function call head can be a name, representing the name of the symbolic function.
head = ident |
# Alternatively, it can be a parenthesized type-annotated name, where the type annotation
# represents the intended supertype of the function. In other words, if this symbolic
# function were to be replaced by an &quot;actual&quot; function, the type-annotation constrains the
# type of the &quot;actual&quot; function.
       &quot;(&quot; ident &quot;::&quot; type &quot;)&quot;
# Arguments to a function is a list of one or more arguments
args = arg | arg &quot;,&quot; args
# An argument can take the syntax of a variable (which means we can represent functions of
# functions of functions of...). The type of the variable constrains the type of the
# corresponding argument of the function. The name and shape information is discarded.
arg = var |
# Or an argument can be an unnamed type-annotation, which constrains the type without
# requiring a name.
      &quot;::&quot; type |
# Or an argument can be the identifier `..`, which is used as a stand-in for `Vararg{Any}`
      &quot;..&quot; |
# Or an argument can be a type-annotated `..`, representing `Vararg{type}`. Note that this
# and the previous version of `arg` can only be the last element in `args` due to Julia&#39;s
# `Tuple` semantics.
      &quot;(..)::&quot; type |
# Or an argument can be a Julia expression followed by a splat operator. This assumes the
# expression evaluates to an iterable of symbolic variables whose `symtype` should be used
# as the argument types. Note that `expr` may be evaluated multiple times in the macro
# expansion.
      expr &quot;...&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/7fa3f76d1ada08c23a7953d5a52acf935435eae4/src/syms.jl#L1-L98">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.term" href="#SymbolicUtils.term"><code>SymbolicUtils.term</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">term(f, args...; type = nothing)</code></pre><p>Create a symbolic term with operation <code>f</code> and arguments <code>args</code>.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: The operation or function head of the term</li><li><code>args...</code>: The arguments to the operation</li><li><code>type</code>: Optional type specification for the term. If not provided, the type is inferred using <code>promote_symtype</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; @syms x y
(x, y)

julia&gt; term(+, x, y)
x + y

julia&gt; term(sin, x)
sin(x)

julia&gt; term(^, x, 2)
x^2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/7fa3f76d1ada08c23a7953d5a52acf935435eae4/src/types.jl#L1572-L1596">source</a></section></article><h3 id="Inspecting-Terms"><a class="docs-heading-anchor" href="#Inspecting-Terms">Inspecting Terms</a><a id="Inspecting-Terms-1"></a><a class="docs-heading-anchor-permalink" href="#Inspecting-Terms" title="Permalink"></a></h3><div class="admonition is-warning" id="Missing-docstring.-f87f987293dca905"><header class="admonition-header">Missing docstring.<a class="admonition-anchor" href="#Missing-docstring.-f87f987293dca905" title="Permalink"></a></header><div class="admonition-body"><p>Missing docstring for <code>SymbolicUtils.issym</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning" id="Missing-docstring.-9e69035d674d20d1"><header class="admonition-header">Missing docstring.<a class="admonition-anchor" href="#Missing-docstring.-9e69035d674d20d1" title="Permalink"></a></header><div class="admonition-body"><p>Missing docstring for <code>SymbolicUtils.symtype</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermInterface.iscall" href="#TermInterface.iscall"><code>TermInterface.iscall</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">iscall(expr)</code></pre><p>Check if a symbolic expression <code>expr</code> represents a function call. Returns <code>true</code> if the  expression is a composite expression with an operation and arguments, <code>false</code> otherwise.</p><p>This function is fundamental for traversing and analyzing symbolic expressions. In  SymbolicUtils.jl, an expression is considered a &quot;call&quot; if it represents a function  application (including operators like +, -, *, etc.).</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymbolicUtils
@variables x y

# Basic variables are not calls
iscall(x)           # false

# Function calls are calls  
expr = sin(x + y)
iscall(expr)        # true

# Arithmetic expressions are calls
iscall(x + y)       # true
iscall(x * y)       # true</code></pre><p>See also: <a href="#TermInterface.operation"><code>operation</code></a>, <a href="#TermInterface.arguments"><code>arguments</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/7fa3f76d1ada08c23a7953d5a52acf935435eae4/src/types.jl#L544-L572">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermInterface.operation" href="#TermInterface.operation"><code>TermInterface.operation</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">operation(expr)</code></pre><p>Extract the operation (function) from a symbolic function call expression. Only valid for expressions where <code>iscall(expr)</code> returns <code>true</code>.</p><p>Returns the function/operator that is being applied in the expression. For basic arithmetic, this returns the operator function (+, -, *, /, ^). For function calls like <code>sin(x)</code>, this returns the function <code>sin</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymbolicUtils
@variables x y

# Arithmetic operations
expr1 = x + y
operation(expr1)    # returns +

expr2 = x * y  
operation(expr2)    # returns *

# Function calls
expr3 = sin(x)
operation(expr3)    # returns sin

# Nested expressions
expr4 = sin(x + y)
operation(expr4)    # returns sin
operation(arguments(expr4)[1])  # returns +</code></pre><p>See also: <a href="#TermInterface.iscall"><code>iscall</code></a>, <a href="#TermInterface.arguments"><code>arguments</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/7fa3f76d1ada08c23a7953d5a52acf935435eae4/src/types.jl#L347-L380">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermInterface.arguments" href="#TermInterface.arguments"><code>TermInterface.arguments</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">arguments(expr)</code></pre><p>Extract the arguments from a symbolic function call expression. Only valid for expressions where <code>iscall(expr)</code> returns <code>true</code>.</p><p>Returns a collection (typically a vector) containing the arguments passed to the operation. For binary operations like <code>+</code> or <code>*</code>, this returns a collection of all operands. For function calls, this returns the function arguments.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymbolicUtils
@variables x y z

# Binary arithmetic operations
expr1 = x + y
arguments(expr1)    # returns collection containing x and y

expr2 = x * y * z  
arguments(expr2)    # returns collection containing x, y, and z

# Function calls
expr3 = sin(x)
arguments(expr3)    # returns collection containing x

# Nested expressions
expr4 = sin(x + y)
arguments(expr4)             # returns collection containing (x + y)
arguments(arguments(expr4)[1])  # returns collection containing x and y</code></pre><p>See also: <a href="#TermInterface.iscall"><code>iscall</code></a>, <a href="#TermInterface.operation"><code>operation</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/7fa3f76d1ada08c23a7953d5a52acf935435eae4/src/types.jl#L449-L482">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermInterface.sorted_arguments" href="#TermInterface.sorted_arguments"><code>TermInterface.sorted_arguments</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sorted_arguments(x::BasicSymbolic)</code></pre><p>Get the arguments of a symbolic expression in canonical sorted order.</p><p>For commutative operations like addition and multiplication, the arguments are sorted according to a canonical ordering. This ensures that equivalent expressions have the same representation.</p><p><strong>Arguments</strong></p><ul><li><code>x::BasicSymbolic</code>: The symbolic expression</li></ul><p><strong>Returns</strong></p><p>A vector of the arguments in sorted order. For non-commutative operations, returns the arguments in their original order.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; @syms x y z
(x, y, z)

julia&gt; expr = x + z + y
x + y + z

julia&gt; sorted_arguments(expr)
3-element Vector{Any}:
 x
 y
 z</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/7fa3f76d1ada08c23a7953d5a52acf935435eae4/src/types.jl#L403-L433">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.showraw" href="#SymbolicUtils.showraw"><code>SymbolicUtils.showraw</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">showraw([io::IO], t)</code></pre><p>Display the raw structure of a symbolic expression without simplification.</p><p>This function shows the internal structure of symbolic expressions without applying any simplification rules, which is useful for debugging and understanding the exact form of an expression.</p><p><strong>Arguments</strong></p><ul><li><code>io::IO</code>: Optional IO stream to write to (defaults to stdout)</li><li><code>t</code>: The symbolic expression to display</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; @syms x
x

julia&gt; expr = x + x + x
3x

julia&gt; showraw(expr)  # Shows the unsimplified structure
x + x + x</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/7fa3f76d1ada08c23a7953d5a52acf935435eae4/src/printing.jl#L197-L221">source</a></section></article><h3 id="Metadata"><a class="docs-heading-anchor" href="#Metadata">Metadata</a><a id="Metadata-1"></a><a class="docs-heading-anchor-permalink" href="#Metadata" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.hasmetadata" href="#SymbolicUtils.hasmetadata"><code>SymbolicUtils.hasmetadata</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hasmetadata(s::Symbolic, ctx)</code></pre><p>Check if a symbolic expression has metadata for a given context.</p><p><strong>Arguments</strong></p><ul><li><code>s::Symbolic</code>: The symbolic expression to check</li><li><code>ctx</code>: The metadata context key (typically a DataType)</li></ul><p><strong>Returns</strong></p><ul><li><code>true</code> if the expression has metadata for the given context, <code>false</code> otherwise</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; @syms x
x

julia&gt; hasmetadata(x, Float64)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/7fa3f76d1ada08c23a7953d5a52acf935435eae4/src/types.jl#L1689-L1709">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.getmetadata" href="#SymbolicUtils.getmetadata"><code>SymbolicUtils.getmetadata</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getmetadata(s::Symbolic, ctx)</code></pre><p>Retrieve metadata associated with a symbolic expression for a given context.</p><p><strong>Arguments</strong></p><ul><li><code>s::Symbolic</code>: The symbolic expression</li><li><code>ctx</code>: The metadata context key (typically a DataType)</li></ul><p><strong>Returns</strong></p><p>The metadata value associated with the given context</p><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code> if the expression does not have metadata for the given context</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; @syms x::Float64
x

julia&gt; getmetadata(x, symtype)  # Get the type metadata
Float64</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/7fa3f76d1ada08c23a7953d5a52acf935435eae4/src/types.jl#L1714-L1737">source</a></section><section><div><pre><code class="language-julia hljs">getmetadata(s::Symbolic, ctx, default)</code></pre><p>Retrieve metadata associated with a symbolic expression for a given context, returning a default value if not found.</p><p><strong>Arguments</strong></p><ul><li><code>s::Symbolic</code>: The symbolic expression</li><li><code>ctx</code>: The metadata context key (typically a DataType)</li><li><code>default</code>: The default value to return if metadata is not found</li></ul><p><strong>Returns</strong></p><p>The metadata value associated with the given context, or <code>default</code> if not found</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; @syms x
x

julia&gt; getmetadata(x, Float64, &quot;no type&quot;)
&quot;no type&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/7fa3f76d1ada08c23a7953d5a52acf935435eae4/src/types.jl#L1747-L1769">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.setmetadata" href="#SymbolicUtils.setmetadata"><code>SymbolicUtils.setmetadata</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">setmetadata(s::Symbolic, ctx::DataType, val)</code></pre><p>Set metadata for a symbolic expression in a given context.</p><p><strong>Arguments</strong></p><ul><li><code>s::Symbolic</code>: The symbolic expression</li><li><code>ctx::DataType</code>: The metadata context key</li><li><code>val</code>: The metadata value to set</li></ul><p><strong>Returns</strong></p><p>A new symbolic expression with the updated metadata</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; @syms x
x

julia&gt; x_with_meta = setmetadata(x, Float64, &quot;custom value&quot;)
x

julia&gt; getmetadata(x_with_meta, Float64)
&quot;custom value&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/7fa3f76d1ada08c23a7953d5a52acf935435eae4/src/types.jl#L1798-L1822">source</a></section></article><h3 id="Type-Promotion"><a class="docs-heading-anchor" href="#Type-Promotion">Type Promotion</a><a id="Type-Promotion-1"></a><a class="docs-heading-anchor-permalink" href="#Type-Promotion" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.promote_symtype" href="#SymbolicUtils.promote_symtype"><code>SymbolicUtils.promote_symtype</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">promote_symtype(f, Ts...)</code></pre><p>The result of applying <code>f</code> to arguments of <a href="#symtype"><code>symtype</code></a> <code>Ts...</code></p><pre><code class="language-julia hljs">julia&gt; promote_symtype(+, Real, Real)
Real

julia&gt; promote_symtype(+, Complex, Real)
Number

julia&gt; @syms f(x)::Complex
(f(::Number)::Complex,)

julia&gt; promote_symtype(f, Number)
Complex</code></pre><p>When constructing <a href="#Term"><code>Term</code></a>s without an explicit symtype, <code>promote_symtype</code> is used to figure out the symtype of the Term.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/7fa3f76d1ada08c23a7953d5a52acf935435eae4/src/types.jl#L1836-L1857">source</a></section><section><div><pre><code class="language-julia hljs">promote_symtype(f::FnType{X,Y}, arg_symtypes...)</code></pre><p>The output symtype of applying variable <code>f</code> to arguments of symtype <code>arg_symtypes...</code>. if the arguments are of the wrong type then this function will error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/7fa3f76d1ada08c23a7953d5a52acf935435eae4/src/types.jl#L1933-L1938">source</a></section></article><h2 id="Rewriting-System"><a class="docs-heading-anchor" href="#Rewriting-System">Rewriting System</a><a id="Rewriting-System-1"></a><a class="docs-heading-anchor-permalink" href="#Rewriting-System" title="Permalink"></a></h2><h3 id="Rule-Creation"><a class="docs-heading-anchor" href="#Rule-Creation">Rule Creation</a><a id="Rule-Creation-1"></a><a class="docs-heading-anchor-permalink" href="#Rule-Creation" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.@rule" href="#SymbolicUtils.@rule"><code>SymbolicUtils.@rule</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@rule LHS =&gt; RHS</code></pre><p>Creates a <code>Rule</code> object. A rule object is callable, and  takes an expression and rewrites it if it matches the LHS pattern to the RHS pattern, returns <code>nothing</code> otherwise. The rule language is described below.</p><p>LHS can be any possibly nested function call expression where any of the arguments can optionally be a Slot (<code>~x</code>), Default Value Slot (<code>~!x</code> also called DefSlot) or a Segment  (<code>~~x</code>) (described below).</p><p>If an expression matches LHS entirely, then it is rewritten to the pattern in the RHS. Slot, DefSlot and Segment variables on the RHS will substitute the result of the matches found for these variables in the LHS.</p><p><strong>Slot</strong>:</p><p>A Slot variable is written as <code>~x</code> and matches a single expression. <code>x</code> is the name of the variable. If a slot appears more than once in an LHS expression then expression matched at every such location must be equal (as shown by <code>isequal</code>).</p><p><em>Example:</em></p><p>Simple rule to turn any <code>sin</code> into <code>cos</code>:</p><pre><code class="language-julia hljs">julia&gt; @syms a b c
(a, b, c)

julia&gt; r = @rule sin(~x) =&gt; cos(~x)
sin(~x) =&gt; cos(~x)

julia&gt; r(sin(1+a))
cos((1 + a))</code></pre><p>A rule with 2 segment variables</p><pre><code class="language-julia hljs">julia&gt; r = @rule sin(~x + ~y) =&gt; sin(~x)*cos(~y) + cos(~x)*sin(~y)
sin(~x + ~y) =&gt; sin(~x) * cos(~y) + cos(~x) * sin(~y)

julia&gt; r(sin(a + b))
cos(a)*sin(b) + sin(a)*cos(b)</code></pre><p>A rule that matches two of the same expressions:</p><pre><code class="language-julia hljs">julia&gt; r = @rule sin(~x)^2 + cos(~x)^2 =&gt; 1
sin(~x) ^ 2 + cos(~x) ^ 2 =&gt; 1

julia&gt; r(sin(2a)^2 + cos(2a)^2)
1

julia&gt; r(sin(2a)^2 + cos(a)^2)
# nothing</code></pre><p><strong>DefSlot</strong>:</p><p>A DefSlot variable is written as <code>~!x</code>. Works like a normal slot, but can also take default values if not present in the expression.</p><p><em>Example in power:</em></p><pre><code class="language-julia hljs">julia&gt; r_pow = @rule (~x)^(~!m) =&gt; ~m
(~x) ^ ~(!m) =&gt; ~m

julia&gt; r_pow(x^2)
2

julia&gt; r_pow(x)
1</code></pre><p><em>Example in sum:</em></p><pre><code class="language-julia hljs">julia&gt; r_sum = @rule ~x + ~!y =&gt; ~y
~x + ~(!y) =&gt; ~y

julia&gt; r_sum(x+2)
x

julia&gt; r_sum(x)
0</code></pre><p>Currently DefSlot is implemented in:</p><table><tr><th style="text-align: right">Operation</th><th style="text-align: right">Default value&lt;br&gt;</th></tr><tr><td style="text-align: right">*</td><td style="text-align: right">1</td></tr><tr><td style="text-align: right">+</td><td style="text-align: right">0</td></tr><tr><td style="text-align: right">2nd argument of ^</td><td style="text-align: right">1</td></tr></table><p><strong>Segment</strong>:</p><p>A Segment variable is written as <code>~~x</code> and matches zero or more expressions in the function call.</p><p><em>Example:</em></p><p>This implements the distributive property of multiplication: <code>+(~~ys)</code> matches expressions like <code>a + b</code>, <code>a+b+c</code> and so on. On the RHS <code>~~ys</code> presents as any old julia array.</p><pre><code class="language-julia hljs">julia&gt; r = @rule ~x * +((~~ys)) =&gt; sum(map(y-&gt; ~x * y, ~~ys));

julia&gt; r(2 * (a+b+c))
((2 * a) + (2 * b) + (2 * c))</code></pre><p><strong>Predicates</strong>:</p><p>There are two kinds of predicates, namely over slot variables and over the whole rule. For the former, predicates can be used on both <code>~x</code> and <code>~~x</code> by using the <code>~x::f</code> or <code>~~x::f</code>. Here <code>f</code> can be any julia function. In the case of a slot the function gets a single matched subexpression, in the case of segment, it gets an array of matched expressions.</p><p>The predicate should return <code>true</code> if the current match is acceptable, and <code>false</code> otherwise.</p><pre><code class="language-julia hljs">julia&gt; two_πs(x::Number) = abs(round(x/(2π)) - x/(2π)) &lt; 10^-9
two_πs (generic function with 1 method)

julia&gt; two_πs(x) = false
two_πs (generic function with 2 methods)

julia&gt; r = @rule sin(~~x + ~y::two_πs + ~~z) =&gt; sin(+(~~x..., ~~z...))
sin(~(~x) + ~(y::two_πs) + ~(~z)) =&gt; sin(+(~(~x)..., ~(~z)...))

julia&gt; r(sin(a+3π))

julia&gt; r(sin(a+6π))
sin(a)

julia&gt; r(sin(a+6π+c))
sin((a + c))</code></pre><p>Predicate function gets an array of values if attached to a segment variable (<code>~~x</code>).</p><p>For the predicate over the whole rule, use <code>@rule &lt;LHS&gt; =&gt; &lt;RHS&gt; where &lt;predicate&gt;</code>:</p><pre><code class="nohighlight hljs">julia&gt; @syms a b;

julia&gt; predicate(x) = x === a;

julia&gt; r = @rule ~x =&gt; ~x where predicate(~x);

julia&gt; r(a)
a

julia&gt; r(b) === nothing
true</code></pre><p>Note that this is syntactic sugar and that it is the same as something like <code>@rule ~x =&gt; f(~x) ? ~x : nothing</code>.</p><p><strong>Debugging Rules</strong>: Note that if the RHS is a single tilde <code>~</code>, then the rule returns a a dictionary of all [slot variable, expression matched], this is useful for debugging.</p><p><em>Example:</em></p><pre><code class="language-julia hljs">julia&gt; r = @rule (~x + (~y)^(~m)) =&gt; ~
~x + (~y) ^ ~m =&gt; (~)

julia&gt; r(a + b^2)
Base.ImmutableDict{Symbol, Any} with 5 entries:
  :MATCH =&gt; a + b^2
  :m     =&gt; 2
  :y     =&gt; b
  :x     =&gt; a
  :____  =&gt; nothing</code></pre><p><strong>Context</strong>:</p><p><em>In predicates</em>: Contextual predicates are functions wrapped in the <code>Contextual</code> type. The function is called with 2 arguments: the expression and a context object passed during a call to the Rule object (maybe done by passing a context to <code>simplify</code> or a <code>RuleSet</code> object).</p><p>The function can use the inputs however it wants, and must return a boolean indicating whether the predicate holds or not.</p><p><em>In the consequent pattern</em>: Use <code>(@ctx)</code> to access the context object on the right hand side of an expression.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/7fa3f76d1ada08c23a7953d5a52acf935435eae4/src/rule.jl#L239-L429">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.@acrule" href="#SymbolicUtils.@acrule"><code>SymbolicUtils.@acrule</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@acrule(lhs =&gt; rhs)</code></pre><p>Create an associative-commutative rule that matches all permutations of the arguments.</p><p>This macro creates a rule that can match patterns regardless of the order of arguments in associative and commutative operations like addition and multiplication.</p><p><strong>Arguments</strong></p><ul><li><code>lhs</code>: The pattern to match (left-hand side)</li><li><code>rhs</code>: The replacement expression (right-hand side)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; @syms x y z
(x, y, z)

julia&gt; r = @acrule x + y =&gt; 2x  # Matches both x + y and y + x
ACRule(x + y =&gt; 2x)

julia&gt; r(x + y)
2x

julia&gt; r(y + x)
2x</code></pre><p>See also: <a href="#SymbolicUtils.@rule"><code>@rule</code></a>, <a href="@ref"><code>@ordered_acrule</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/7fa3f76d1ada08c23a7953d5a52acf935435eae4/src/rule.jl#L505-L533">source</a></section></article><h3 id="Rewriters"><a class="docs-heading-anchor" href="#Rewriters">Rewriters</a><a id="Rewriters-1"></a><a class="docs-heading-anchor-permalink" href="#Rewriters" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.Rewriters" href="#SymbolicUtils.Rewriters"><code>SymbolicUtils.Rewriters</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A rewriter is any function which takes an expression and returns an expression or <code>nothing</code>. If <code>nothing</code> is returned that means there was no changes applicable to the input expression.</p><p>The <code>Rewriters</code> module contains some types which create and transform rewriters.</p><ul><li><code>Empty()</code> is a rewriter which always returns <code>nothing</code></li><li><code>Chain(itr)</code> chain an iterator of rewriters into a single rewriter which applies  each chained rewriter in the given order.  If a rewriter returns <code>nothing</code> this is treated as a no-change.</li><li><code>RestartedChain(itr)</code> like <code>Chain(itr)</code> but restarts from the first rewriter once on the  first successful application of one of the chained rewriters.</li><li><code>IfElse(cond, rw1, rw2)</code> runs the <code>cond</code> function on the input, applies <code>rw1</code> if cond  returns true, <code>rw2</code> if it returns false</li><li><code>If(cond, rw)</code> is the same as <code>IfElse(cond, rw, Empty())</code></li><li><code>Prewalk(rw; threaded=false, thread_cutoff=100)</code> returns a rewriter which does a pre-order  traversal of a given expression and applies the rewriter <code>rw</code>. Note that if  <code>rw</code> returns <code>nothing</code> when a match is not found, then <code>Prewalk(rw)</code> will  also return nothing unless a match is found at every level of the walk.  <code>threaded=true</code> will use multi threading for traversal. <code>thread_cutoff</code> is  the minimum number of nodes in a subtree which should be walked in a  threaded spawn.</li><li><code>Postwalk(rw; threaded=false, thread_cutoff=100)</code> similarly does post-order traversal.</li><li><code>Fixpoint(rw)</code> returns a rewriter which applies <code>rw</code> repeatedly until there are no changes to be made.</li><li><code>FixpointNoCycle</code> behaves like <a href="#SymbolicUtils.Rewriters.Fixpoint"><code>Fixpoint</code></a> but instead it applies <code>rw</code> repeatedly only while it is returning new results.</li><li><code>PassThrough(rw)</code> returns a rewriter which if <code>rw(x)</code> returns <code>nothing</code> will instead  return <code>x</code> otherwise will return <code>rw(x)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/7fa3f76d1ada08c23a7953d5a52acf935435eae4/src/rewriters.jl#L1-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.Rewriters.Empty" href="#SymbolicUtils.Rewriters.Empty"><code>SymbolicUtils.Rewriters.Empty</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Empty()</code></pre><p>A rewriter that always returns <code>nothing</code>, indicating no rewrite occurred.</p><p>This is useful as a placeholder or for conditional rewriting patterns.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; Empty()(x)
nothing</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/7fa3f76d1ada08c23a7953d5a52acf935435eae4/src/rewriters.jl#L40-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.Rewriters.IfElse" href="#SymbolicUtils.Rewriters.IfElse"><code>SymbolicUtils.Rewriters.IfElse</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IfElse(cond, yes, no)</code></pre><p>A conditional rewriter that applies <code>yes</code> if <code>cond(x)</code> is true, otherwise applies <code>no</code>.</p><p><strong>Arguments</strong></p><ul><li><code>cond</code>: A function that returns true or false for the input</li><li><code>yes</code>: The rewriter to apply if the condition is true</li><li><code>no</code>: The rewriter to apply if the condition is false</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; r = IfElse(x -&gt; x &gt; 0, x -&gt; -x, x -&gt; x)
julia&gt; r(5)  # Returns -5
julia&gt; r(-3) # Returns -3</code></pre><p>See also: <a href="#SymbolicUtils.Rewriters.If"><code>If</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/7fa3f76d1ada08c23a7953d5a52acf935435eae4/src/rewriters.jl#L60-L78">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.Rewriters.If" href="#SymbolicUtils.Rewriters.If"><code>SymbolicUtils.Rewriters.If</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">If(cond, yes)</code></pre><p>A conditional rewriter that applies <code>yes</code> if <code>cond(x)</code> is true, otherwise returns the input unchanged.</p><p>This is equivalent to <code>IfElse(cond, yes, Empty())</code>.</p><p><strong>Arguments</strong></p><ul><li><code>cond</code>: A function that returns true or false for the input</li><li><code>yes</code>: The rewriter to apply if the condition is true</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; r = If(x -&gt; x &gt; 0, x -&gt; -x)
julia&gt; r(5)  # Returns -5
julia&gt; r(-3) # Returns -3 (unchanged)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/7fa3f76d1ada08c23a7953d5a52acf935435eae4/src/rewriters.jl#L91-L108">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.Rewriters.Chain" href="#SymbolicUtils.Rewriters.Chain"><code>SymbolicUtils.Rewriters.Chain</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Chain(rws; stop_on_match=false)</code></pre><p>Apply a sequence of rewriters to an expression, chaining the results.</p><p>Each rewriter in the chain receives the result of the previous rewriter. If a rewriter returns <code>nothing</code>, the input is passed unchanged to the next rewriter.</p><p><strong>Arguments</strong></p><ul><li><code>rws</code>: A collection of rewriters to apply in sequence</li><li><code>stop_on_match</code>: If true, stop at the first rewriter that produces a change</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; r1 = @rule sin(~x)^2 + cos(~x)^2 =&gt; 1
julia&gt; r2 = @rule sin(2*(~x)) =&gt; 2*sin(~x)*cos(~x)
julia&gt; chain = Chain([r1, r2])
julia&gt; chain(sin(x)^2 + cos(x)^2)  # Returns 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/7fa3f76d1ada08c23a7953d5a52acf935435eae4/src/rewriters.jl#L111-L130">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.Rewriters.RestartedChain" href="#SymbolicUtils.Rewriters.RestartedChain"><code>SymbolicUtils.Rewriters.RestartedChain</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RestartedChain(rws)</code></pre><p>Apply rewriters in sequence, restarting the chain when any rewriter produces a change.</p><p>When any rewriter in the chain produces a non-nothing result, the entire chain is restarted with that result as the new input.</p><p><strong>Arguments</strong></p><ul><li><code>rws</code>: A collection of rewriters to apply</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; r1 = @rule ~x + ~x =&gt; 2 * ~x
julia&gt; r2 = @rule 2 * ~x =&gt; ~x * 2
julia&gt; chain = RestartedChain([r1, r2])
julia&gt; chain(x + x)  # Applies r1, then restarts and applies r2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/7fa3f76d1ada08c23a7953d5a52acf935435eae4/src/rewriters.jl#L169-L187">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.Rewriters.Fixpoint" href="#SymbolicUtils.Rewriters.Fixpoint"><code>SymbolicUtils.Rewriters.Fixpoint</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Fixpoint(rw)</code></pre><p>Apply a rewriter repeatedly until a fixed point is reached.</p><p>The rewriter is applied repeatedly until the output equals the input (either by identity or by <code>isequal</code>), indicating a fixed point has been reached.</p><p><strong>Arguments</strong></p><ul><li><code>rw</code>: The rewriter to apply repeatedly</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; r = @rule ~x + ~x =&gt; 2 * ~x
julia&gt; fp = Fixpoint(r)
julia&gt; fp(x + x + x + x)  # Keeps applying until no more changes</code></pre><p>See also: <a href="#SymbolicUtils.Rewriters.FixpointNoCycle"><code>FixpointNoCycle</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/7fa3f76d1ada08c23a7953d5a52acf935435eae4/src/rewriters.jl#L219-L238">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.Rewriters.FixpointNoCycle" href="#SymbolicUtils.Rewriters.FixpointNoCycle"><code>SymbolicUtils.Rewriters.FixpointNoCycle</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FixpointNoCycle(rw)</code></pre><p><code>FixpointNoCycle</code> behaves like <a href="#SymbolicUtils.Rewriters.Fixpoint"><code>Fixpoint</code></a>, but returns a rewriter which applies <code>rw</code> repeatedly until  it produces a result that was already produced before, for example,  if the repeated application of <code>rw</code> produces results <code>a, b, c, d, b</code> in order,  <code>FixpointNoCycle</code> stops because <code>b</code> has been already produced. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/7fa3f76d1ada08c23a7953d5a52acf935435eae4/src/rewriters.jl#L256-L264">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.Rewriters.Postwalk" href="#SymbolicUtils.Rewriters.Postwalk"><code>SymbolicUtils.Rewriters.Postwalk</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Postwalk(rw; threaded=false, thread_cutoff=100, maketerm=maketerm)</code></pre><p>Apply a rewriter to a symbolic expression tree in post-order (bottom-up).</p><p>Post-order traversal visits child nodes before their parents, allowing for simplification of subexpressions before the containing expression.</p><p><strong>Arguments</strong></p><ul><li><code>rw</code>: The rewriter to apply at each node</li><li><code>threaded</code>: If true, use multi-threading for large expressions</li><li><code>thread_cutoff</code>: Minimum node count to trigger threading</li><li><code>maketerm</code>: Function to construct terms (defaults to <code>maketerm</code>)</li><li><code>filter</code>: Function which returns whether to search into a subtree</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; r = @rule ~x + ~x =&gt; 2 * ~x
julia&gt; pw = Postwalk(r)
julia&gt; pw((x + x) * (y + y))  # Simplifies both additions
2x * 2y</code></pre><p>See also: <a href="#SymbolicUtils.Rewriters.Prewalk"><code>Prewalk</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/7fa3f76d1ada08c23a7953d5a52acf935435eae4/src/rewriters.jl#L307-L331">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.Rewriters.Prewalk" href="#SymbolicUtils.Rewriters.Prewalk"><code>SymbolicUtils.Rewriters.Prewalk</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Prewalk(rw; threaded=false, thread_cutoff=100, maketerm=maketerm)</code></pre><p>Apply a rewriter to a symbolic expression tree in pre-order (top-down).</p><p>Pre-order traversal visits parent nodes before their children, allowing for transformation of the overall structure before processing subexpressions.</p><p><strong>Arguments</strong></p><ul><li><code>rw</code>: The rewriter to apply at each node</li><li><code>threaded</code>: If true, use multi-threading for large expressions</li><li><code>thread_cutoff</code>: Minimum node count to trigger threading</li><li><code>maketerm</code>: Function to construct terms (defaults to <code>maketerm</code>)</li><li><code>filter</code>: Function which returns whether to search into a subtree</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; r = @rule sin(~x) =&gt; cos(~x)
julia&gt; pw = Prewalk(r)
julia&gt; pw(sin(sin(x)))  # Transforms outer sin first
cos(cos(x))</code></pre><p>See also: <a href="#SymbolicUtils.Rewriters.Postwalk"><code>Postwalk</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/7fa3f76d1ada08c23a7953d5a52acf935435eae4/src/rewriters.jl#L336-L360">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.Rewriters.PassThrough" href="#SymbolicUtils.Rewriters.PassThrough"><code>SymbolicUtils.Rewriters.PassThrough</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PassThrough(rw)</code></pre><p>A rewriter that returns the input unchanged if the wrapped rewriter returns <code>nothing</code>.</p><p>This is useful for making rewriters that preserve the input when no rule applies.</p><p><strong>Arguments</strong></p><ul><li><code>rw</code>: The rewriter to wrap</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; r = @rule sin(~x) =&gt; cos(~x)
julia&gt; pt = PassThrough(r)
julia&gt; pt(sin(x))  # Returns cos(x)
julia&gt; pt(tan(x))  # Returns tan(x) unchanged</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/7fa3f76d1ada08c23a7953d5a52acf935435eae4/src/rewriters.jl#L365-L382">source</a></section></article><h2 id="Simplification-and-Transformation"><a class="docs-heading-anchor" href="#Simplification-and-Transformation">Simplification and Transformation</a><a id="Simplification-and-Transformation-1"></a><a class="docs-heading-anchor-permalink" href="#Simplification-and-Transformation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.simplify" href="#SymbolicUtils.simplify"><code>SymbolicUtils.simplify</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">simplify(x; expand=false,
            threaded=false,
            thread_subtree_cutoff=100,
            rewriter=nothing)</code></pre><p>Simplify an expression (<code>x</code>) by applying <code>rewriter</code> until there are no changes. <code>expand=true</code> applies <a href="/api/#expand"><code>expand</code></a> in the beginning of each fixpoint iteration.</p><p>By default, simplify will assume denominators are not zero and allow cancellation in fractions. Pass <code>simplify_fractions=false</code> to prevent this.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/7fa3f76d1ada08c23a7953d5a52acf935435eae4/src/simplify.jl#L2-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.expand" href="#SymbolicUtils.expand"><code>SymbolicUtils.expand</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">expand(expr)</code></pre><p>Expand expressions by distributing multiplication over addition, e.g., <code>a*(b+c)</code> becomes <code>ab+ac</code>.</p><p><code>expand</code> uses replace symbols and non-algebraic expressions by variables of type <code>variable_type</code> to compute the distribution using a specialized sparse multivariate polynomials implementation. <code>variable_type</code> can be any subtype of <code>MultivariatePolynomials.AbstractVariable</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/7fa3f76d1ada08c23a7953d5a52acf935435eae4/src/polyform.jl#L121-L131">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.substitute" href="#SymbolicUtils.substitute"><code>SymbolicUtils.substitute</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">substitute(expr, dict; fold=true)</code></pre><p>substitute any subexpression that matches a key in <code>dict</code> with the corresponding value. If <code>fold=false</code>, expressions which can be evaluated won&#39;t be evaluated.</p><pre><code class="language-julia hljs">julia&gt; substitute(1+sqrt(y), Dict(y =&gt; 2), fold=true)
2.414213562373095
julia&gt; substitute(1+sqrt(y), Dict(y =&gt; 2), fold=false)
1 + sqrt(2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/7fa3f76d1ada08c23a7953d5a52acf935435eae4/src/substitute.jl#L92-L105">source</a></section></article><h2 id="Polynomial-Forms"><a class="docs-heading-anchor" href="#Polynomial-Forms">Polynomial Forms</a><a id="Polynomial-Forms-1"></a><a class="docs-heading-anchor-permalink" href="#Polynomial-Forms" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.simplify_fractions" href="#SymbolicUtils.simplify_fractions"><code>SymbolicUtils.simplify_fractions</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">simplify_fractions(x; polyform=false)</code></pre><p>Find <code>Div</code> nodes and simplify them by cancelling a set of factors of numerators and denominators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/7fa3f76d1ada08c23a7953d5a52acf935435eae4/src/polyform.jl#L414-L419">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.quick_cancel" href="#SymbolicUtils.quick_cancel"><code>SymbolicUtils.quick_cancel</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">quick_cancel(d)</code></pre><p>Cancel out matching factors from numerator and denominator. This is not as effective as <code>simplify_fractions</code>, for example, it wouldn&#39;t simplify <code>(x^2 + 15 -  8x)  / (x - 5)</code> to <code>(x - 3)</code>. But it will simplify <code>(x - 5)^2*(x - 3) / (x - 5)</code> to <code>(x - 5)*(x - 3)</code>. Has optimized processes for <code>Mul</code> and <code>Pow</code> terms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/7fa3f76d1ada08c23a7953d5a52acf935435eae4/src/polyform.jl#L212-L220">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.flatten_fractions" href="#SymbolicUtils.flatten_fractions"><code>SymbolicUtils.flatten_fractions</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">flatten_fractions(x)</code></pre><p>Flatten nested fractions that are added together.</p><pre><code class="language-julia hljs">julia&gt; flatten_fractions((1+(1+1/a)/a)/a)
(1 + a + a^2) / (a^3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/7fa3f76d1ada08c23a7953d5a52acf935435eae4/src/polyform.jl#L432-L441">source</a></section></article><h2 id="Code-Generation"><a class="docs-heading-anchor" href="#Code-Generation">Code Generation</a><a id="Code-Generation-1"></a><a class="docs-heading-anchor-permalink" href="#Code-Generation" title="Permalink"></a></h2><h3 id="Core-Functions"><a class="docs-heading-anchor" href="#Core-Functions">Core Functions</a><a id="Core-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Core-Functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.Code.toexpr" href="#SymbolicUtils.Code.toexpr"><code>SymbolicUtils.Code.toexpr</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">toexpr(ex, [st,])</code></pre><p>Convert a symbolic expression into an <code>Expr</code>, suitable to be passed into <code>eval</code>.</p><p>For example,</p><pre><code class="language-julia hljs">julia&gt; @syms a b
(a, b)

julia&gt; toexpr(a+b)
:((+)(a, b))

julia&gt; toexpr(a+b) |&gt; dump
Expr
  head: Symbol call
  args: Array{Any}((3,))
    1: + (function of type typeof(+))
    2: Symbol a
    3: Symbol b</code></pre><p>Note that the function is an actual function object.</p><p>For more complex expressions, see other code-related combinators,</p><p>Namely <code>Assignment</code>, <code>Let</code>, <code>Func</code>, <code>SetArray</code>, <code>MakeArray</code>, <code>MakeSparseArray</code> and <code>MakeTuple</code>.</p><p>To make your own type convertible to Expr using <code>toexpr</code> define <code>toexpr(x, st)</code> and forward the state <code>st</code> in internal calls to <code>toexpr</code>. <code>st</code> is state used to know when to leave something like <code>y(t)</code> as it is or when to make it <code>var&quot;y(t)&quot;</code>. E.g. when <code>y(t)</code> is itself the argument of a function rather than <code>y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/7fa3f76d1ada08c23a7953d5a52acf935435eae4/src/code.jl#L47-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.Code.cse" href="#SymbolicUtils.Code.cse"><code>SymbolicUtils.Code.cse</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cse(expr) -&gt; Any
</code></pre><p>Perform common subexpression elimination on an expression.</p><p>This optimization identifies repeated subexpressions and replaces them with variables to avoid redundant computation.</p><p><strong>Arguments</strong></p><ul><li><code>expr</code>: The expression to optimize</li></ul><p><strong>Returns</strong></p><p>An optimized expression with common subexpressions eliminated</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; expr = :(sin(x) + sin(x) * cos(y))
julia&gt; cse(expr)  # sin(x) is computed only once</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/7fa3f76d1ada08c23a7953d5a52acf935435eae4/src/code.jl#L944-L963">source</a></section></article><h3 id="Code-Generation-Types"><a class="docs-heading-anchor" href="#Code-Generation-Types">Code Generation Types</a><a id="Code-Generation-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Code-Generation-Types" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.Code.Assignment" href="#SymbolicUtils.Code.Assignment"><code>SymbolicUtils.Code.Assignment</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Assignment(lhs, rhs)</code></pre><p>An assignment expression. Shorthand <code>lhs ← rhs</code> (<code>\leftarrow</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/7fa3f76d1ada08c23a7953d5a52acf935435eae4/src/code.jl#L90-L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.Code.Let" href="#SymbolicUtils.Code.Let"><code>SymbolicUtils.Code.Let</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Let(assignments, body[, let_block])</code></pre><p>A Let block.</p><ul><li><code>assignments</code> is a vector of <code>Assignment</code>s</li><li><code>body</code> is the body of the let block</li><li><code>let_block</code> boolean (default=true) – do not create a let block if false.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/7fa3f76d1ada08c23a7953d5a52acf935435eae4/src/code.jl#L375-L383">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.Code.Func" href="#SymbolicUtils.Code.Func"><code>SymbolicUtils.Code.Func</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Func(args, kwargs, body[, pre])</code></pre><p>A function.</p><ul><li><code>args</code> is a vector of expressions</li><li><code>kwargs</code> is a vector of <code>Assignment</code>s</li><li><code>body</code> is the body of the function</li><li><code>pre</code> a vector of expressions to be prepended to the function body,  for example, it could be <code>[Expr(:meta, :inline), Expr(:meta, :propagate_inbounds)]</code>  to create an <code>@inline @propagate_inbounds</code> function definition.</li></ul><p><strong>Special features in <code>args</code></strong>:</p><ul><li>args can contain <code>DestructuredArgs</code></li><li>call expressions</li></ul><p>For example,</p><pre><code class="language-julia hljs">
julia&gt; @syms a b c t f(d) x(t) y(t) z(t)
(a, b, c, t, f(::Number)::Number, x(::Number)::Number, y(::Number)::Number, z(::Number)::Number)

julia&gt; func = Func([a,x(t), DestructuredArgs([b, y(t)]), f], # args
                   [c ← 2, z(t) ← 42], # kwargs
                   f((a + b + c) / x(t) + y(t) + z(t)));

julia&gt; toexpr(func)
:(function (a, var&quot;x(t)&quot;, var&quot;##arg#255&quot;, f; c = 2, var&quot;z(t)&quot; = 42)
      let b = var&quot;##arg#255&quot;[1], var&quot;y(t)&quot; = var&quot;##arg#255&quot;[2]
          f((+)(var&quot;y(t)&quot;, var&quot;z(t)&quot;, (*)((+)(a, b, c), (inv)(var&quot;x(t)&quot;))))
      end
  end)</code></pre><ul><li>the second argument is a <code>DestructuredArgs</code>, in the <code>Expr</code> form, it is given a random name, and is expected to receive a vector or tuple of size 2 containing the values of <code>b</code> and <code>y(t)</code>. The let block that is automatically generated &quot;destructures&quot; these arguments.</li><li><code>x(t)</code> and <code>y(t)</code> have been replaced with <code>var&quot;x(t)&quot;</code> and <code>var&quot;y(t)&quot;</code> symbols throughout</li></ul><p>the generated Expr. This makes sure that we are not actually calling the expressions <code>x(t)</code> or <code>y(t)</code> but instead passing the right values in place of the whole expression.</p><ul><li><code>f</code> is also a function-like symbol, same as <code>x</code> and <code>y</code>, but since the <code>args</code> array contains <code>f</code> as itself rather than as say, <code>f(t)</code>, it does not become a <code>var&quot;f(t)&quot;</code>. The generated function expects a function of one argument to be passed in the position of <code>f</code>.</li></ul><p>An example invocation of this function is:</p><pre><code class="language-julia hljs">julia&gt; executable = eval(toexpr(func))
#10 (generic function with 1 method)

julia&gt; executable(1, 2.0, [2,3.0], x-&gt;string(x); var&quot;z(t)&quot; = sqrt(42))
&quot;11.98074069840786&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/7fa3f76d1ada08c23a7953d5a52acf935435eae4/src/code.jl#L438-L488">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.Code.DestructuredArgs" href="#SymbolicUtils.Code.DestructuredArgs"><code>SymbolicUtils.Code.DestructuredArgs</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DestructuredArgs(elems, [name=gensym(&quot;arg&quot;)])</code></pre><p><code>elems</code> is a vector of symbols or call expressions.  When it appears as an argument in <code>Func</code>, it expects a vector of the same length and de-structures the vector into its named components. See example in <code>Func</code> for more information.</p><p><code>name</code> is the name to be used for the argument in the generated function Expr.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/7fa3f76d1ada08c23a7953d5a52acf935435eae4/src/code.jl#L338-L346">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.Code.LiteralExpr" href="#SymbolicUtils.Code.LiteralExpr"><code>SymbolicUtils.Code.LiteralExpr</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LiteralExpr(ex)</code></pre><p>Literally <code>ex</code>, an <code>Expr</code>. <code>toexpr</code> on <code>LiteralExpr</code> recursively calls <code>toexpr</code> on any interpolated symbolic expressions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/7fa3f76d1ada08c23a7953d5a52acf935435eae4/src/code.jl#L813-L818">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.Code.ForLoop" href="#SymbolicUtils.Code.ForLoop"><code>SymbolicUtils.Code.ForLoop</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ForLoop(itervar, range, body)</code></pre><p>Generate a <code>for</code> loop of the form</p><pre><code class="language-julia hljs">for itervar in range
    body
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/7fa3f76d1ada08c23a7953d5a52acf935435eae4/src/code.jl#L830-L839">source</a></section></article><h3 id="Array-Operations"><a class="docs-heading-anchor" href="#Array-Operations">Array Operations</a><a id="Array-Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Array-Operations" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.Code.SetArray" href="#SymbolicUtils.Code.SetArray"><code>SymbolicUtils.Code.SetArray</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SetArray(inbounds::Bool, arr, elems[, return_arr::Bool])</code></pre><p>An expression representing setting of elements of <code>arr</code>.</p><p>By default, every element of <code>elems</code> is copied over to <code>arr</code>,</p><p>but if <code>elems</code> contains <code>AtIndex(i, val)</code> objects, then <code>arr[i] = val</code> is performed in its place.</p><p><code>inbounds</code> is a boolean flag, <code>true</code> surrounds the resulting expression in an <code>@inbounds</code>.</p><p><code>return_arr</code> is a flag which controls whether the generated <code>begin..end</code> block returns the <code>arr</code>. Defaults to <code>false</code>, in which case the block returns <code>nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/7fa3f76d1ada08c23a7953d5a52acf935435eae4/src/code.jl#L523-L538">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.Code.MakeArray" href="#SymbolicUtils.Code.MakeArray"><code>SymbolicUtils.Code.MakeArray</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MakeArray(elems, similarto, [output_eltype=nothing])</code></pre><p>An expression which constructs an array.</p><ul><li><code>elems</code> is the output array</li><li><code>similarto</code> can either be a type, or some symbol that is an array whose type needs to  be emulated. If <code>similarto</code> is a StaticArrays.SArray, then the output array is also  created as an <code>SArray</code>, similarly, an <code>Array</code> will result in an <code>Array</code>, and a  <code>LabelledArrays.SLArray</code> will result in a labelled static array.</li><li><code>output_eltype</code>: if set, then forces the element type of the output array to be this.  by default, the output type is inferred automatically.</li></ul><p>You can define:</p><pre><code class="nohighlight hljs">@inline function create_array(A::Type{&lt;:MyArray},a
                              ::Nothing, d::Val{dims}, elems...) where dims

# and

@inline function create_array(::Type{&lt;:MyArray}, T, ::Val{dims}, elems...) where dims</code></pre><p>which creates an array of size <code>dims</code> using the elements <code>elems</code> and eltype <code>T</code>, to allow <code>MakeArray</code> to create arrays similarto <code>MyArray</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/7fa3f76d1ada08c23a7953d5a52acf935435eae4/src/code.jl#L567-L593">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.Code.MakeSparseArray" href="#SymbolicUtils.Code.MakeSparseArray"><code>SymbolicUtils.Code.MakeSparseArray</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MakeSpaseArray(array)</code></pre><p>An expression which creates a <code>SparseMatrixCSC</code> or a <code>SparseVector</code>.</p><p>The generated expression contains the sparsity information of <code>array</code>,</p><p>it only creates the <code>nzval</code> field at run time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/7fa3f76d1ada08c23a7953d5a52acf935435eae4/src/code.jl#L721-L729">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.Code.MakeTuple" href="#SymbolicUtils.Code.MakeTuple"><code>SymbolicUtils.Code.MakeTuple</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MakeTuple(tup)</code></pre><p>Make a Tuple from a tuple of expressions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/7fa3f76d1ada08c23a7953d5a52acf935435eae4/src/code.jl#L752-L756">source</a></section></article><h3 id="Parallelism"><a class="docs-heading-anchor" href="#Parallelism">Parallelism</a><a id="Parallelism-1"></a><a class="docs-heading-anchor-permalink" href="#Parallelism" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.Code.SpawnFetch" href="#SymbolicUtils.Code.SpawnFetch"><code>SymbolicUtils.Code.SpawnFetch</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SpawnFetch{ParallelType}(funcs [, args], reduce)</code></pre><p>Run every expression in <code>funcs</code> in its own task, the expression should be a <code>Func</code> object and is passed to <code>Threads.Task(f)</code>. If <code>Func</code> takes arguments, then the arguments must be passed in as <code>args</code>–a vector of vector of arguments to each function in <code>funcs</code>. We don&#39;t use <code>@spawn</code> in order to support RuntimeGeneratedFunctions which disallow closures, instead we interpolate these functions or closures as smaller RuntimeGeneratedFunctions.</p><p><code>reduce</code> function is used to combine the results of executing <code>exprs</code>. A SpawnFetch expression returns the reduced result.</p><p>Use <code>Symbolics.MultithreadedForm</code> ParallelType from the Symbolics.jl package to get the RuntimeGeneratedFunction version SpawnFetch.</p><p><code>ParallelType</code> can be used to define more parallelism types SymbolicUtils supports <code>Multithreaded</code> type. Which spawns threaded tasks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/7fa3f76d1ada08c23a7953d5a52acf935435eae4/src/code.jl#L779-L794">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.Code.Multithreaded" href="#SymbolicUtils.Code.Multithreaded"><code>SymbolicUtils.Code.Multithreaded</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Multithreaded</code></pre><p>A parallelism type for <code>SpawnFetch</code> that uses Julia&#39;s threading system.</p><p>When used with <code>SpawnFetch{Multithreaded}</code>, expressions are executed in parallel using <code>Threads.@spawn</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; SpawnFetch{Multithreaded}([func1, func2], combine_func)</code></pre><p>See also: <a href="#SymbolicUtils.Code.SpawnFetch"><code>SpawnFetch</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/7fa3f76d1ada08c23a7953d5a52acf935435eae4/src/code.jl#L763-L777">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../manual/codegen/">« Code generation</a><a class="docs-footer-nextpage" href="../upgrade/">Upgrade to SymbolicUtils v1 »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Friday 26 September 2025 11:34">Friday 26 September 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
