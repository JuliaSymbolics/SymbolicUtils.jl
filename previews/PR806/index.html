<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>SymbolicUtils.jl — Symbolic programming in Julia · SymbolicUtils.jl</title><meta name="title" content="SymbolicUtils.jl — Symbolic programming in Julia · SymbolicUtils.jl"/><meta property="og:title" content="SymbolicUtils.jl — Symbolic programming in Julia · SymbolicUtils.jl"/><meta property="twitter:title" content="SymbolicUtils.jl — Symbolic programming in Julia · SymbolicUtils.jl"/><meta name="description" content="Documentation for SymbolicUtils.jl."/><meta property="og:description" content="Documentation for SymbolicUtils.jl."/><meta property="twitter:description" content="Documentation for SymbolicUtils.jl."/><meta property="og:url" content="https://docs.sciml.ai/SymbolicUtils/stable/"/><meta property="twitter:url" content="https://docs.sciml.ai/SymbolicUtils/stable/"/><link rel="canonical" href="https://docs.sciml.ai/SymbolicUtils/stable/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script><link href="assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>SymbolicUtils.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>SymbolicUtils.jl — Symbolic programming in Julia</a><ul class="internal"><li><a class="tocitem" href="#Features"><span>Features</span></a></li><li><a class="tocitem" href="#Creating-symbolic-expressions"><span>Creating symbolic expressions</span></a></li><li><a class="tocitem" href="#Function-like-symbols"><span>Function-like symbols</span></a></li><li><a class="tocitem" href="#Expression-interface"><span>Expression interface</span></a></li><li><a class="tocitem" href="#Term-rewriting"><span>Term rewriting</span></a></li><li><a class="tocitem" href="#Simplification"><span>Simplification</span></a></li><li><a class="tocitem" href="#Code-generation"><span>Code generation</span></a></li><li><a class="tocitem" href="#Learn-more"><span>Learn more</span></a></li></ul></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="manual/variants/">Variant structure and types</a></li><li><a class="tocitem" href="manual/rewrite/">Term Rewriting</a></li><li><a class="tocitem" href="manual/interface/">Interfacing with SymbolicUtils.jl</a></li><li><a class="tocitem" href="manual/codegen/">Code generation</a></li><li><a class="tocitem" href="manual/caching/">Caching recursive functions</a></li><li><a class="tocitem" href="manual/recursive_utils/">Recursive utility functions</a></li></ul></li><li><a class="tocitem" href="api/">API Reference</a></li><li><a class="tocitem" href="upgrade/">Upgrade to SymbolicUtils v1</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>SymbolicUtils.jl — Symbolic programming in Julia</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>SymbolicUtils.jl — Symbolic programming in Julia</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/master/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="SymbolicUtils.jl-—-Symbolic-programming-in-Julia"><a class="docs-heading-anchor" href="#SymbolicUtils.jl-—-Symbolic-programming-in-Julia">SymbolicUtils.jl — Symbolic programming in Julia</a><a id="SymbolicUtils.jl-—-Symbolic-programming-in-Julia-1"></a><a class="docs-heading-anchor-permalink" href="#SymbolicUtils.jl-—-Symbolic-programming-in-Julia" title="Permalink"></a></h1><h2 id="Features"><a class="docs-heading-anchor" href="#Features">Features</a><a id="Features-1"></a><a class="docs-heading-anchor-permalink" href="#Features" title="Permalink"></a></h2><ul><li>Fast expressions</li><li>A <a href="/rewrite/#rule-based_rewriting">rule-based rewriting language</a>.</li><li>A <a href="/rewrite/#composing_rewriters">combinator library</a> for making rewriters.</li><li><a href="/representation/">Efficient representation</a> of numeric expressions</li><li>Type promotion:<ul><li>Symbols (<code>Sym</code>s) carry type information. (<a href="#creating_symbolic_expressions">read more</a>)</li><li>Compound expressions composed of <code>Sym</code>s propagate type information. (<a href="#expression_interface">read more</a>)</li></ul></li><li>Set of extendable <a href="#Simplification">simplification rules</a>.</li></ul><h2 id="Creating-symbolic-expressions"><a class="docs-heading-anchor" href="#Creating-symbolic-expressions">Creating symbolic expressions</a><a id="Creating-symbolic-expressions-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-symbolic-expressions" title="Permalink"></a></h2><p>First, let&#39;s use the <code>@syms</code> macro to create a few symbols.</p><pre><code class="language-julia hljs">using SymbolicUtils

@syms w z α::Real β::Real

(w, z, α, β) # hide
</code></pre><p>Type annotations are optional when creating symbols. Here <code>α</code>, <code>β</code> behave like Real numbers. <code>w</code> and <code>z</code> behave like <code>Number</code>, which is the default. You can use the <code>symtype</code> function to find the type of a symbol.</p><pre><code class="language-julia hljs">using SymbolicUtils: symtype

symtype(w), symtype(z),  symtype(α), symtype(β)</code></pre><p>Note however that they are not subtypes of these types!</p><pre><code class="language-julia hljs">@show w isa Number
@show α isa Real</code></pre><p>As their types are different:</p><pre><code class="language-julia hljs">@show typeof(w)
@show typeof(α)</code></pre><p>(see <a href="https://discourse.julialang.org/t/ann-symbolicutils-jl-groundwork-for-a-symbolic-ecosystem-in-julia/38455/13?u=shashi">this post</a> for why they are all not just subtypes of <code>Number</code>)</p><p>You can do basic arithmetic on symbols to get symbolic expressions:</p><pre><code class="language-julia hljs">expr1 = α*sin(w)^2 + β*cos(z)^2
expr2 = α*cos(z)^2 + β*sin(w)^2

expr1 + expr2</code></pre><p>SymbolicUtils automatically simplifies</p><pre><code class="language-julia hljs">2w + 3w - 3z + α</code></pre><p>and reorders</p><pre><code class="language-julia hljs">(z + w)*(α + β)</code></pre><p>expressions of type <code>Symbolic{&lt;:Number}</code> (which includes <code>Sym{Real}</code>) when they are created. It also does constant elimination (including rational numbers)</p><pre><code class="language-julia hljs">5 + 2w - 3z + α - (β + 5//3) + 3w - 2 + 3//2 * β</code></pre><p>It&#39;s worth remembering that the expression may be transformed with respect to the input when it&#39;s created.</p><h2 id="Function-like-symbols"><a class="docs-heading-anchor" href="#Function-like-symbols">Function-like symbols</a><a id="Function-like-symbols-1"></a><a class="docs-heading-anchor-permalink" href="#Function-like-symbols" title="Permalink"></a></h2><p>Symbols can be defined to behave like functions. Both the input and output types for the function can be specified. Any application to that function will only admit either values of those types or symbols of the same <code>symtype</code>.</p><pre><code class="language-julia hljs">using SymbolicUtils
@syms f(x) g(x::Real, y::Real)::Real

f(z) + g(1, α) + sin(w)</code></pre><p>This does not work since <code>z</code> is a <code>Number</code>, not a <code>Real</code>.</p><pre><code class="language-julia hljs">g(1, z)</code></pre><p>This works because <code>g</code> &quot;returns&quot; a <code>Real</code>.</p><pre><code class="language-julia hljs">g(2//5, g(1, β))</code></pre><h2 id="Expression-interface"><a class="docs-heading-anchor" href="#Expression-interface">Expression interface</a><a id="Expression-interface-1"></a><a class="docs-heading-anchor-permalink" href="#Expression-interface" title="Permalink"></a></h2><p>Symbolic expressions are of type <code>Term{T}</code>, <code>Add{T}</code>, <code>Mul{T}</code>, <code>Pow{T}</code> or <code>Div{T}</code> and denote some function call where one or more arguments are themselves such expressions or <code>Sym</code>s. See more about the representation <a href="/representation/">here</a>.</p><p>All the expression types support the <a href="https://github.com/0x0f0f0f/TermInterface.jl">TermInterface.jl</a> interface. Please refer to the package for the complete reference of the interface.</p><h2 id="Term-rewriting"><a class="docs-heading-anchor" href="#Term-rewriting">Term rewriting</a><a id="Term-rewriting-1"></a><a class="docs-heading-anchor-permalink" href="#Term-rewriting" title="Permalink"></a></h2><p>SymbolicUtils contains <a href="/rewrite/#rule-based_rewriting">a rule-based rewriting language</a> for easy pattern matching and rewriting of expression. There is also a <a href="/rewrite/#composing_rewriters">combinator library</a> to combine rules to chain, branch and loop over rules.</p><h2 id="Simplification"><a class="docs-heading-anchor" href="#Simplification">Simplification</a><a id="Simplification-1"></a><a class="docs-heading-anchor-permalink" href="#Simplification" title="Permalink"></a></h2><p>By default <code>+</code>, <code>*</code> and <code>^</code> operations apply the most basic simplification upon construction of the expression.</p><p>The rules with which the canonical form of <code>Symbolic{&lt;:Number}</code> terms are constructed are the next (where <code>x isa Symbolic</code> and <code>c isa Number</code>)</p><ul><li><code>0 + x</code>, <code>1 * x</code> and <code>x^1</code> always gives <code>x</code></li><li><code>0 * x</code> always gives <code>0</code> and <code>x ^ 0</code> gives <code>1</code></li><li><code>-x</code> becomes <code>(-1)*x</code></li><li>commutativity and associativity over <code>+</code> and <code>*</code> are assumed. Re-ordering of terms will be done under a <a href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/master/src/ordering.jl">total order</a></li><li><code>p/q * x</code> or <code>x * p/q</code> results in <code>(p*x)/q</code></li><li><code>p/q * x/y</code> results in <code>(p*x)/(q*y)</code></li><li><code>x + ... + x</code> will be fused into <code>n*x</code> with type <code>Mul</code></li><li><code>x * ... * x</code> will be fused into <code>x^n</code> with type <code>Pow</code></li><li>sum of <code>Add</code>&#39;s are fused</li><li>product of <code>Mul</code>&#39;s are fused</li><li><code>c * (c₁x₁ + ... + cₙxₙ)</code> will be converted into <code>c*c₁*x₁ + ... + c*cₙ*xₙ</code></li><li><code>(x₁^c₁ * ... * xₙ^cₙ)^c</code> will be converted into <code>x₁^(c*c₁) * ... * xₙ^(c*cₙ)</code></li><li>there are come other simplifications on construction that you can check <a href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/master/src/methods.jl">here</a></li></ul><p>Here is an example of this</p><pre><code class="language-julia hljs">2 * (w+w+α+β + sin(z)^2 + cos(z)^2 - 1)</code></pre><p>The <code>simplify</code> function applies a built-in set of rules to rewrite expressions in order to simplify it.</p><pre><code class="language-julia hljs">simplify(2 * (w+w+α+β + sin(z)^2 + cos(z)^2 - 1))</code></pre><p>The rules in the default simplify applies simple constant elimination and trigonometric identities.</p><p>If you read the previous section on the rules DSL, you should be able to read and understand the <a href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/master/src/simplify_rules.jl">rules</a> that are used by <code>simplify</code>.</p><h2 id="Code-generation"><a class="docs-heading-anchor" href="#Code-generation">Code generation</a><a id="Code-generation-1"></a><a class="docs-heading-anchor-permalink" href="#Code-generation" title="Permalink"></a></h2><p><strong>Experimental feature</strong></p><p>It is common to want to generate executable code from symbolic expressions and blocks of them. We are working on experimental support for turning Symbolic expressions into executable functions with specific focus on array input and output and performance which is critical to the Differential Equations ecosystem which is making heavy use of this package.</p><p>See <a href="/codegen/">Code generation</a> for more about this.</p><h2 id="Learn-more"><a class="docs-heading-anchor" href="#Learn-more">Learn more</a><a id="Learn-more-1"></a><a class="docs-heading-anchor-permalink" href="#Learn-more" title="Permalink"></a></h2><p>If you have a package that you would like to utilize rule-based rewriting in, look at the suggestions in the <a href="/interface/">Interfacing</a> section to find out how you can do that without any fundamental changes to your package. Look at the <a href="/api/">API documentation</a> for docstrings about specific functions or macros.</p><p>Head over to the github repository to ask questions and <a href="https://github.com/JuliaSymbolics/SymbolicUtils.jl">report problems</a>! Join the <a href="https://julialang.zulipchat.com/#narrow/stream/236639-symbolic-programming">Zulip stream</a> to chat!</p></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="manual/variants/">Variant structure and types »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.15.0 on <span class="colophon-date" title="Tuesday 28 October 2025 10:18">Tuesday 28 October 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
