var documenterSearchIndex = {"docs":
[{"location":"manual/caching/#Caching-recursive-functions","page":"Caching recursive functions","title":"Caching recursive functions","text":"","category":"section"},{"location":"manual/caching/","page":"Caching recursive functions","title":"Caching recursive functions","text":"Many functions benefit greatly from caching their results such that repeated calls with the same arguments can return cached values. As an example, getindex on symbolic arrays is a cached function since the operation can be expensive. SymbolicUtils.jl provides the @cache macro to allow easily caching such functions, with special benefits when the arguments are symbolic.","category":"page"},{"location":"manual/caching/#SymbolicUtils.@cache","page":"Caching recursive functions","title":"SymbolicUtils.@cache","text":"@cache [options...] function foo(arg1::Type, arg2::Type; kwargs...)::ReturnType\n    # ...\nend\n\nCreate a cached version of the function foo. This is typically useful for recursive functions that descend through an expression tree.\n\nThe return type of the function should be annotated to avoid warnings. If any of the argument types is a BasicSymbolic, uses a special caching for efficiency. If an argument has Any type or a Union containing BasicSymbolic, a runtime check is performed to handle it. This can be avoided if the type is annotated with BasicSymbolic. The maximum number of entries in the cache can be set using the limit option by providing an integer size. This defaults to 100_000. When this limit is hit, a fraction of the entries in the cache will be cleared at random. The fraction of entries retained is given by the retain_fraction option, which defaults to 0.5.\n\nMultiple methods of the same function cannot be cached and will lead to an error. This should be avoided by creating a wrapper function which calls the one with ,multiple methods, and caching the wrapper. The function with multiple methods should recursively call the wrapper. Caching a single method is valid.\n\nThe cache is thread-safe and uses TaskLocalValues.jl to maintain a task-specific cache.\n\nThe caching behavior for this function is enabled by default. Use the enabled option to toggle this.\n\nSee also: SymbolicUtils.get_limit, SymbolicUtils.set_limit!, SymbolicUtils.get_retain_fraction, SymbolicUtils.set_retain_fraction!, SymbolicUtils.toggle_caching!, SymbolicUtils.is_caching_enabled, SymbolicUtils.get_stats, SymbolicUtils.clear_cache!, [SymbolicUtils.reset_stats!].\n\n\n\n\n\n","category":"macro"},{"location":"manual/caching/#SymbolicUtils.associated_cache","page":"Caching recursive functions","title":"SymbolicUtils.associated_cache","text":"associated_cache(fn)\n\nGiven a function annotated with @cache, get the cache struct it uses. Automatically implemented by @cache.\n\n\n\n\n\n","category":"function"},{"location":"manual/caching/#SymbolicUtils.get_limit","page":"Caching recursive functions","title":"SymbolicUtils.get_limit","text":"get_limit(fn)\n\n\nGet the maximum size for the cache associated with function fn.\n\n\n\n\n\n","category":"function"},{"location":"manual/caching/#SymbolicUtils.is_caching_enabled","page":"Caching recursive functions","title":"SymbolicUtils.is_caching_enabled","text":"is_caching_enabled(fn)\n\n\nCheck whether caching is enabled for fn.\n\n\n\n\n\n","category":"function"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Symbols-and-Terms","page":"API Reference","title":"Symbols and Terms","text":"","category":"section"},{"location":"api/#Creating-Symbols-and-Terms","page":"API Reference","title":"Creating Symbols and Terms","text":"","category":"section"},{"location":"api/#SymbolicUtils.@syms-api","page":"API Reference","title":"SymbolicUtils.@syms","text":"@syms <lhs_expr>[::T1] <lhs_expr>[::T2]...\n\nFor instance:\n\n@syms foo::Real bar baz(x, y::Real)::Complex\n\nCreate one or more variables. <lhs_expr> can be just a symbol in which case it will be the name of the variable, or a function call in which case a function-like variable which has the same name as the function being called. The Sym type, or in the case of a function-like Sym, the output type of calling the function can be set using the ::T syntax.\n\nExamples:\n\n@syms foo bar::Real baz::Int will create\n\nvariable foo of symtype Number (the default), bar of symtype Real and baz of symtype Int\n\n@syms f(x) g(y::Real, x)::Int h(a::Int, f(b)) creates 1-arg f 2-arg g\n\nand 2 arg h. The second argument to h must be a one argument function-like variable. So, h(1, g) will fail and h(1, f) will work.\n\nFormal syntax\n\nFollowing is a semi-formal CFG of the syntax accepted by this macro:\n\n# any variable accepted by this macro must be a `var`.\n# `var` can represent a quantity (`value`) or a function `(fn)`.\nvar = value | fn\n# A `value` is represented as a name followed by a suffix\nvalue = name suffix\n# A `name` can be a valid Julia identifier\nname = ident |\n# Or it can be an interpolated variable, in which case `ident` is assumed to refer to\n# a variable in the current scope of type `Symbol` containing the name of this variable.\n# Note that in this case the created symbolic variable will be bound to a randomized\n# Julia identifier.\n       \"$\" ident |\n# Or it can be of the form `Foo.Bar.baz` referencing a value accessible as `Foo.Bar.baz`\n# in the current scope.\n       getproperty_literal\ngetproperty_literal = ident \".\" getproperty_literal | ident \".\" ident\n# The `suffix` can be empty (no suffix) which defaults the type to `Number`\nsuffix = \"\" |\n# or it can be a type annotation (setting the type of the prefix). The shape of the result\n# is inferred from the type as best it can be. In particular, `Array{T, N}` is inferred\n# to have shape `Unknown(N)`.\n         \"::\" type |\n# or it can be a shape annotation, which sets the shape to the one specified by `ranges`.\n# The type defaults to `Array{Number, length(ranges)}`\n         \"[\" ranges \"]\" |\n# lastly, it can be a combined shape and type annotation. Here, the type annotation\n# sets the `eltype` of the symbolic array.\n         \"[\" ranges \"]::\" type\n# `ranges` is either a single `range` or a single range followed by one or more `ranges`.\nranges = range | range \",\" ranges\n# A `range` is simply two bounds separated by a colon, as standard Julia ranges work.\n# The range must be non-empty. Each bound can be a literal integer or an identifier\n# representing an integer in the current scope.\nrange = (int | ident) \":\" (int | ident) |\n# Alternatively, a range can be a Julia expression that evaluates to a range. All identifiers\n# used in `expr` are assumed to exist in the current scope.\n        expr |\n# Alternatively, a range can be a Julia expression evaluating to an iterable of ranges,\n# followed by the splat operator.\n        expr \"...\"\n# A function is represented by a function-call syntax `fncall` followed by the `suffix`\n# above. The type and shape from `suffix` represent the type and shape of the value\n# returned by the symbolic function.\nfn = fncall suffix\n# a function call is a call `head` followed by a parenthesized list of arguments.\nfncall = head \"(\" args \")\"\n# A function call head can be a name, representing the name of the symbolic function.\nhead = ident |\n# Alternatively, it can be a parenthesized type-annotated name, where the type annotation\n# represents the intended supertype of the function. In other words, if this symbolic\n# function were to be replaced by an \"actual\" function, the type-annotation constrains the\n# type of the \"actual\" function.\n       \"(\" ident \"::\" type \")\"\n# Arguments to a function is a list of one or more arguments\nargs = arg | arg \",\" args\n# An argument can take the syntax of a variable (which means we can represent functions of\n# functions of functions of...). The type of the variable constrains the type of the\n# corresponding argument of the function. The name and shape information is discarded.\narg = var |\n# Or an argument can be an unnamed type-annotation, which constrains the type without\n# requiring a name.\n      \"::\" type |\n# Or an argument can be the identifier `..`, which is used as a stand-in for `Vararg{Any}`\n      \"..\" |\n# Or an argument can be a type-annotated `..`, representing `Vararg{type}`. Note that this\n# and the previous version of `arg` can only be the last element in `args` due to Julia's\n# `Tuple` semantics.\n      \"(..)::\" type |\n# Or an argument can be a Julia expression followed by a splat operator. This assumes the\n# expression evaluates to an iterable of symbolic variables whose `symtype` should be used\n# as the argument types. Note that `expr` may be evaluated multiple times in the macro\n# expansion.\n      expr \"...\"\n\n\n\n\n\n","category":"macro"},{"location":"api/#SymbolicUtils.term-api","page":"API Reference","title":"SymbolicUtils.term","text":"term(f, args...; vartype = SymReal, type = promote_symtype(f, symtype.(args)...), shape = promote_shape(f, SymbolicUtils.shape.(args)...))\n\nCreate a symbolic term with operation f and arguments args.\n\nArguments\n\nf: The operation or function head of the term\nargs...: The arguments to the operation\nvartype: The variant type for the term (default: SymReal)\ntype: The symbolic type of the term. If not provided, it is inferred using promote_symtype on the function and argument types.\nshape: The shape of the term. If not provided, it is inferred using promote_shape on the function and argument shapes.\n\nExamples\n\njulia> @syms x y\n(x, y)\n\njulia> term(+, x, y)\nx + y\n\njulia> term(sin, x)\nsin(x)\n\njulia> term(^, x, 2)\nx^2\n\n\n\n\n\n","category":"function"},{"location":"api/#Metadata","page":"API Reference","title":"Metadata","text":"","category":"section"},{"location":"api/#SymbolicUtils.hasmetadata","page":"API Reference","title":"SymbolicUtils.hasmetadata","text":"hasmetadata(s::Symbolic, ctx)\n\nCheck if a symbolic expression has metadata for a given context.\n\nArguments\n\ns::Symbolic: The symbolic expression to check\nctx: The metadata context key (typically a DataType)\n\nReturns\n\ntrue if the expression has metadata for the given context, false otherwise\n\nExamples\n\njulia> @syms x\nx\n\njulia> hasmetadata(x, Float64)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"api/#SymbolicUtils.getmetadata","page":"API Reference","title":"SymbolicUtils.getmetadata","text":"getmetadata(s::Symbolic, ctx)\n\nRetrieve metadata associated with a symbolic expression for a given context.\n\nArguments\n\ns::Symbolic: The symbolic expression\nctx: The metadata context key (typically a DataType)\n\nReturns\n\nThe metadata value associated with the given context\n\nThrows\n\nArgumentError if the expression does not have metadata for the given context\n\nExamples\n\njulia> @syms x::Float64\nx\n\njulia> getmetadata(x, symtype)  # Get the type metadata\nFloat64\n\n\n\n\n\ngetmetadata(s::Symbolic, ctx, default)\n\nRetrieve metadata associated with a symbolic expression for a given context, returning a default value if not found.\n\nArguments\n\ns::Symbolic: The symbolic expression\nctx: The metadata context key (typically a DataType)\ndefault: The default value to return if metadata is not found\n\nReturns\n\nThe metadata value associated with the given context, or default if not found\n\nExamples\n\njulia> @syms x\nx\n\njulia> getmetadata(x, Float64, \"no type\")\n\"no type\"\n\n\n\n\n\n","category":"function"},{"location":"api/#SymbolicUtils.setmetadata","page":"API Reference","title":"SymbolicUtils.setmetadata","text":"setmetadata(s::Symbolic, ctx::DataType, val)\n\nSet metadata for a symbolic expression in a given context.\n\nArguments\n\ns::Symbolic: The symbolic expression\nctx::DataType: The metadata context key\nval: The metadata value to set\n\nReturns\n\nA new symbolic expression with the updated metadata\n\nExamples\n\njulia> @syms x\nx\n\njulia> x_with_meta = setmetadata(x, Float64, \"custom value\")\nx\n\njulia> getmetadata(x_with_meta, Float64)\n\"custom value\"\n\n\n\n\n\n","category":"function"},{"location":"api/#Type-Promotion","page":"API Reference","title":"Type Promotion","text":"","category":"section"},{"location":"api/#SymbolicUtils.promote_symtype-api","page":"API Reference","title":"SymbolicUtils.promote_symtype","text":"promote_symtype(f, Ts...) -> Type{Bool}\n\n\nThe result of applying f to arguments of SymbolicUtils.symtype Ts...\n\njulia> promote_symtype(+, Real, Real)\nReal\n\njulia> promote_symtype(+, Complex, Real)\nNumber\n\njulia> @syms f(x)::Complex\n(f(::Number)::Complex,)\n\njulia> promote_symtype(f, Number)\nComplex\n\nWhen constructing expressions without an explicit symtype, promote_symtype is used to figure out the symtype of the Term.\n\nIt is recommended that all type arguments be annotated with SymbolicUtils.TypeT and one method be implemented for any combination of f and the number of arguments. For example, one method is implemented for unary - and one method for binary -. Each method has an if..elseif chain to handle possible types. Any call to promote_type should be typeasserted with ::TypeT.\n\n\n\n\n\npromote_symtype(f::FnType{X,Y}, arg_symtypes...)\n\nThe output symtype of applying variable f to arguments of symtype arg_symtypes.... if the arguments are of the wrong type then this function will error.\n\n\n\n\n\n","category":"function"},{"location":"api/#Rewriting-System","page":"API Reference","title":"Rewriting System","text":"","category":"section"},{"location":"api/#Rule-Creation","page":"API Reference","title":"Rule Creation","text":"","category":"section"},{"location":"api/#SymbolicUtils.@rule","page":"API Reference","title":"SymbolicUtils.@rule","text":"@rule LHS => RHS\n\nCreates a Rule object. A rule object is callable, and  takes an expression and rewrites it if it matches the LHS pattern to the RHS pattern, returns nothing otherwise. The rule language is described below.\n\nLHS can be any possibly nested function call expression where any of the arguments can optionally be a Slot (~x), Default Value Slot (~!x also called DefSlot) or a Segment  (~~x) (described below).\n\nIf an expression matches LHS entirely, then it is rewritten to the pattern in the RHS. Slot, DefSlot and Segment variables on the RHS will substitute the result of the matches found for these variables in the LHS.\n\nSlot:\n\nA Slot variable is written as ~x and matches a single expression. x is the name of the variable. If a slot appears more than once in an LHS expression then expression matched at every such location must be equal (as shown by isequal).\n\nExample:\n\nSimple rule to turn any sin into cos:\n\njulia> @syms a b c\n(a, b, c)\n\njulia> r = @rule sin(~x) => cos(~x)\nsin(~x) => cos(~x)\n\njulia> r(sin(1+a))\ncos((1 + a))\n\nA rule with 2 segment variables\n\njulia> r = @rule sin(~x + ~y) => sin(~x)*cos(~y) + cos(~x)*sin(~y)\nsin(~x + ~y) => sin(~x) * cos(~y) + cos(~x) * sin(~y)\n\njulia> r(sin(a + b))\ncos(a)*sin(b) + sin(a)*cos(b)\n\nA rule that matches two of the same expressions:\n\njulia> r = @rule sin(~x)^2 + cos(~x)^2 => 1\nsin(~x) ^ 2 + cos(~x) ^ 2 => 1\n\njulia> r(sin(2a)^2 + cos(2a)^2)\n1\n\njulia> r(sin(2a)^2 + cos(a)^2)\n# nothing\n\nDefSlot:\n\nA DefSlot variable is written as ~!x. Works like a normal slot, but can also take default values if not present in the expression.\n\nExample in power:\n\njulia> r_pow = @rule (~x)^(~!m) => ~m\n(~x) ^ ~(!m) => ~m\n\njulia> r_pow(x^2)\n2\n\njulia> r_pow(x)\n1\n\nExample in sum:\n\njulia> r_sum = @rule ~x + ~!y => ~y\n~x + ~(!y) => ~y\n\njulia> r_sum(x+2)\nx\n\njulia> r_sum(x)\n0\n\nCurrently DefSlot is implemented in:\n\nOperation Default value<br>\n* 1\n+ 0\n2nd argument of ^ 1\n\nSegment:\n\nA Segment variable is written as ~~x and matches zero or more expressions in the function call.\n\nExample:\n\nThis implements the distributive property of multiplication: +(~~ys) matches expressions like a + b, a+b+c and so on. On the RHS ~~ys presents as any old julia array.\n\njulia> r = @rule ~x * +((~~ys)) => sum(map(y-> ~x * y, ~~ys));\n\njulia> r(2 * (a+b+c))\n((2 * a) + (2 * b) + (2 * c))\n\nPredicates:\n\nThere are two kinds of predicates, namely over slot variables and over the whole rule. For the former, predicates can be used on both ~x and ~~x by using the ~x::f or ~~x::f. Here f can be any julia function. In the case of a slot the function gets a single matched subexpression, in the case of segment, it gets an array of matched expressions.\n\nThe predicate should return true if the current match is acceptable, and false otherwise.\n\njulia> two_πs(x::Number) = abs(round(x/(2π)) - x/(2π)) < 10^-9\ntwo_πs (generic function with 1 method)\n\njulia> two_πs(x) = false\ntwo_πs (generic function with 2 methods)\n\njulia> r = @rule sin(~~x + ~y::two_πs + ~~z) => sin(+(~~x..., ~~z...))\nsin(~(~x) + ~(y::two_πs) + ~(~z)) => sin(+(~(~x)..., ~(~z)...))\n\njulia> r(sin(a+3π))\n\njulia> r(sin(a+6π))\nsin(a)\n\njulia> r(sin(a+6π+c))\nsin((a + c))\n\nPredicate function gets an array of values if attached to a segment variable (~~x).\n\nFor the predicate over the whole rule, use @rule <LHS> => <RHS> where <predicate>:\n\njulia> @syms a b;\n\njulia> predicate(x) = x === a;\n\njulia> r = @rule ~x => ~x where predicate(~x);\n\njulia> r(a)\na\n\njulia> r(b) === nothing\ntrue\n\nNote that this is syntactic sugar and that it is the same as something like @rule ~x => f(~x) ? ~x : nothing.\n\nDebugging Rules: Note that if the RHS is a single tilde ~, then the rule returns a a dictionary of all [slot variable, expression matched], this is useful for debugging.\n\nExample:\n\njulia> r = @rule (~x + (~y)^(~m)) => ~\n~x + (~y) ^ ~m => (~)\n\njulia> r(a + b^2)\nBase.ImmutableDict{Symbol, Any} with 5 entries:\n  :MATCH => a + b^2\n  :m     => 2\n  :y     => b\n  :x     => a\n  :____  => nothing\n\nContext:\n\nIn predicates: Contextual predicates are functions wrapped in the Contextual type. The function is called with 2 arguments: the expression and a context object passed during a call to the Rule object (maybe done by passing a context to simplify or a RuleSet object).\n\nThe function can use the inputs however it wants, and must return a boolean indicating whether the predicate holds or not.\n\nIn the consequent pattern: Use (@ctx) to access the context object on the right hand side of an expression.\n\n\n\n\n\n","category":"macro"},{"location":"api/#SymbolicUtils.@acrule","page":"API Reference","title":"SymbolicUtils.@acrule","text":"@acrule(lhs => rhs)\n\nCreate an associative-commutative rule that matches all permutations of the arguments.\n\nThis macro creates a rule that can match patterns regardless of the order of arguments in associative and commutative operations like addition and multiplication.\n\nArguments\n\nlhs: The pattern to match (left-hand side)\nrhs: The replacement expression (right-hand side)\n\nExamples\n\njulia> @syms x y z\n(x, y, z)\n\njulia> r = @acrule x + y => 2x  # Matches both x + y and y + x\nACRule(x + y => 2x)\n\njulia> r(x + y)\n2x\n\njulia> r(y + x)\n2x\n\nSee also: @rule, @ordered_acrule\n\n\n\n\n\n","category":"macro"},{"location":"api/#Rewriters","page":"API Reference","title":"Rewriters","text":"","category":"section"},{"location":"api/#SymbolicUtils.Rewriters","page":"API Reference","title":"SymbolicUtils.Rewriters","text":"A rewriter is any function which takes an expression and returns an expression or nothing. If nothing is returned that means there was no changes applicable to the input expression.\n\nThe Rewriters module contains some types which create and transform rewriters.\n\nEmpty() is a rewriter which always returns nothing\nChain(itr) chain an iterator of rewriters into a single rewriter which applies  each chained rewriter in the given order.  If a rewriter returns nothing this is treated as a no-change.\nRestartedChain(itr) like Chain(itr) but restarts from the first rewriter once on the  first successful application of one of the chained rewriters.\nIfElse(cond, rw1, rw2) runs the cond function on the input, applies rw1 if cond  returns true, rw2 if it returns false\nIf(cond, rw) is the same as IfElse(cond, rw, Empty())\nPrewalk(rw; threaded=false, thread_cutoff=100) returns a rewriter which does a pre-order  traversal of a given expression and applies the rewriter rw. Note that if  rw returns nothing when a match is not found, then Prewalk(rw) will  also return nothing unless a match is found at every level of the walk.  threaded=true will use multi threading for traversal. thread_cutoff is  the minimum number of nodes in a subtree which should be walked in a  threaded spawn.\nPostwalk(rw; threaded=false, thread_cutoff=100) similarly does post-order traversal.\nFixpoint(rw) returns a rewriter which applies rw repeatedly until there are no changes to be made.\nFixpointNoCycle behaves like Fixpoint but instead it applies rw repeatedly only while it is returning new results.\nPassThrough(rw) returns a rewriter which if rw(x) returns nothing will instead  return x otherwise will return rw(x).\n\n\n\n\n\n","category":"module"},{"location":"api/#SymbolicUtils.Rewriters.Empty","page":"API Reference","title":"SymbolicUtils.Rewriters.Empty","text":"Empty()\n\nA rewriter that always returns nothing, indicating no rewrite occurred.\n\nThis is useful as a placeholder or for conditional rewriting patterns.\n\nExamples\n\njulia> Empty()(x)\nnothing\n\n\n\n\n\n","category":"type"},{"location":"api/#SymbolicUtils.Rewriters.IfElse","page":"API Reference","title":"SymbolicUtils.Rewriters.IfElse","text":"IfElse(cond, yes, no)\n\nA conditional rewriter that applies yes if cond(x) is true, otherwise applies no.\n\nArguments\n\ncond: A function that returns true or false for the input\nyes: The rewriter to apply if the condition is true\nno: The rewriter to apply if the condition is false\n\nExamples\n\njulia> r = IfElse(x -> x > 0, x -> -x, x -> x)\njulia> r(5)  # Returns -5\njulia> r(-3) # Returns -3\n\nSee also: If\n\n\n\n\n\n","category":"type"},{"location":"api/#SymbolicUtils.Rewriters.If","page":"API Reference","title":"SymbolicUtils.Rewriters.If","text":"If(cond, yes)\n\nA conditional rewriter that applies yes if cond(x) is true, otherwise returns the input unchanged.\n\nThis is equivalent to IfElse(cond, yes, Empty()).\n\nArguments\n\ncond: A function that returns true or false for the input\nyes: The rewriter to apply if the condition is true\n\nExamples\n\njulia> r = If(x -> x > 0, x -> -x)\njulia> r(5)  # Returns -5\njulia> r(-3) # Returns -3 (unchanged)\n\n\n\n\n\n","category":"function"},{"location":"api/#SymbolicUtils.Rewriters.Chain","page":"API Reference","title":"SymbolicUtils.Rewriters.Chain","text":"Chain(rws; stop_on_match=false)\n\nApply a sequence of rewriters to an expression, chaining the results.\n\nEach rewriter in the chain receives the result of the previous rewriter. If a rewriter returns nothing, the input is passed unchanged to the next rewriter.\n\nArguments\n\nrws: A collection of rewriters to apply in sequence\nstop_on_match: If true, stop at the first rewriter that produces a change\n\nExamples\n\njulia> r1 = @rule sin(~x)^2 + cos(~x)^2 => 1\njulia> r2 = @rule sin(2*(~x)) => 2*sin(~x)*cos(~x)\njulia> chain = Chain([r1, r2])\njulia> chain(sin(x)^2 + cos(x)^2)  # Returns 1\n\n\n\n\n\n","category":"type"},{"location":"api/#SymbolicUtils.Rewriters.RestartedChain","page":"API Reference","title":"SymbolicUtils.Rewriters.RestartedChain","text":"RestartedChain(rws)\n\nApply rewriters in sequence, restarting the chain when any rewriter produces a change.\n\nWhen any rewriter in the chain produces a non-nothing result, the entire chain is restarted with that result as the new input.\n\nArguments\n\nrws: A collection of rewriters to apply\n\nExamples\n\njulia> r1 = @rule ~x + ~x => 2 * ~x\njulia> r2 = @rule 2 * ~x => ~x * 2\njulia> chain = RestartedChain([r1, r2])\njulia> chain(x + x)  # Applies r1, then restarts and applies r2\n\n\n\n\n\n","category":"type"},{"location":"api/#SymbolicUtils.Rewriters.Fixpoint","page":"API Reference","title":"SymbolicUtils.Rewriters.Fixpoint","text":"Fixpoint(rw)\n\nApply a rewriter repeatedly until a fixed point is reached.\n\nThe rewriter is applied repeatedly until the output equals the input (either by identity or by isequal), indicating a fixed point has been reached.\n\nArguments\n\nrw: The rewriter to apply repeatedly\n\nExamples\n\njulia> r = @rule ~x + ~x => 2 * ~x\njulia> fp = Fixpoint(r)\njulia> fp(x + x + x + x)  # Keeps applying until no more changes\n\nSee also: FixpointNoCycle\n\n\n\n\n\n","category":"type"},{"location":"api/#SymbolicUtils.Rewriters.FixpointNoCycle","page":"API Reference","title":"SymbolicUtils.Rewriters.FixpointNoCycle","text":"FixpointNoCycle(rw)\n\nFixpointNoCycle behaves like Fixpoint, but returns a rewriter which applies rw repeatedly until  it produces a result that was already produced before, for example,  if the repeated application of rw produces results a, b, c, d, b in order,  FixpointNoCycle stops because b has been already produced. \n\n\n\n\n\n","category":"type"},{"location":"api/#SymbolicUtils.Rewriters.Postwalk","page":"API Reference","title":"SymbolicUtils.Rewriters.Postwalk","text":"Postwalk(rw; threaded=false, thread_cutoff=100, maketerm=maketerm)\n\nApply a rewriter to a symbolic expression tree in post-order (bottom-up).\n\nPost-order traversal visits child nodes before their parents, allowing for simplification of subexpressions before the containing expression.\n\nArguments\n\nrw: The rewriter to apply at each node\nthreaded: If true, use multi-threading for large expressions\nthread_cutoff: Minimum node count to trigger threading\nmaketerm: Function to construct terms (defaults to maketerm)\nfilter: Function which returns whether to search into a subtree\n\nExamples\n\njulia> r = @rule ~x + ~x => 2 * ~x\njulia> pw = Postwalk(r)\njulia> pw((x + x) * (y + y))  # Simplifies both additions\n2x * 2y\n\nSee also: Prewalk\n\n\n\n\n\n","category":"function"},{"location":"api/#SymbolicUtils.Rewriters.Prewalk","page":"API Reference","title":"SymbolicUtils.Rewriters.Prewalk","text":"Prewalk(rw; threaded=false, thread_cutoff=100, maketerm=maketerm)\n\nApply a rewriter to a symbolic expression tree in pre-order (top-down).\n\nPre-order traversal visits parent nodes before their children, allowing for transformation of the overall structure before processing subexpressions.\n\nArguments\n\nrw: The rewriter to apply at each node\nthreaded: If true, use multi-threading for large expressions\nthread_cutoff: Minimum node count to trigger threading\nmaketerm: Function to construct terms (defaults to maketerm)\nfilter: Function which returns whether to search into a subtree\n\nExamples\n\njulia> r = @rule sin(~x) => cos(~x)\njulia> pw = Prewalk(r)\njulia> pw(sin(sin(x)))  # Transforms outer sin first\ncos(cos(x))\n\nSee also: Postwalk\n\n\n\n\n\n","category":"function"},{"location":"api/#SymbolicUtils.Rewriters.PassThrough","page":"API Reference","title":"SymbolicUtils.Rewriters.PassThrough","text":"PassThrough(rw)\n\nA rewriter that returns the input unchanged if the wrapped rewriter returns nothing.\n\nThis is useful for making rewriters that preserve the input when no rule applies.\n\nArguments\n\nrw: The rewriter to wrap\n\nExamples\n\njulia> r = @rule sin(~x) => cos(~x)\njulia> pt = PassThrough(r)\njulia> pt(sin(x))  # Returns cos(x)\njulia> pt(tan(x))  # Returns tan(x) unchanged\n\n\n\n\n\n","category":"type"},{"location":"api/#Simplification-and-Transformation","page":"API Reference","title":"Simplification and Transformation","text":"","category":"section"},{"location":"api/#SymbolicUtils.simplify","page":"API Reference","title":"SymbolicUtils.simplify","text":"simplify(x; expand=false,\n            threaded=false,\n            thread_subtree_cutoff=100,\n            rewriter=nothing)\n\nSimplify an expression (x) by applying rewriter until there are no changes. expand=true applies expand in the beginning of each fixpoint iteration.\n\nBy default, simplify will assume denominators are not zero and allow cancellation in fractions. Pass simplify_fractions=false to prevent this.\n\n\n\n\n\n","category":"function"},{"location":"api/#SymbolicUtils.expand","page":"API Reference","title":"SymbolicUtils.expand","text":"expand(expr)\n\nExpand expressions by distributing multiplication over addition, e.g., a*(b+c) becomes ab+ac.\n\nexpand uses replace symbols and non-algebraic expressions by variables of type variable_type to compute the distribution using a specialized sparse multivariate polynomials implementation. variable_type can be any subtype of MultivariatePolynomials.AbstractVariable.\n\n\n\n\n\n","category":"function"},{"location":"api/#SymbolicUtils.substitute","page":"API Reference","title":"SymbolicUtils.substitute","text":"substitute(expr, dict; fold=Val(false))\n\nsubstitute any subexpression that matches a key in dict with the corresponding value. If fold=Val(false), expressions which can be evaluated won't be evaluated.\n\njulia> substitute(1+sqrt(y), Dict(y => 2), fold=Val(true))\n2.414213562373095\njulia> substitute(1+sqrt(y), Dict(y => 2), fold=Val(false))\n1 + sqrt(2)\n\n\n\n\n\n","category":"function"},{"location":"api/#Polynomial-Forms","page":"API Reference","title":"Polynomial Forms","text":"","category":"section"},{"location":"api/#SymbolicUtils.simplify_fractions","page":"API Reference","title":"SymbolicUtils.simplify_fractions","text":"simplify_fractions(x; polyform=false)\n\nFind Div nodes and simplify them by cancelling a set of factors of numerators and denominators.\n\n\n\n\n\n","category":"function"},{"location":"api/#SymbolicUtils.quick_cancel","page":"API Reference","title":"SymbolicUtils.quick_cancel","text":"quick_cancel(d)\n\nCancel out matching factors from numerator and denominator. This is not as effective as simplify_fractions, for example, it wouldn't simplify (x^2 + 15 -  8x)  / (x - 5) to (x - 3). But it will simplify (x - 5)^2*(x - 3) / (x - 5) to (x - 5)*(x - 3). Has optimized processes for Mul and Pow terms.\n\n\n\n\n\n","category":"function"},{"location":"api/#SymbolicUtils.flatten_fractions","page":"API Reference","title":"SymbolicUtils.flatten_fractions","text":"flatten_fractions(x)\n\nFlatten nested fractions that are added together.\n\njulia> flatten_fractions((1+(1+1/a)/a)/a)\n(1 + a + a^2) / (a^3)\n\n\n\n\n\n","category":"function"},{"location":"manual/rewrite/#Term-Rewriting","page":"Term Rewriting","title":"Term Rewriting","text":"","category":"section"},{"location":"manual/rewrite/#Rule-based-rewriting","page":"Term Rewriting","title":"Rule-based rewriting","text":"","category":"section"},{"location":"manual/rewrite/","page":"Term Rewriting","title":"Term Rewriting","text":"Rewrite rules match and transform an expression. A rule is written using either the @rule macro or the @acrule macro. It creates a callable Rule object.","category":"page"},{"location":"manual/rewrite/#Basics-of-rule-based-term-rewriting-in-SymbolicUtils","page":"Term Rewriting","title":"Basics of rule-based term rewriting in SymbolicUtils","text":"","category":"section"},{"location":"manual/rewrite/","page":"Term Rewriting","title":"Term Rewriting","text":"Here is a simple rewrite rule, that uses formula for the double angle of the sine function:","category":"page"},{"location":"manual/rewrite/","page":"Term Rewriting","title":"Term Rewriting","text":"using SymbolicUtils\n\n@syms w z α::Real β::Real d(..)\n\n(w, z, α, β) # hide\n\nr1 = @rule sin(2(~x)) => 2sin(~x)*cos(~x)\n\nr1(sin(2z))","category":"page"},{"location":"manual/rewrite/","page":"Term Rewriting","title":"Term Rewriting","text":"The @rule macro takes a pair of patterns – the matcher and the consequent (@rule matcher => consequent). If an expression matches the matcher pattern, it is rewritten to the consequent pattern. @rule returns a callable object that applies the rule to an expression.","category":"page"},{"location":"manual/rewrite/","page":"Term Rewriting","title":"Term Rewriting","text":"~x in the example is what is a slot variable named x. In a matcher pattern, slot variables are placeholders that match exactly one expression. When used on the consequent side, they stand in for the matched expression. If a slot variable appears twice in a matcher pattern, all corresponding matches must be equal (as tested by Base.isequal function).","category":"page"},{"location":"manual/rewrite/","page":"Term Rewriting","title":"Term Rewriting","text":"If you try to apply this rule to an expression with triple angle, it will return nothing – this is the way a rule signifies failure to match.","category":"page"},{"location":"manual/rewrite/","page":"Term Rewriting","title":"Term Rewriting","text":"r1(sin(3z))","category":"page"},{"location":"manual/rewrite/","page":"Term Rewriting","title":"Term Rewriting","text":"Slot variable (matcher) is not necessary a single variable:","category":"page"},{"location":"manual/rewrite/","page":"Term Rewriting","title":"Term Rewriting","text":"r1(sin(2*(w-z)))","category":"page"},{"location":"manual/rewrite/","page":"Term Rewriting","title":"Term Rewriting","text":"And can also match a function:","category":"page"},{"location":"manual/rewrite/","page":"Term Rewriting","title":"Term Rewriting","text":"r = @rule (~f)(z+1) => ~f\n\nr(sin(z+1))","category":"page"},{"location":"manual/rewrite/","page":"Term Rewriting","title":"Term Rewriting","text":"Rules are of course not limited to single slot variable","category":"page"},{"location":"manual/rewrite/","page":"Term Rewriting","title":"Term Rewriting","text":"r2 = @rule sin(~x + ~y) => sin(~x)*cos(~y) + cos(~x)*sin(~y);\n\nr2(sin(α+β))","category":"page"},{"location":"manual/rewrite/","page":"Term Rewriting","title":"Term Rewriting","text":"Now let's say you want to catch the coefficients of a second degree polynomial in z. You can do that with:","category":"page"},{"location":"manual/rewrite/","page":"Term Rewriting","title":"Term Rewriting","text":"c2d = @rule ~a + ~b*z + ~c*z^2 => (~a, ~b, ~c)\n\n2d(3 + 2z + 5z^2)","category":"page"},{"location":"manual/rewrite/","page":"Term Rewriting","title":"Term Rewriting","text":"Great! But if you try:","category":"page"},{"location":"manual/rewrite/","page":"Term Rewriting","title":"Term Rewriting","text":"c2d(3 + 2z + z^2)","category":"page"},{"location":"manual/rewrite/","page":"Term Rewriting","title":"Term Rewriting","text":"the rule is not applied. This is because in the input polynomial there isn't a multiplication in front of the z^2. For this you can use defslot variables, with syntax ~!a:","category":"page"},{"location":"manual/rewrite/","page":"Term Rewriting","title":"Term Rewriting","text":"c2d = @rule ~!a + ~!b*z + ~!c*z^2 => (~a, ~b, ~c)\n\n2d(3 + 2z + z^2)","category":"page"},{"location":"manual/rewrite/","page":"Term Rewriting","title":"Term Rewriting","text":"They work like normal slot variables, but if they are not present they take a default value depending on the operation they are in, in the above example ~b = 1. Currently defslot variables can be defined in:","category":"page"},{"location":"manual/rewrite/","page":"Term Rewriting","title":"Term Rewriting","text":"Operation Default value\nmultiplication * 1\naddition + 0\n2nd argument of ^ 1","category":"page"},{"location":"manual/rewrite/","page":"Term Rewriting","title":"Term Rewriting","text":"If you want to match a variable number of subexpressions at once, you will need a segment variable. ~~xs in the following example is a segment variable:","category":"page"},{"location":"manual/rewrite/","page":"Term Rewriting","title":"Term Rewriting","text":"@syms x y z\n@rule(+(~~xs) => ~~xs)(x + y + z)","category":"page"},{"location":"manual/rewrite/","page":"Term Rewriting","title":"Term Rewriting","text":"~~xs is a vector of subexpressions matched. You can use it to construct something more useful:","category":"page"},{"location":"manual/rewrite/","page":"Term Rewriting","title":"Term Rewriting","text":"r3 = @rule ~x * +(~~ys) => sum(map(y-> ~x * y, ~~ys));\n\nr3(2 * (w+w+α+β))","category":"page"},{"location":"manual/rewrite/","page":"Term Rewriting","title":"Term Rewriting","text":"Notice that the expression was autosimplified before application of the rule.","category":"page"},{"location":"manual/rewrite/","page":"Term Rewriting","title":"Term Rewriting","text":"2 * (w+w+α+β)","category":"page"},{"location":"manual/rewrite/","page":"Term Rewriting","title":"Term Rewriting","text":"Note that writing a single tilde ~ as consequent, will make the rule return a dictionary of [slot variable, expression matched].","category":"page"},{"location":"manual/rewrite/","page":"Term Rewriting","title":"Term Rewriting","text":"r = @rule (~x + (~y)^(~m)) => ~\n\nr(z+w^α)","category":"page"},{"location":"manual/rewrite/#Predicates-for-matching","page":"Term Rewriting","title":"Predicates for matching","text":"","category":"section"},{"location":"manual/rewrite/","page":"Term Rewriting","title":"Term Rewriting","text":"Matcher pattern may contain slot variables with attached predicates, written as ~x::f where f is a function that takes a matched expression and returns a boolean value. Such a slot will be considered a match only if f returns true.","category":"page"},{"location":"manual/rewrite/","page":"Term Rewriting","title":"Term Rewriting","text":"Similarly ~~x::g is a way of attaching a predicate g to a segment variable. In the case of segment variables g gets a vector of 0 or more expressions and must return a boolean value. If the same slot or segment variable appears twice in the matcher pattern, then at most one of the occurrence should have a predicate.","category":"page"},{"location":"manual/rewrite/","page":"Term Rewriting","title":"Term Rewriting","text":"For example,","category":"page"},{"location":"manual/rewrite/","page":"Term Rewriting","title":"Term Rewriting","text":"using SymbolicUtils\n@syms a b c d\n\nr = @rule ~x + ~~y::(ys->iseven(length(ys))) => \"odd terms\";\n\n@show r(a + b + c + d)\n@show r(b + c + d)\n@show r(b + c + b)\n@show r(a + b)","category":"page"},{"location":"manual/rewrite/#Associative-Commutative-Rules","page":"Term Rewriting","title":"Associative-Commutative Rules","text":"","category":"section"},{"location":"manual/rewrite/","page":"Term Rewriting","title":"Term Rewriting","text":"Given an expression f(x, f(y, z, u), v, w), a f is said to be associative if the expression is equivalent to f(x, y, z, u, v, w) and commutative if the order of arguments does not matter.  SymbolicUtils has a special @acrule macro meant for rules on functions which are associate and commutative such as addition and multiplication of real and complex numbers.","category":"page"},{"location":"manual/rewrite/","page":"Term Rewriting","title":"Term Rewriting","text":"using SymbolicUtils\n@syms x y z\n\nacr = @acrule((~a)^(~x) * (~a)^(~y) => (~a)^(~x + ~y))\n\nacr(x^y * x^z)","category":"page"},{"location":"manual/rewrite/","page":"Term Rewriting","title":"Term Rewriting","text":"although in case of Number it also works the same way with regular @rule since autosimplification orders and applies associativity and commutativity to the expression.","category":"page"},{"location":"manual/rewrite/#Example-of-applying-the-rules-to-simplify-expression","page":"Term Rewriting","title":"Example of applying the rules to simplify expression","text":"","category":"section"},{"location":"manual/rewrite/","page":"Term Rewriting","title":"Term Rewriting","text":"Consider expression (cos(x) + sin(x))^2 that we would like simplify by applying some trigonometric rules. First, we need rule to expand square of cos(x) + sin(x). First we try the simplest rule to expand square of the sum and try it on simple expression","category":"page"},{"location":"manual/rewrite/","page":"Term Rewriting","title":"Term Rewriting","text":"using SymbolicUtils\n\n@syms x::Real y::Real\n\nsqexpand = @rule (~x + ~y)^2 => (~x)^2 + (~y)^2 + 2 * ~x * ~y\n\nsqexpand((cos(x) + sin(x))^2)","category":"page"},{"location":"manual/rewrite/","page":"Term Rewriting","title":"Term Rewriting","text":"It works. This can be further simplified using Pythagorean identity and check it","category":"page"},{"location":"manual/rewrite/","page":"Term Rewriting","title":"Term Rewriting","text":"pyid = @rule sin(~x)^2 + cos(~x)^2 => 1\n\npyid(sin(x)^2 + 2sin(x)*cos(x) + cos(x)^2)===nothing","category":"page"},{"location":"manual/rewrite/","page":"Term Rewriting","title":"Term Rewriting","text":"Why does it return nothing? If we look at the expression, we see that we have an additional addend + 2sin(x)*cos(x). Therefore, in order to work, the rule needs to be associative-commutative.","category":"page"},{"location":"manual/rewrite/","page":"Term Rewriting","title":"Term Rewriting","text":"acpyid = @acrule sin(~x)^2 + cos(~x)^2 => 1\n\nacpyid(cos(x)^2 + sin(x)^2 + 2cos(x)*sin(x))","category":"page"},{"location":"manual/rewrite/","page":"Term Rewriting","title":"Term Rewriting","text":"It has been some work. Fortunately rules may be chained together into more sophisticated rewriters to avoid manual application of the rules.","category":"page"},{"location":"manual/rewrite/#Composing-rewriters","page":"Term Rewriting","title":"Composing rewriters","text":"","category":"section"},{"location":"manual/rewrite/","page":"Term Rewriting","title":"Term Rewriting","text":"A rewriter is any callable object which takes an expression and returns an expression or nothing. If nothing is returned that means there was no changes applicable to the input expression. The Rules we created above are rewriters.","category":"page"},{"location":"manual/rewrite/","page":"Term Rewriting","title":"Term Rewriting","text":"The SymbolicUtils.Rewriters module contains some types which create and transform rewriters.","category":"page"},{"location":"manual/rewrite/","page":"Term Rewriting","title":"Term Rewriting","text":"Empty() is a rewriter which always returns nothing\nChain(itr) chain an iterator of rewriters into a single rewriter which applies  each chained rewriter in the given order.  If a rewriter returns nothing this is treated as a no-change.\nRestartedChain(itr) like Chain(itr) but restarts from the first rewriter once on the  first successful application of one of the chained rewriters.\nIfElse(cond, rw1, rw2) runs the cond function on the input, applies rw1 if cond  returns true, rw2 if it returns false\nIf(cond, rw) is the same as IfElse(cond, rw, Empty())\nPrewalk(rw; threaded=false, thread_cutoff=100) returns a rewriter which does a pre-order   (from top to bottom and from left to right) traversal of a given expression and applies   the rewriter rw. threaded=true will use multi threading for traversal.  Note that if rw returns nothing when a match is not found, then Prewalk(rw) will  also return nothing unless a match is found at every level of the walk. If you are  applying multiple rules, then Chain already has the appropriate passthrough behavior.  If you only want to apply one rule, then consider using PassThrough.  thread_cutoff   is the minimum number of nodes in a subtree which should be walked in a threaded spawn.\nPostwalk(rw; threaded=false, thread_cutoff=100) similarly does post-order   (from left to right and from bottom to top) traversal.\nFixpoint(rw) returns a rewriter which applies rw repeatedly until there are no changes to be made.\nPassThrough(rw) returns a rewriter which if rw(x) returns nothing will instead  return x otherwise will return rw(x).","category":"page"},{"location":"manual/rewrite/#Chaining-rewriters","page":"Term Rewriting","title":"Chaining rewriters","text":"","category":"section"},{"location":"manual/rewrite/","page":"Term Rewriting","title":"Term Rewriting","text":"Several rules may be chained to give chain of rules. Chain is an array of rules which are subsequently applied to the expression.","category":"page"},{"location":"manual/rewrite/","page":"Term Rewriting","title":"Term Rewriting","text":"To check that, we will combine rules from previous example into a chain","category":"page"},{"location":"manual/rewrite/","page":"Term Rewriting","title":"Term Rewriting","text":"using SymbolicUtils\nusing SymbolicUtils.Rewriters\n\n@syms x\n\nsqexpand = @rule (~x + ~y)^2 => (~x)^2 + (~y)^2 + 2 * ~x * ~y\nacpyid = @acrule sin(~x)^2 + cos(~x)^2 => 1\n\ncsa = Chain([sqexpand, acpyid])\n\ncsa((cos(x) + sin(x))^2)","category":"page"},{"location":"manual/rewrite/","page":"Term Rewriting","title":"Term Rewriting","text":"Important feature of Chain is that it returns the expression instead of nothing if it doesn't change the expression","category":"page"},{"location":"manual/rewrite/","page":"Term Rewriting","title":"Term Rewriting","text":"Chain([@acrule sin(~x)^2 + cos(~x)^2 => 1])((cos(x) + sin(x))^2)","category":"page"},{"location":"manual/rewrite/","page":"Term Rewriting","title":"Term Rewriting","text":"it's important to notice, that chain is ordered, so if rules are in different order it wouldn't work the same as in earlier example","category":"page"},{"location":"manual/rewrite/","page":"Term Rewriting","title":"Term Rewriting","text":"cas = Chain([acpyid, sqexpand])\n\ncas((cos(x) + sin(x))^2)","category":"page"},{"location":"manual/rewrite/","page":"Term Rewriting","title":"Term Rewriting","text":"since Pythagorean identity is applied before square expansion, so it is unable to match squares of sine and cosine.","category":"page"},{"location":"manual/rewrite/","page":"Term Rewriting","title":"Term Rewriting","text":"One way to circumvent the problem of order of applying rules in chain is to use RestartedChain","category":"page"},{"location":"manual/rewrite/","page":"Term Rewriting","title":"Term Rewriting","text":"using SymbolicUtils.Rewriters: RestartedChain\n\nrcas = RestartedChain([acpyid, sqexpand])\n\nrcas((cos(x) + sin(x))^2)","category":"page"},{"location":"manual/rewrite/","page":"Term Rewriting","title":"Term Rewriting","text":"It restarts the chain after each successful application of a rule, so after sqexpand is hit it (re)starts again and successfully applies acpyid to resulting expression.","category":"page"},{"location":"manual/rewrite/","page":"Term Rewriting","title":"Term Rewriting","text":"You can also use Fixpoint to apply the rules until there are no changes.","category":"page"},{"location":"manual/rewrite/","page":"Term Rewriting","title":"Term Rewriting","text":"Fixpoint(cas)((cos(x) + sin(x))^2)","category":"page"},{"location":"upgrade/#Upgrade-to-SymbolicUtils-v1","page":"Upgrade to SymbolicUtils v1","title":"Upgrade to SymbolicUtils v1","text":"","category":"section"},{"location":"upgrade/","page":"Upgrade to SymbolicUtils v1","title":"Upgrade to SymbolicUtils v1","text":"The version 1 of SymbolicUtils utilizes Unityper to speed up the compilation time. We introduce a new type BasicSymbolic <: Symbolic to represent all the previous types Sym, Term, Add, Mul, Pow and Div. Since BasicSymbolic is a concrete type, checking x isa Sym or x isa Pow no longer works. Instead, one should use issym(x) or ispow(x) to check the \"type\" of the expression. Also, note that if one does not need to work on a specific symbolic representation, issym(x) and isterm(x) should be replaced by x isa Symbolic && !istree(x) and istree(x) to be more generic. Furthermore, dispatching on Sym, Term, etc no longer works. Instead, a function that takes BasicSymbolic should check the type of the expression using a if statement to select the right code path.","category":"page"},{"location":"upgrade/","page":"Upgrade to SymbolicUtils v1","title":"Upgrade to SymbolicUtils v1","text":"Although we don't have Sym, Term, etc in the Julia type system anymore, we still provide convenient constructors for them. For example, Sym{Real}(:x) would still work. For constructor that takes a collection like Terms, we recommend directly construct Any element type constructors like Term(f, Any[x1, x2]) to reduce extra memory allocation and compile time.","category":"page"},{"location":"manual/variants/#Variant-structure-and-types","page":"Variant structure and types","title":"Variant structure and types","text":"","category":"section"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"This document aims to describe the structure of the Algebraic Data Type (ADT) used to represent a symbolic tree, along with several utility types to allow robustly interacting with it.","category":"page"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"SymbolicUtils uses Moshi.jl's ADT structure. The ADT is named BasicSymbolicImpl, and an alias BSImpl is available for convenience. The actual type of a variable is BSImpl.Type, aliased as BasicSymbolic. A BasicSymbolic is considered immutable. Mutating its fields is unsafe behavior.","category":"page"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"In SymbolicUtils v3, the type T in BasicSymbolic{T} was the type represented by the symbolic variable. In other words, T was the SymbolicUtils.symtype of the variable.","category":"page"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"In SymbolicUtils v4, the symtype is not stored in the type, and is instead a field of the struct. This allows for greatly increased type-stability. The type T in BasicSymbolic{T} now represents a tag known as thw vartype. This flag determines the assumptions made about the symbolic algebra. It can take one of three values:","category":"page"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"SymReal: The default behavior.\nSafeReal: Idential to SymReal, but common factors in the numerator and denominator of a division are not cancelled.\nTreeReal: Assumes nothing about the algebra, and always uses the Term variant to represent an expression.","category":"page"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"A given expression must be pure in its vartype. In other words, no operation supports operands of different vartypes.","category":"page"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"warning: A short note on (im-)mutability\n","category":"page"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"While ismutabletype(BasicSymbolic) returns true, symbolic types are IMMUTABLE.   Any mutation is undefined behavior and can lead to very confusing and hard-to-debug issues.   This includes internal mutation, such as mutating AddMul.dict. The arrays returned from   TermInterface.arguments and TermInterface.sorted_arguments are read-only arrays for this   reason.","category":"page"},{"location":"manual/variants/#Expression-symtypes","page":"Variant structure and types","title":"Expression symtypes","text":"","category":"section"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"The \"symtype\" of a symbolic variable/expression is the Julia type that the variable/expression represents. It can be queried with SymbolicUtils.symtype. Note that this query is unstable - the returned type cannot be inferred.","category":"page"},{"location":"manual/variants/#Expression-shapes","page":"Variant structure and types","title":"Expression shapes","text":"","category":"section"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"In SymbolicUtils v4, arrays are first-class citizens. This is implemented by storing the shape of the symbolic. The shape can be queried using SymbolicUtils.shape and is one of two types.","category":"page"},{"location":"manual/variants/#Symbolics-with-known-shape","page":"Variant structure and types","title":"Symbolics with known shape","text":"","category":"section"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"The most common case is when the shape of a symbolic variable is known. For example:","category":"page"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"@syms x[1:2] y[-3:6, 4:7] z","category":"page"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"All of the variables created above have known shape. In this case, SymbolicUtils.shape returns a (custom) vector of UnitRange{Int} semantically equivalent to Base.axes. This does not return a Tuple since the number of dimensions cannot be inferred and thus returning a tuple would introduce type-instability. All array operations will perform validation on the shapes of their inputs (e.g. matrix multiplication) and calculates the shape of their outputs.","category":"page"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"Scalar variables return an empty vector as their shape.","category":"page"},{"location":"manual/variants/#Symbolics-with-known-ndims","page":"Variant structure and types","title":"Symbolics with known ndims","text":"","category":"section"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"The next most common case is when the exact shape/size of the symbolic is unknown but the number of dimensions is known. For example:","category":"page"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"@syms x::Vector{Number} y::Matrix{Number} z::Array{Number, 3}","category":"page"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"In this case, SymbolicUtils.shape returns a value of type SymbolicUtils.Unknown. This has a single field ndims::Int storing the number of dimensions of the symbolic. Note that a shape of SymbolicUtils.Unknown(0) does not represent a scalar. All array operations will perform as much validation as possible on their arguments. The shape of the result will be calculated on a best-effort basis.","category":"page"},{"location":"manual/variants/#Symbolics-with-unknown-ndims","page":"Variant structure and types","title":"Symbolics with unknown ndims","text":"","category":"section"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"In this case, nothing is known about the symbolic except that it is an array. For example:","category":"page"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"@syms x::Array{Number}","category":"page"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"Symbolics.shape(x) will return SymbolicUtils.Unknown(-1). This effectively disables most shape checking for array operations.","category":"page"},{"location":"manual/variants/#Variants","page":"Variant structure and types","title":"Variants","text":"","category":"section"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"struct Const\n    const val::Any\n    # ...\nend","category":"page"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"Any non-symbolic values in an expression are stored in a Const variant. This is crucial for type-stability, but it does mean that obtaining the value out of a Const is unstable and should be avoided. This value can be obtained by pattern matching using Moshi.Match.@match or using the unwrap_const utility. unwrap_const will act as an identity function for any input that is not Const, including non-symbolic inputs. Const is the only variant which does not have metadata.","category":"page"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"SymbolicUtils.isconst can be used to check if a BasicSymbolic is the Const variant. This variant can be constructed using Const{T}(val) or BSImpl.Const{T}(val), where T is the appropriate vartype.","category":"page"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"The Const constructors have an additional special behavior. If given an array of symbolics (or array of array of ... symbolics), it will return a Term (see below) with SymbolicUtils.array_literal as the operation. This allows standard symbolic operations (such as substitute) to work on arrays of symbolics without excessive special-case handling and improved type-stability.","category":"page"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"struct Sym\n    const name::Symbol\n    const metadata::MetadataT\n    const shape::ShapeT\n    const type::TypeT\n    # ...\nend","category":"page"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"Sym represents a symbolic quantity with a given name. This and Const are the two atomic variants. metadata is the symbolic metadata associated with this variable. type is the tag for the type of quantity represented here. shape stores the shape if the variable is an array symbolic.","category":"page"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"metadata is either nothing or a map from DataType keys to arbitrary values. Any","category":"page"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"interaction with metadata should be done by providing such a mapping during construction or using getmetadata, setmetadata, hasmetadata.","category":"page"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"type is a Julia type.\nshape is as described above.","category":"page"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"These three fields are present in all subsequent variants as well.","category":"page"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"A Sym can be constructed using Sym{T}(name::Symbol; type, shape, metadata) or BSImpl.Sym{T}(name::Symbol; type, shape, metadata).","category":"page"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"struct Term\n    const f::Any\n    const args::SmallV{BasicSymbolicImpl.Type{T}}\n    const metadata::MetadataT\n    const shape::ShapeT\n    const type::TypeT\n    # ...\nend","category":"page"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"Term is the generic expression form for an operation f applied to the arguments in args. In other words, this represents f(args...). Any constant (non-symbolic) arguments (including arrays of symbolics) are converted to symbolics and wrapped in Const.","category":"page"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"A Term can be constructed using Term{T}(f, args; type, shape, metadata) or BSImpl.Term{T}(f, args; type, shape, metadata).","category":"page"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"struct AddMul\n    const coeff::Any\n    const dict::ACDict{T}\n    const variant::AddMulVariant.T\n    const metadata::MetadataT\n    const shape::ShapeT\n    const type::TypeT\n    # ...\nend","category":"page"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"AddMul is a specialized representation for associative-commutative addition and multiplication. The two operations are distinguised using the AddMulVariant EnumX.jl enum. It has two variants: AddMulVariant.ADD and AddMulVariant.MUL.","category":"page"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"For multiplication terms, coeff is a constant non-symbolic coefficient multipled with the expression. dict is a map from terms being multiplied to their exponents. For example, 2x^2 * (y + z)^3 is represented with coeff = 2 and dict = ACDict{T}(x => 2, (y + z) => 3). A valid multiplication term is subject to the following constraints:","category":"page"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"coeff must be non-symbolic.\nThe values of dict must be non-symbolic.\nThe keys of dict must not be expressions with ^ as the operation UNLESS the exponent is symbolic. For example, x^x * y^2 is represented with dict = ACDict{T}((x^x) => 1, y => 2).\ndict must not be empty.\ncoeff must not be zero.\nIf dict has only one element, coeff must not be one. Such a case should be represented as a power term (with ^ as the operation).\nIf dict has only one element where the key is an addition, coeff must not be negative one. Such a case should be represented by distributing the negation.","category":"page"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"The Mul{T}(coeff, dict; type, shape, metadata) constructor validates these constraints and automatically returns the appropriate alternative form where applicable. It should be preferred. BSImpl.AddMul{T}(coeff, dict, variant; type, shape, metadata) is faster but does not validate the constraints and should be used with caution. Incorrect usage can and will lead to both invalid expressions and undefined behavior.","category":"page"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"For addition terms, coeff is a constant non-symbolic coefficient added to the expression. dict is a map from terms being added to the constant non-symbolic coefficients they are multiplied by. For example, to represent 1 + 2x + 3y * z coeff would be 1 and dict would be Dict(x => 2, (y * z) => 3). A valid addition term is subject to the following constraints:","category":"page"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"coeff must be non-symbolic.\nThe values of dict must be non-symbolic.\nThe keys of dict must not be additions expressions represented with AddMul.\ndict must not be empty.\nIf dict has only one element, coeff must not be zero. Such a case should be represented using the appropriate multiplication form.","category":"page"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"The Add{T}(coeff, dict; type, shape, metadata) constructor validates these constraints and automatically returns the appropriate alternative form where applicable. It should be preferred. BSImpl.AddMul{T}(coeff, dict, variant; type, shape, metadata) is faster but does not validate the constraints and should be used with caution. Incorrect usage can and will lead to both invalid expressions and undefined behavior.","category":"page"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"struct Div\n    const num::BasicSymbolicImpl.Type{T}\n    const den::BasicSymbolicImpl.Type{T}\n    const simplified::Bool\n    const metadata::MetadataT\n    const shape::ShapeT\n    const type::TypeT\n    # ...\nend","category":"page"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"The Div variant represents division (where the operation is /). num is the numerator and den is the denominator expression. simplified is a boolean indicating whether this expression is in the most simplified form possible. If it is true, certain algorithms in simplify_fractions will not inspect this term. In almost all cases, it should be provided as false. A valid division term is subject to the following constraints:","category":"page"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"Both the numerator and denominator cannot be Const variants. This should instead be represented as a Const variant wrapping the result of division.\nThe numerator cannot be zero. This should instead be represented as a Const wrapping the appropriate zero.\nThe denominator cannot be one. This should instead be represented as the numerator, possibly wrapped in a Const.\nThe denominator cannot be zero. This should instead be represented as a Const with some form of infinity.\nThe denominator cannot be negative one. This should instead be represented as the negation of the numerator.\nNon-symbolic coefficients should be propagated to the numerator if it is a constant or multiplication term.","category":"page"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"The Div{T}(num, den, simplified; type, shape, metadata) constructor can be used to build this form. If T is SymReal, the constructor will use quick_cancel to cancel trivially identifiable common factors in the numerator and denominator. It will also perform validation of the above constraints and return the appropriate alternative form where applicable. Some of the constraints can be relaxed for non-scalar algebras. The BSImpl.Div{T}(num, den, simplified; type, shape, metadata) does not perform such validation or transformation.","category":"page"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"struct ArrayOp\n    const output_idx::SmallV{Union{Int, BasicSymbolicImpl.Type{T}}}\n    const expr::BasicSymbolicImpl.Type{T}\n    const reduce::Any\n    const term::Union{BasicSymbolicImpl.Type{T}, Nothing}\n    const ranges::Dict{BasicSymbolicImpl.Type{T}, StepRange{Int, Int}}\n    const metadata::MetadataT\n    const shape::ShapeT\n    const type::TypeT\nend","category":"page"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"ArrayOp is used to represent vectorized operations. This variant should not be created manually. Instead, the @arrayop macro constructs this using a generalized Einstein-summation notation, similar to that of Tullio.jl. Consider the following example:","category":"page"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"ex = @arrayop (i, j) A[i, k] * B[k, j] + C[i, j]","category":"page"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"This represents A * B + C for matrices A, B, C as a vectorized array operation. Some operations, such as broadcasts, are automatically represented as such a form internally. The following description of the fields assumes familiarity with the @arrayop macro.","category":"page"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"When processing this macro, the indices i, j, k are converted to use a common global index variable to avoid potential name conflicts with other symbolic variables named i, j, k if ex is used in a larger expression. The output_idx field stores [i, j]. expr stores the expression A[i, k] * B[k, j] + C[i, j], with i, j, k replaced by the common global index variable. reduce is the operation used to reduce indices not present in output_idx (in this example, k). By default, it is +. term stores an expression that represents an equivalent computation to use for printing/code-generation. For example, here A * B + C would be a valid value for term. By default, term is nothing except when the expression is generated via broadcast or a similar operation. ranges is a dictionary mapping indices used in expr (converted to the common global index) to the range of indices over which they should iterate, in case such a range is explicitly provided.","category":"page"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"note: Note\n","category":"page"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"The common global index variable is printed as _1, _2, ... in arrayops. It is not   a valid symbolic variable outside of an ArrayOp's expr.","category":"page"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"A valid ArrayOp satisfies the following conditions:","category":"page"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"output_idx only contains the integer 1 or variants of the common global index variable.\nAny top-level indexing operations in expr use common global indices. A top-level indexing operation is a term whose operation is getindex, and which is not a descendant of any other term whose operation is getindex.\nreduce must be a valid reduction operation that can be passed to Base.reduce.\nIf term is not nothing, it must be an expression with shape shape and type type.\nThe keys of ranges must be variants of the common global index variable, and must be present in expr.","category":"page"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"The @arrayop macro should be heavily preferred for creating ArrayOps. In case this is not possible (such as in recursive functions like substitute) the ArrayOp constructor should be preferred. This does not allow specifying the type and shape, since these values are tied to the fields of the variant and are thus determined. The BSImpl.ArrayOp constructor should be used with extreme caution, since it does not validate input.","category":"page"},{"location":"manual/variants/#Array-arithmetic","page":"Variant structure and types","title":"Array arithmetic","text":"","category":"section"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"SymbolicUtils implements a simple array algebra in addition to the default scalar algebra. Similar to how SymbolicUtils.promote_symtype given a function and symtypes of its arguments returns the symtype of the result, SymbolicUtils.promote_shape does the same for the shapes of the arguments. Implementing both methods is cruicial for correctly using custom functions in symbolic expressions. Without promote_shape, SymbolicUtils will use Unknown(-1) as the shape.","category":"page"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"The array algebra implemented aims to mimic that of base Arrays as closely as possible. For example, a symbolic adjoint(::Vector) * (::Vector) will return a symbolic scalar instead of a one-element symbolic vector. promote_shape implementations will propagate the shape information on a best-effort basis. Invalid shapes (such as attempting to multiply a 3-dimensional array) will error. Following are notable exceptions to Base-like behavior:","category":"page"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"map and mapreduce require that all input arrays have the same shape\npromote_symtype and promote_shape is not implemented for map and mapreduce, since doing so requires the function(s) passed to map and mapreduce instead of their types or shapes.\nSince ndims information is not present in the type, eachindex, iterate, size, axes, ndims, collect are type-unstable. SymbolicUtils.stable_eachindex is useful as a type-stable iteration alternative.\nifelse requires that both the true and false cases have identical shape.\nSymbolic arrays only support cartesian indexing. For example, given @syms x[1:3, 1:3] accessing x[4] is invalid and x[1, 2] should be used. Valid indices are Int, Colon, AbstractRange{Int} and symbolic expressions with integer symtype. A single CartesianIndex of appropriate dimension can also be used to symbolically index arrays.","category":"page"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"Symbolic array operations are also supported on arrays of symbolics. However, at least one of the arguments to the function must be a symbolic (instead of an array of symbolics) to allow the dispatches defined in SymbolicUtils to be targeted instead of those in Base. To aid in constructing arrays of symbolics, the BS utility is provided. Similar to the T[...] syntax for constructing an array of etype T, BS[...] will construct an array of BasicSymbolics. At least one value in the array must be a symbolic value to infer T in Array{BasicSymbolic{T}, N}. To explicitly specify the vartype, use BS{T}[...].","category":"page"},{"location":"manual/variants/#Symbolic-functions-and-dependent-variables","page":"Variant structure and types","title":"Symbolic functions and dependent variables","text":"","category":"section"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"SymbolicUtils defines FnType{A, R, T} for symbolic functions and dependent variables. Here, A is a Tuple{...} of the symtypes of arguments and R is the type returned by the symbolic function. T is the type that the function itself subtypes, or Nothing.","category":"page"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"The syntax","category":"page"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"@syms f(::T1, ::T2)::R","category":"page"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"creates f with a symtype of FnType{Tuple{T1, T2}, R, Nothing}. This is a symbolic function taking arguments of type T1 and T2, and returning R. Nothing is a sentinel indicating that the supertype of the function is unknown. By contrast,","category":"page"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"@syms f(..)::R","category":"page"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"creates f with a symtype of FnType{Tuple, R, Nothing}. SymbolicUtils considers this case to be a dependent variable with as-yet unspecified independent variables. In other words,","category":"page"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"@syms x f1(::Real)::Real f2(..)::Real","category":"page"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"Here, f1(x) is considered a symbolic function f1 called with the argument x and f2(x) is considered a dependent variable that depends on x. The utilities SymbolicUtils.is_function_symbolic, SymbolicUtils.is_function_symtype, SymbolicUtils.is_called_function_symbolic can be used to differentiate between these cases.","category":"page"},{"location":"manual/variants/#API","page":"Variant structure and types","title":"API","text":"","category":"section"},{"location":"manual/variants/#Basics","page":"Variant structure and types","title":"Basics","text":"","category":"section"},{"location":"manual/variants/#SymbolicUtils.BasicSymbolic","page":"Variant structure and types","title":"SymbolicUtils.BasicSymbolic","text":"Alias for `SymbolicUtils.BasicSymbolicImpl.Type`.\n\n\n\n\n\n","category":"type"},{"location":"manual/variants/#SymbolicUtils.@syms","page":"Variant structure and types","title":"SymbolicUtils.@syms","text":"@syms <lhs_expr>[::T1] <lhs_expr>[::T2]...\n\nFor instance:\n\n@syms foo::Real bar baz(x, y::Real)::Complex\n\nCreate one or more variables. <lhs_expr> can be just a symbol in which case it will be the name of the variable, or a function call in which case a function-like variable which has the same name as the function being called. The Sym type, or in the case of a function-like Sym, the output type of calling the function can be set using the ::T syntax.\n\nExamples:\n\n@syms foo bar::Real baz::Int will create\n\nvariable foo of symtype Number (the default), bar of symtype Real and baz of symtype Int\n\n@syms f(x) g(y::Real, x)::Int h(a::Int, f(b)) creates 1-arg f 2-arg g\n\nand 2 arg h. The second argument to h must be a one argument function-like variable. So, h(1, g) will fail and h(1, f) will work.\n\nFormal syntax\n\nFollowing is a semi-formal CFG of the syntax accepted by this macro:\n\n# any variable accepted by this macro must be a `var`.\n# `var` can represent a quantity (`value`) or a function `(fn)`.\nvar = value | fn\n# A `value` is represented as a name followed by a suffix\nvalue = name suffix\n# A `name` can be a valid Julia identifier\nname = ident |\n# Or it can be an interpolated variable, in which case `ident` is assumed to refer to\n# a variable in the current scope of type `Symbol` containing the name of this variable.\n# Note that in this case the created symbolic variable will be bound to a randomized\n# Julia identifier.\n       \"$\" ident |\n# Or it can be of the form `Foo.Bar.baz` referencing a value accessible as `Foo.Bar.baz`\n# in the current scope.\n       getproperty_literal\ngetproperty_literal = ident \".\" getproperty_literal | ident \".\" ident\n# The `suffix` can be empty (no suffix) which defaults the type to `Number`\nsuffix = \"\" |\n# or it can be a type annotation (setting the type of the prefix). The shape of the result\n# is inferred from the type as best it can be. In particular, `Array{T, N}` is inferred\n# to have shape `Unknown(N)`.\n         \"::\" type |\n# or it can be a shape annotation, which sets the shape to the one specified by `ranges`.\n# The type defaults to `Array{Number, length(ranges)}`\n         \"[\" ranges \"]\" |\n# lastly, it can be a combined shape and type annotation. Here, the type annotation\n# sets the `eltype` of the symbolic array.\n         \"[\" ranges \"]::\" type\n# `ranges` is either a single `range` or a single range followed by one or more `ranges`.\nranges = range | range \",\" ranges\n# A `range` is simply two bounds separated by a colon, as standard Julia ranges work.\n# The range must be non-empty. Each bound can be a literal integer or an identifier\n# representing an integer in the current scope.\nrange = (int | ident) \":\" (int | ident) |\n# Alternatively, a range can be a Julia expression that evaluates to a range. All identifiers\n# used in `expr` are assumed to exist in the current scope.\n        expr |\n# Alternatively, a range can be a Julia expression evaluating to an iterable of ranges,\n# followed by the splat operator.\n        expr \"...\"\n# A function is represented by a function-call syntax `fncall` followed by the `suffix`\n# above. The type and shape from `suffix` represent the type and shape of the value\n# returned by the symbolic function.\nfn = fncall suffix\n# a function call is a call `head` followed by a parenthesized list of arguments.\nfncall = head \"(\" args \")\"\n# A function call head can be a name, representing the name of the symbolic function.\nhead = ident |\n# Alternatively, it can be a parenthesized type-annotated name, where the type annotation\n# represents the intended supertype of the function. In other words, if this symbolic\n# function were to be replaced by an \"actual\" function, the type-annotation constrains the\n# type of the \"actual\" function.\n       \"(\" ident \"::\" type \")\"\n# Arguments to a function is a list of one or more arguments\nargs = arg | arg \",\" args\n# An argument can take the syntax of a variable (which means we can represent functions of\n# functions of functions of...). The type of the variable constrains the type of the\n# corresponding argument of the function. The name and shape information is discarded.\narg = var |\n# Or an argument can be an unnamed type-annotation, which constrains the type without\n# requiring a name.\n      \"::\" type |\n# Or an argument can be the identifier `..`, which is used as a stand-in for `Vararg{Any}`\n      \"..\" |\n# Or an argument can be a type-annotated `..`, representing `Vararg{type}`. Note that this\n# and the previous version of `arg` can only be the last element in `args` due to Julia's\n# `Tuple` semantics.\n      \"(..)::\" type |\n# Or an argument can be a Julia expression followed by a splat operator. This assumes the\n# expression evaluates to an iterable of symbolic variables whose `symtype` should be used\n# as the argument types. Note that `expr` may be evaluated multiple times in the macro\n# expansion.\n      expr \"...\"\n\n\n\n\n\n","category":"macro"},{"location":"manual/variants/#SymbolicUtils.symtype","page":"Variant structure and types","title":"SymbolicUtils.symtype","text":"symtype(\n    x::SymbolicUtils.BasicSymbolicImpl.var\"typeof(BasicSymbolicImpl)\"{T} where T\n) -> DataType\n\n\nReturn the Julia type that the given symbolic expression x represents. Can also be called on non-symbolic values, in which case it is equivalent to typeof.\n\n\n\n\n\n","category":"function"},{"location":"manual/variants/#SymbolicUtils.vartype","page":"Variant structure and types","title":"SymbolicUtils.vartype","text":"vartype(x)\n\ndefined at /home/runner/work/SymbolicUtils.jl/SymbolicUtils.jl/src/types.jl:331.\n\nvartype(_)\n\ndefined at /home/runner/work/SymbolicUtils.jl/SymbolicUtils.jl/src/types.jl:332.\n\nExtract the variant type of a BasicSymbolic.\n\n\n\n\n\n","category":"function"},{"location":"manual/variants/#SymbolicUtils.SymReal","page":"Variant structure and types","title":"SymbolicUtils.SymReal","text":"abstract type SymReal <: SymbolicUtils.SymVariant\n\nOne of three possible values of the vartype. This variant is the default and behaves as a typical ideal scalar algebra would be expected to.\n\n\n\n\n\n","category":"type"},{"location":"manual/variants/#SymbolicUtils.SafeReal","page":"Variant structure and types","title":"SymbolicUtils.SafeReal","text":"abstract type SafeReal <: SymbolicUtils.SymVariant\n\nOne of three possible values of the vartype. This variant is identical to SymReal except common terms in the numerator and denominator of a division are not cancelled out.\n\n\n\n\n\n","category":"type"},{"location":"manual/variants/#SymbolicUtils.TreeReal","page":"Variant structure and types","title":"SymbolicUtils.TreeReal","text":"abstract type TreeReal <: SymbolicUtils.SymVariant\n\nOne of three possible values of the vartype. This variant does not assume anything about the algebra and always uses the default tree form for expressions.\n\n\n\n\n\n","category":"type"},{"location":"manual/variants/#SymbolicUtils.shape","page":"Variant structure and types","title":"SymbolicUtils.shape","text":"shape(x)\n\nGet the shape of a value or symbolic expression. Generally equivalent to axes for non-symbolic x, but also works on non-array values.\n\n\n\n\n\n","category":"function"},{"location":"manual/variants/#SymbolicUtils.Unknown","page":"Variant structure and types","title":"SymbolicUtils.Unknown","text":"struct Unknown\n\nA struct used as the shape of symbolic expressions with unknown size.\n\nFields\n\nndims::Int64: An integer >= -1 indicating the number of dimensions of the symbolic expression of unknown size. A value of -1 indicates the number of dimensions is also unknown.\n\n\n\n\n\n","category":"type"},{"location":"manual/variants/#SymbolicUtils.AddMulVariant","page":"Variant structure and types","title":"SymbolicUtils.AddMulVariant","text":"An EnumX.jl enum used to distinguish between addition and multiplication in SymbolicUtils.BSImpl.AddMul.\n\n\n\n\n\n","category":"module"},{"location":"manual/variants/#SymbolicUtils.unwrap_const","page":"Variant structure and types","title":"SymbolicUtils.unwrap_const","text":"unwrap_const(x) -> Any\n\n\nExtract the constant value from a Const variant, or return the input unchanged.\n\nArguments\n\nx: Any value, potentially a BasicSymbolic with a Const variant\n\nReturns\n\nThe wrapped constant value if x is a Const variant of BasicSymbolic\nThe input x unchanged otherwise\n\nDetails\n\nThis function unwraps constant symbolic expressions to their underlying values. It handles all three symbolic variants (SymReal, SafeReal, TreeReal). For non-Const symbolic expressions or non-symbolic values, returns the input unchanged.\n\n\n\n\n\n","category":"function"},{"location":"manual/variants/#Inner-constructors","page":"Variant structure and types","title":"Inner constructors","text":"","category":"section"},{"location":"manual/variants/#SymbolicUtils.array_literal","page":"Variant structure and types","title":"SymbolicUtils.array_literal","text":"array_literal(sz::NTuple{N, Int64}, args...) -> Any\n\n\nUtility function used as the operation of expressions representing an array of symbolic values. See SymbolicUtils.BSImpl.Const for more details.\n\nThe first argument sz is the size of the represented array. args... is prod(sz) elements representing the elements of the array in column-major order.\n\n\n\n\n\n","category":"function"},{"location":"manual/variants/#SymbolicUtils.BasicSymbolicImpl.Const","page":"Variant structure and types","title":"SymbolicUtils.BasicSymbolicImpl.Const","text":"BSImpl.Const{T}(val) where {T}\n\nConstructor for a symbolic expression that wraps a constant value val. Also converts arrays/tuples of symbolics to symbolic expressions.\n\nArguments\n\nval: The value to wrap (can be any type including arrays and tuples)\n\nReturns\n\nBasicSymbolic{T}: A Const variant or specialized representation\n\nDetails\n\nThis is the low-level constructor for constant expressions. It handles several special cases:\n\nIf val is already a BasicSymbolic{T}, returns it unchanged\nIf val is a BasicSymbolic of a different variant type, throws an error\nIf val is an array containing symbolic elements, creates a Term with SymbolicUtils.array_literal operation\nIf val is a tuple containing symbolic elements, creates a Term with tuple operation\nOtherwise, creates a Const variant wrapping the value\n\nExtended help\n\nThe unsafe flag skips hash consing for performance in internal operations.\n\n\n\n\n\n","category":"type"},{"location":"manual/variants/#SymbolicUtils.BasicSymbolicImpl.Sym","page":"Variant structure and types","title":"SymbolicUtils.BasicSymbolicImpl.Sym","text":"BSImpl.Sym{T}(name::Symbol; metadata = nothing, type, shape = default_shape(type)) where {T}\n\nInternal constructor for symbolic variables.\n\nArguments\n\nname::Symbol: The name of the symbolic variable\nmetadata: Optional metadata dictionary (default: nothing)\ntype: The symbolic type of the variable (required keyword argument)\nshape: The shape of the variable (default: inferred from type)\n\nReturns\n\nBasicSymbolic{T}: A Sym variant representing the symbolic variable\n\nDetails\n\nThis is the low-level constructor for symbolic variables. It normalizes the metadata and shape inputs, populates default properties using ordered_override_properties, and performs hash consing. The type parameter determines the Julia type that this symbolic variable represents.\n\nExtended help\n\nThe unsafe keyword argument (default: false) can be used to skip hash consing for performance in internal operations.\n\n\n\n\n\n","category":"type"},{"location":"manual/variants/#SymbolicUtils.BasicSymbolicImpl.Term","page":"Variant structure and types","title":"SymbolicUtils.BasicSymbolicImpl.Term","text":"BSImpl.Term{T}(f, args; metadata = nothing, type, shape = default_shape(type)) where {T}\n\nInternal constructor for function application terms.\n\nArguments\n\nf: The function or operation to apply\nargs: The arguments to the function (normalized to ArgsT{T})\nmetadata: Optional metadata dictionary (default: nothing)\ntype: The result type of the function application (required keyword argument)\nshape: The shape of the result (default: inferred from type)\n\nReturns\n\nBasicSymbolic{T}: A Term variant representing the function application\n\nDetails\n\nThis is the low-level constructor for function application expressions. It represents f(args...) symbolically. The constructor normalizes metadata, shape, and arguments, populates default properties, and performs hash consing. The type parameter should be the expected return type of calling f with args.\n\nExtended help\n\nThe unsafe keyword argument (default: false) can be used to skip hash consing for performance in internal operations.\n\n\n\n\n\n","category":"type"},{"location":"manual/variants/#SymbolicUtils.BasicSymbolicImpl.AddMul","page":"Variant structure and types","title":"SymbolicUtils.BasicSymbolicImpl.AddMul","text":"BSImpl.AddMul{T}(coeff, dict, variant::AddMulVariant.T; metadata = nothing, type, shape = default_shape(type)) where {T}\n\nInternal constructor for addition and multiplication expressions.\n\nArguments\n\ncoeff: The leading coefficient (for addition) or coefficient (for multiplication)\ndict: Dictionary mapping terms to their coefficients/exponents (normalized to ACDict{T})\nvariant::AddMulVariant.T: Either AddMulVariant.ADD or AddMulVariant.MUL\nmetadata: Optional metadata dictionary (default: nothing)\ntype: The result type of the operation (required keyword argument)\nshape: The shape of the result (default: inferred from type)\n\nReturns\n\nBasicSymbolic{T}: An AddMul variant representing the sum or product\n\nDetails\n\nThis is the low-level constructor for optimized addition and multiplication expressions. For addition, represents coeff + sum(k * v for (k, v) in dict). For multiplication, represents coeff * prod(k ^ v for (k, v) in dict). The constructor normalizes all inputs and performs hash consing.\n\nExtended help\n\nThe unsafe keyword argument (default: false) can be used to skip hash consing for performance in internal operations.\n\n\n\n\n\n","category":"type"},{"location":"manual/variants/#SymbolicUtils.BasicSymbolicImpl.Div","page":"Variant structure and types","title":"SymbolicUtils.BasicSymbolicImpl.Div","text":"BSImpl.Div{T}(num, den, simplified::Bool; metadata = nothing, type, shape = default_shape(type)) where {T}\n\nInternal constructor for division expressions.\n\nArguments\n\nnum: The numerator (converted to Const{T})\nden: The denominator (converted to Const{T})\nsimplified::Bool: Whether the division has been simplified\nmetadata: Optional metadata dictionary (default: nothing)\ntype: The result type of the division (required keyword argument)\nshape: The shape of the result (default: inferred from type)\n\nReturns\n\nBasicSymbolic{T}: A Div variant representing the division\n\nDetails\n\nThis is the low-level constructor for division expressions. It represents num / den symbolically. Both numerator and denominator are automatically wrapped in Const{T} if not already symbolic. The simplified flag tracks whether simplification has been attempted. The constructor normalizes all inputs and performs hash consing.\n\nExtended help\n\nThe unsafe keyword argument (default: false) can be used to skip hash consing for performance in internal operations.\n\n\n\n\n\n","category":"type"},{"location":"manual/variants/#SymbolicUtils.BasicSymbolicImpl.ArrayOp","page":"Variant structure and types","title":"SymbolicUtils.BasicSymbolicImpl.ArrayOp","text":"BSImpl.ArrayOp{T}(output_idx, expr::BasicSymbolic{T}, reduce, term, ranges = default_ranges(T); metadata = nothing, type, shape = default_shape(type)) where {T}\n\nInternal constructor for array operation expressions.\n\nArguments\n\noutput_idx: Output indices defining the result array dimensions (normalized to OutIdxT{T})\nexpr::BasicSymbolic{T}: The expression to evaluate for each index combination\nreduce: Reduction operation to apply (or nothing for direct assignment)\nterm: Optional term for accumulation (or nothing)\nranges: Dictionary mapping index variables to their ranges (default: empty)\nmetadata: Optional metadata dictionary (default: nothing)\ntype: The result type (required keyword argument, typically an array type)\nshape: The shape of the result (default: inferred from type)\n\nReturns\n\nBasicSymbolic{T}: An ArrayOp variant representing the array operation\n\nDetails\n\nThis is the low-level constructor for array comprehension-like operations. It represents operations like [expr for i in range1, j in range2] with optional reduction. The constructor normalizes all inputs, unwraps constants where appropriate, and optionally performs hash consing.\n\nThe ArrayOp constructor should be strongly preferred.\n\nExtended help\n\nThe unsafe keyword argument (default: false) can be used to skip hash consing for performance in internal operations.\n\n\n\n\n\n","category":"type"},{"location":"manual/variants/#High-level-constructors","page":"Variant structure and types","title":"High-level constructors","text":"","category":"section"},{"location":"manual/variants/#SymbolicUtils.Const","page":"Variant structure and types","title":"SymbolicUtils.Const","text":"Const{T}(val) where {T}\n\nAlias for BSImpl.Const{T}.\n\n\n\n\n\n","category":"type"},{"location":"manual/variants/#SymbolicUtils.Sym","page":"Variant structure and types","title":"SymbolicUtils.Sym","text":"Sym{T}(name; kw...) where {T}\n\nAlias for BSImpl.Sym{T}.\n\n\n\n\n\n","category":"type"},{"location":"manual/variants/#SymbolicUtils.Term","page":"Variant structure and types","title":"SymbolicUtils.Term","text":"Term{T}(f, args; type = _promote_symtype(f, args), kw...) where {T}\n\nAlias for BSImpl.Term{T} except it also unwraps args.\n\n\n\n\n\n","category":"type"},{"location":"manual/variants/#SymbolicUtils.Add","page":"Variant structure and types","title":"SymbolicUtils.Add","text":"Add{T}(coeff, dict; kw...) where {T}\n\nHigh-level constructor for addition expressions.\n\nArguments\n\ncoeff: The constant term (additive offset)\ndict: Dictionary mapping terms to their coefficients\nkw...: Additional keyword arguments (e.g., type, shape, metadata, unsafe)\n\nReturns\n\nBasicSymbolic{T}: An optimized representation of coeff + sum(k * v for (k, v) in dict)\n\nDetails\n\nThis constructor maintains invariants required by the AddMul variant. This should be preferred over the BSImpl.AddMul{T} constructor.\n\n\n\n\n\n","category":"type"},{"location":"manual/variants/#SymbolicUtils.Mul","page":"Variant structure and types","title":"SymbolicUtils.Mul","text":"Mul{T}(coeff, dict; kw...) where {T}\n\nHigh-level constructor for multiplication expressions.\n\nArguments\n\ncoeff: The multiplicative coefficient\ndict: Dictionary mapping base terms to their exponents\nkw...: Additional keyword arguments (e.g., type, shape, metadata, unsafe)\n\nReturns\n\nBasicSymbolic{T}: An optimized representation of coeff * prod(k ^ v for (k, v) in dict)\n\nDetails\n\nThis constructor maintains invariants required by the AddMul variant. This should be preferred over the BSImpl.AddMul{T} constructor.\n\n\n\n\n\n","category":"type"},{"location":"manual/variants/#SymbolicUtils.Div","page":"Variant structure and types","title":"SymbolicUtils.Div","text":"Div{T}(n, d, simplified; type = promote_symtype(/, symtype(n), symtype(d)), kw...) where {T}\n\nHigh-level constructor for division expressions with simplification.\n\nArguments\n\nn: The numerator\nd: The denominator\nsimplified::Bool: Whether simplification has been attempted\ntype: The result type (default: inferred using promote_symtype)\nkw...: Additional keyword arguments (e.g., shape, metadata, unsafe)\n\nReturns\n\nBasicSymbolic{T}: An optimized representation of n / d\n\nDetails\n\nThis constructor creates symbolic division expressions with extensive simplification:\n\nZero numerator returns zero\nUnit denominator returns the numerator\nZero denominator returns Const{T}(1 // 0) (infinity). Any infinity may be returned.\nNested divisions are flattened\nConstant divisions are evaluated\nRational coefficients are simplified\nMultiplications in numerator/denominator are handled specially\n\nFor non-SafeReal variants, automatic cancellation is attempted using quick_cancel. The simplified flag prevents infinite simplification loops.\n\n\n\n\n\n","category":"type"},{"location":"manual/variants/#SymbolicUtils.ArrayOp","page":"Variant structure and types","title":"SymbolicUtils.ArrayOp","text":"ArrayOp{T}(output_idx, expr, reduce, term, ranges; metadata = nothing) where {T}\n\nHigh-level constructor for array operation expressions.\n\nArguments\n\noutput_idx: Output indices defining result dimensions\nexpr: Expression to evaluate for each index combination\nreduce: Reduction operation (or nothing)\nterm: Optional accumulation term (or nothing)\nranges: Dictionary mapping index variables to ranges\nmetadata: Optional metadata (default: nothing)\n\nReturns\n\nBasicSymbolic{T}: An ArrayOp representing the array comprehension\n\nDetails\n\nThis constructor validates and parses fields of the ArrayOp variant. It is usually never called directly. Prefer using the @arrayop macro.\n\nExtended help\n\nThe unsafe keyword argument (default: false) can be used to skip hash consing for performance in internal operations.\n\n\n\n\n\n","category":"type"},{"location":"manual/variants/#SymbolicUtils.@arrayop","page":"Variant structure and types","title":"SymbolicUtils.@arrayop","text":"@arrayop (idxs...,) expr [idx in range, ...] [options...]\n\nConstruct a vectorized array operation using Tullio.jl-like generalized Einstein notation. idxs is a tuple corresponding to the indices in the result. expr is the indexed expression. Indices used in expr not present in idxs will be collapsed using the reduce function, which defaults to +. For example, matrix multiplication can be expressed as follows:\n\n@syms A[1:5, 1:5] B[1:5, 1:5]\nmatmul = @arrayop (i, j) A[i, k] * B[k, j]\n\nHere the elements of the collapsed dimension k are reduced using the + operation. To use a different reducer, the reduce option can be supplied:\n\nC = @arrayop (i, j) A[i, k] * B[k, j] reduce=max\n\nNow, C[i, j] is the maximum value of A[i, k] * B[k, j] for across all k.\n\nSingleton dimensions\n\nArbitrary singleton dimensions can be added in the result by inserting 1 at the desired position in idxs:\n\nC = @arrayop (i, 1, j, 1) A[i, k] * B[k, j]\n\nHere, C is a symbolic array of size (5, 1, 5, 1).\n\nRestricted ranges\n\nFor any index variable i in expr, all its usages in expr must correspond to axes of identical length. For example:\n\n@syms D[1:3, 1:5]\n@arrayop (i, j) A[i, k] * D[k, j]\n\nThe above usage is invalid, since k in A is used to index an axis of length 5 and in D is used to index an axis of length 3. The iteration range of variables can be manually restricted:\n\n@arrayop (i, j) A[i, k] * D[k, j] k in 1:3\n\nThis expression is valid. Note that when manually restricting iteration ranges, the range must be a subset of the axes where the iteration variable is used. Here 1:3 is a subset of both 1:5 and 1:3.\n\nAxis offsets\n\nThe usages of index variables can be offset.\n\nA2 = @arrayop (i, j) A[i + 1, j] + A[i, j + 1]\n\nHere, A2 will have size (4, 4) since SymbolicUtils.jl is able to recognize that i and j can only iterate in the range 1:4. For trivial offsets of the form idx + offset (offset can be negative), the bounds of idx can be inferred. More complicated offsets can be used, but this requires manually specifying ranges of the involved index variables.\n\nA3 = @arrayop (i, j) A[2i - 1, j] i in 1:3\n\nIn this scenario, it is the responsibility of the user to ensure the arrays are always accessed within their bounds.\n\nUsage with non-standard axes\n\nThe index variables are \"idealized\" indices. This means that as long as the length of all axes where an index variable is used is identical, the bounds of the axes are irrelevant.\n\n@syms E[0:4, 0:4]\nF = @arrayop (i, j) A[i, k] * E[k, j]\n\nDespite axes(A, 2) being 1:5 and axes(E, 1) being 0:4, the above expression is valid since length(1:5) == 5 == length(0:4). When generating code, index variables will be appropriately offset to index the involved axes.\n\nIf the range of an index variable is manually specified, the index variable is no longer \"idealized\" and the user is responsible for offsetting appropriately. The above example with a manual range for k should be written as:\n\nF2 = @arrayop (i, j) A[i, k] * E[k - 1, j] k in 1:5\n\nResult shape\n\nThe result is always 1-indexed with axes of appropriate lengths, regardless of the shape of the inputs.\n\n\n\n\n\n","category":"macro"},{"location":"manual/variants/#Variant-checking","page":"Variant structure and types","title":"Variant checking","text":"","category":"section"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"Note that while these utilities are useful, prefer using Moshi.Match.@match to pattern match against different variant types and access their fields.","category":"page"},{"location":"manual/variants/#SymbolicUtils.isconst","page":"Variant structure and types","title":"SymbolicUtils.isconst","text":"isconst(\n    x::SymbolicUtils.BasicSymbolicImpl.var\"typeof(BasicSymbolicImpl)\"{T} where T\n) -> Bool\n\n\nCheck if a value is a Const variant of BasicSymbolic.\n\nArguments\n\nx: Value to check (for BasicSymbolic input returns true if Const, for others returns false)\n\nReturns\n\ntrue if x is a BasicSymbolic with Const variant, false otherwise\n\n\n\n\n\n","category":"function"},{"location":"manual/variants/#SymbolicUtils.issym","page":"Variant structure and types","title":"SymbolicUtils.issym","text":"issym(\n    x::SymbolicUtils.BasicSymbolicImpl.var\"typeof(BasicSymbolicImpl)\"{T} where T\n) -> Bool\n\n\nCheck if a value is a Sym variant of BasicSymbolic.\n\nArguments\n\nx: Value to check (for BasicSymbolic input returns true if Sym, for others returns false)\n\nReturns\n\ntrue if x is a BasicSymbolic with Sym variant, false otherwise\n\n\n\n\n\n","category":"function"},{"location":"manual/variants/#SymbolicUtils.isterm","page":"Variant structure and types","title":"SymbolicUtils.isterm","text":"isterm(\n    x::SymbolicUtils.BasicSymbolicImpl.var\"typeof(BasicSymbolicImpl)\"{T} where T\n) -> Bool\n\n\nCheck if a value is a Term variant of BasicSymbolic.\n\nArguments\n\nx: Value to check (for BasicSymbolic input returns true if Term, for others returns false)\n\nReturns\n\ntrue if x is a BasicSymbolic with Term variant, false otherwise\n\n\n\n\n\n","category":"function"},{"location":"manual/variants/#SymbolicUtils.isaddmul","page":"Variant structure and types","title":"SymbolicUtils.isaddmul","text":"isaddmul(\n    x::SymbolicUtils.BasicSymbolicImpl.var\"typeof(BasicSymbolicImpl)\"{T} where T\n) -> Bool\n\n\nCheck if a value is an AddMul variant of BasicSymbolic.\n\nArguments\n\nx: Value to check (for BasicSymbolic input returns true if AddMul, for others returns false)\n\nReturns\n\ntrue if x is a BasicSymbolic with AddMul variant, false otherwise\n\n\n\n\n\n","category":"function"},{"location":"manual/variants/#SymbolicUtils.isadd","page":"Variant structure and types","title":"SymbolicUtils.isadd","text":"isadd(\n    x::SymbolicUtils.BasicSymbolicImpl.var\"typeof(BasicSymbolicImpl)\"{T} where T\n) -> Bool\n\n\nCheck if a value is an addition (AddMul with ADD variant).\n\nArguments\n\nx: Value to check (for BasicSymbolic input returns true if addition, for others returns false)\n\nReturns\n\ntrue if x is an AddMul with ADD variant, false otherwise\n\n\n\n\n\n","category":"function"},{"location":"manual/variants/#SymbolicUtils.ismul","page":"Variant structure and types","title":"SymbolicUtils.ismul","text":"ismul(\n    x::SymbolicUtils.BasicSymbolicImpl.var\"typeof(BasicSymbolicImpl)\"{T} where T\n) -> Bool\n\n\nCheck if a value is a multiplication (AddMul with MUL variant).\n\nArguments\n\nx: Value to check (for BasicSymbolic input returns true if multiplication, for others returns false)\n\nReturns\n\ntrue if x is an AddMul with MUL variant, false otherwise\n\n\n\n\n\n","category":"function"},{"location":"manual/variants/#SymbolicUtils.isdiv","page":"Variant structure and types","title":"SymbolicUtils.isdiv","text":"isdiv(\n    x::SymbolicUtils.BasicSymbolicImpl.var\"typeof(BasicSymbolicImpl)\"{T} where T\n) -> Bool\n\n\nCheck if a value is a Div variant of BasicSymbolic.\n\nArguments\n\nx: Value to check (for BasicSymbolic input returns true if Div, for others returns false)\n\nReturns\n\ntrue if x is a BasicSymbolic with Div variant, false otherwise\n\n\n\n\n\n","category":"function"},{"location":"manual/variants/#SymbolicUtils.ispow","page":"Variant structure and types","title":"SymbolicUtils.ispow","text":"ispow(\n    x::SymbolicUtils.BasicSymbolicImpl.var\"typeof(BasicSymbolicImpl)\"{T} where T\n) -> Bool\n\n\nCheck if a value is a power expression (Term with ^ operation).\n\nArguments\n\nx: Value to check (for BasicSymbolic input returns true if power, for others returns false)\n\nReturns\n\ntrue if x is a Term with exponentiation operation, false otherwise\n\nDetails\n\nPower expressions are Term variants where the operation is ^ (6 uses).\n\n\n\n\n\n","category":"function"},{"location":"manual/variants/#SymbolicUtils.isarrayop","page":"Variant structure and types","title":"SymbolicUtils.isarrayop","text":"isarrayop(\n    x::SymbolicUtils.BasicSymbolicImpl.var\"typeof(BasicSymbolicImpl)\"{T} where T\n) -> Bool\n\n\nCheck if a value is an ArrayOp variant of BasicSymbolic.\n\nArguments\n\nx: Value to check (for BasicSymbolic input returns true if ArrayOp, for others returns false).\n\nReturns\n\ntrue if x is a BasicSymbolic with ArrayOp variant, false otherwise.\n\nDetails\n\nArray operations represent vectorized computations created by the @arrayop macro.\n\n\n\n\n\n","category":"function"},{"location":"manual/variants/#Using-custom-functions-in-expressions","page":"Variant structure and types","title":"Using custom functions in expressions","text":"","category":"section"},{"location":"manual/variants/#SymbolicUtils.promote_symtype","page":"Variant structure and types","title":"SymbolicUtils.promote_symtype","text":"promote_symtype(f, Ts...) -> Type{Bool}\n\n\nThe result of applying f to arguments of SymbolicUtils.symtype Ts...\n\njulia> promote_symtype(+, Real, Real)\nReal\n\njulia> promote_symtype(+, Complex, Real)\nNumber\n\njulia> @syms f(x)::Complex\n(f(::Number)::Complex,)\n\njulia> promote_symtype(f, Number)\nComplex\n\nWhen constructing expressions without an explicit symtype, promote_symtype is used to figure out the symtype of the Term.\n\nIt is recommended that all type arguments be annotated with SymbolicUtils.TypeT and one method be implemented for any combination of f and the number of arguments. For example, one method is implemented for unary - and one method for binary -. Each method has an if..elseif chain to handle possible types. Any call to promote_type should be typeasserted with ::TypeT.\n\n\n\n\n\npromote_symtype(f::FnType{X,Y}, arg_symtypes...)\n\nThe output symtype of applying variable f to arguments of symtype arg_symtypes.... if the arguments are of the wrong type then this function will error.\n\n\n\n\n\n","category":"function"},{"location":"manual/variants/#SymbolicUtils.promote_shape","page":"Variant structure and types","title":"SymbolicUtils.promote_shape","text":"promote_shape(f, shs::ShapeT...)\n\nThe shape of the result of applying f to arguments of shape shs.... It is recommended that implemented methods @nospecialize all the shape arguments.\n\n\n\n\n\n","category":"function"},{"location":"manual/variants/#Symbolic-array-utilities","page":"Variant structure and types","title":"Symbolic array utilities","text":"","category":"section"},{"location":"manual/variants/#SymbolicUtils.stable_eachindex","page":"Variant structure and types","title":"SymbolicUtils.stable_eachindex","text":"stable_eachindex(\n    x::SymbolicUtils.BasicSymbolicImpl.var\"typeof(BasicSymbolicImpl)\"{T} where T\n) -> SymbolicUtils.StableIndices\n\n\nReturns a type-stable iterator over all indices of a symbolic array x.\n\nThis function provides an efficient, allocation-friendly way to iterate over multi-dimensional symbolic arrays. Unlike Base.eachindex, which returns CartesianIndices with type parameters that may be uninferrable for symbolic arrays, stable_eachindex returns a StableIndices iterator that produces StableIndex values in a fully type-stable manner.\n\nNote that the returned iterator does not match the shape of x. In other words, collect(stable_eachindex(x)) will be a vector regardless of the shape of x.\n\nArguments\n\nx::BasicSymbolic: A symbolic array expression with a known concrete shape.\n\nReturns\n\nStableIndices: An iterator that yields StableIndex values for each position in the array.\n\nThrows\n\nThis function assumes x has a concrete shape (i.e., shape(x) is a ShapeVecT, not Unknown). If the shape is unknown, it will error.\n\nExamples\n\nusing SymbolicUtils\n\n# Create a symbolic 2×3 matrix\n@variables x[1:2, 1:3]\n\n# Iterate over all indices in a type-stable manner\nfor idx in stable_eachindex(x)\n    println(\"Index: \", idx, \" -> Value: \", x[idx])\nend\n\n# Compare with regular eachindex\nfor idx in eachindex(x)  # Returns CartesianIndices\n    println(\"Index: \", idx, \" -> Value: \", x[idx])\nend\n\nSee also\n\nStableIndices: The iterator type returned by this function\nStableIndex: The index type produced by StableIndices\nBase.eachindex: The standard Julia function for iterating over array indices\n\n\n\n\n\n","category":"function"},{"location":"manual/variants/#SymbolicUtils.StableIndices","page":"Variant structure and types","title":"SymbolicUtils.StableIndices","text":"struct StableIndices\n\nAn iterator that produces StableIndex values representing all possible multi-dimensional indices for a given shape in a type-stable, allocation-efficient manner.\n\nThis type is used to iterate over multi-dimensional index spaces where each dimension can have its own range (stored in sh). The iterator produces all combinations of indices in column-major order, similar to CartesianIndices, but with better type stability and allocation characteristics.\n\nThis is similar to CartesianIndices for symbolic arrays, but avoids type-instability due to the type parameters of CartesianIndices being uninferrable. Note that iterator iterates over multidimensional indices, but is not a multidimensional iterator. In other words, collecting this iterator will return a vector regardless of the number of dimensions it iterates over.\n\nFields\n\nsh::SymbolicUtils.SmallVec{UnitRange{Int64}, Vector{UnitRange{Int64}}}: A small vector of UnitRange{Int} values, one for each dimension, defining the range of valid indices for that dimension.\n\nExamples\n\nsh = ShapeVecT([1:2, 1:3])\nindices = StableIndices(sh)\nfor idx in indices\n    # idx is a StableIndex with values like [1,1], [1,2], [1,3], [2,1], [2,2], [2,3]\nend\n\nSee also\n\nStableIndex: The index type produced by this iterator.\nstable_eachindex: Convenience function that returns a StableIndices iterator for a symbolic array.\n\n\n\n\n\n","category":"type"},{"location":"manual/variants/#SymbolicUtils.StableIndex","page":"Variant structure and types","title":"SymbolicUtils.StableIndex","text":"struct StableIndex\n\nA wrapper around a small vector of integer indices that provides a stable, allocation-efficient representation of multi-dimensional array indices.\n\nThis type is used in conjunction with StableIndices to iterate over multi-dimensional index spaces in a type-stable manner. It implements the standard iteration and indexing interfaces.\n\nThis is effectively equivalent to CartesianIndex for symbolic arrays, but avoids type-instability due to N in CartesianIndex{N} being uninferrable.\n\nFields\n\nidxs::SymbolicUtils.SmallVec{Int64, Vector{Int64}}: A small vector storing the indices for each dimension.\n\nSee also\n\nStableIndices: An iterator that produces StableIndex values.\nstable_eachindex: Returns a StableIndices iterator for a symbolic array.\n\n\n\n\n\n","category":"type"},{"location":"manual/variants/#SymbolicUtils.BS","page":"Variant structure and types","title":"SymbolicUtils.BS","text":"BS[...]\nBS{T}[...]\n\nBS is a utility defined in SymbolicUtils for constructing arrays of symbolics. Similar to how T[...] creates an Array of eltype T, BS[...] creates an array of eltype BasicSymbolic{T}. To infer the vartype of the result, at least one of the values in ... must be a symbolic. BS{T}[...] can be used to explicitly specify the vartype.\n\n\n\n\n\n","category":"type"},{"location":"manual/variants/#Symbolic-function-utilities","page":"Variant structure and types","title":"Symbolic function utilities","text":"","category":"section"},{"location":"manual/variants/#SymbolicUtils.is_function_symbolic","page":"Variant structure and types","title":"SymbolicUtils.is_function_symbolic","text":"is_function_symbolic(\n    x::SymbolicUtils.BasicSymbolicImpl.var\"typeof(BasicSymbolicImpl)\"{T} where T\n) -> Bool\n\n\nCheck if x is a symbolic representing a function (as opposed to a dependent variable). A symbolic function either has a defined signature or the function type defined. For example, all of the below are considered symbolic functions:\n\n@syms f(::Real, ::Real) g(::Real)::Integer h(::Real)[1:2]::Integer (ff::MyCallableT)(..)\n\nHowever, the following is considered a dependent variable with unspecified independent variable:\n\n@syms x(..)\n\nSee also: SymbolicUtils.is_function_symtype.\n\n\n\n\n\n","category":"function"},{"location":"manual/variants/#SymbolicUtils.is_function_symtype","page":"Variant structure and types","title":"SymbolicUtils.is_function_symtype","text":"is_function_symtype(_::Type{T}) -> Bool\n\n\nCheck if the given symtype represents a function (as opposed to a dependent variable).\n\nSee also: SymbolicUtils.is_function_symbolic.\n\n\n\n\n\n","category":"function"},{"location":"manual/variants/#SymbolicUtils.is_called_function_symbolic","page":"Variant structure and types","title":"SymbolicUtils.is_called_function_symbolic","text":"is_called_function_symbolic(\n    x::SymbolicUtils.BasicSymbolicImpl.var\"typeof(BasicSymbolicImpl)\"{T}\n) -> Bool\n\n\nCheck if the given symbolic x is the result of calling a symbolic function (as opposed to a dependent variable).\n\nSee also: SymbolicUtils.is_function_symbolic.\n\n\n\n\n\n","category":"function"},{"location":"manual/variants/#TermInterface.jl-interface","page":"Variant structure and types","title":"TermInterface.jl interface","text":"","category":"section"},{"location":"manual/variants/#Miscellaneous-utilities","page":"Variant structure and types","title":"Miscellaneous utilities","text":"","category":"section"},{"location":"manual/variants/#SymbolicUtils.zero_of_vartype","page":"Variant structure and types","title":"SymbolicUtils.zero_of_vartype","text":"zero_of_vartype(\n    _::Type{SymReal}\n) -> SymbolicUtils.BasicSymbolicImpl.var\"typeof(BasicSymbolicImpl)\"{SymReal}\n\n\nReturn a Const representing 0 with the provided vartype.\n\n\n\n\n\n","category":"function"},{"location":"manual/variants/#SymbolicUtils.one_of_vartype","page":"Variant structure and types","title":"SymbolicUtils.one_of_vartype","text":"one_of_vartype(\n    _::Type{SymReal}\n) -> SymbolicUtils.BasicSymbolicImpl.var\"typeof(BasicSymbolicImpl)\"{SymReal}\n\n\nReturn a Const representing 1 with the provided vartype.\n\n\n\n\n\n","category":"function"},{"location":"manual/variants/#SymbolicUtils.get_mul_coefficient","page":"Variant structure and types","title":"SymbolicUtils.get_mul_coefficient","text":"get_mul_coefficient(x) -> Any\n\n\nExtract the numeric coefficient from a multiplication expression.\n\nArguments\n\nx: A symbolic expression that must be a multiplication\n\nReturns\n\nThe numeric coefficient of the multiplication\n\nDetails\n\nThis function extracts the leading numeric coefficient from a multiplication expression. For Term variants, it recursively searches for nested multiplications. For AddMul variants with MUL operation, it returns the stored coefficient. Throws an error if the input is not a multiplication expression.\n\n\n\n\n\n","category":"function"},{"location":"manual/variants/#SymbolicUtils.term","page":"Variant structure and types","title":"SymbolicUtils.term","text":"term(f, args...; vartype = SymReal, type = promote_symtype(f, symtype.(args)...), shape = promote_shape(f, SymbolicUtils.shape.(args)...))\n\nCreate a symbolic term with operation f and arguments args.\n\nArguments\n\nf: The operation or function head of the term\nargs...: The arguments to the operation\nvartype: The variant type for the term (default: SymReal)\ntype: The symbolic type of the term. If not provided, it is inferred using promote_symtype on the function and argument types.\nshape: The shape of the term. If not provided, it is inferred using promote_shape on the function and argument shapes.\n\nExamples\n\njulia> @syms x y\n(x, y)\n\njulia> term(+, x, y)\nx + y\n\njulia> term(sin, x)\nsin(x)\n\njulia> term(^, x, 2)\nx^2\n\n\n\n\n\n","category":"function"},{"location":"manual/variants/#SymbolicUtils.add_worker","page":"Variant structure and types","title":"SymbolicUtils.add_worker","text":"add_worker(_, terms)\n\ndefined at /home/runner/work/SymbolicUtils.jl/SymbolicUtils.jl/src/types.jl:3082.\n\nAdd an indexable list or tuple of terms terms with the given vartype. Applicable only for symbolic expressions with numeric or array of numeric symtype.\n\n\n\n\n\n","category":"function"},{"location":"manual/variants/#SymbolicUtils.mul_worker","page":"Variant structure and types","title":"SymbolicUtils.mul_worker","text":"mul_worker(_, terms)\n\ndefined at /home/runner/work/SymbolicUtils.jl/SymbolicUtils.jl/src/types.jl:3560.\n\nMultiply an indexable list or tuple of terms terms with the given vartype. Applicable only for symbolic expressions with numeric or array of numeric symtype.\n\n\n\n\n\n","category":"function"},{"location":"manual/variants/#Utility-types","page":"Variant structure and types","title":"Utility types","text":"","category":"section"},{"location":"manual/variants/","page":"Variant structure and types","title":"Variant structure and types","text":"SymbolicUtils exposes a plethora of type aliases to allow easily interacting with common types used internally.","category":"page"},{"location":"manual/variants/#SymbolicUtils.MetadataT","page":"Variant structure and types","title":"SymbolicUtils.MetadataT","text":"Type of metadata field for symbolics.\n\n\n\n\n\n","category":"type"},{"location":"manual/variants/#SymbolicUtils.SmallV","page":"Variant structure and types","title":"SymbolicUtils.SmallV","text":"mutable struct SmallVec{T, Array{T, 1}} <: AbstractArray{T, 1}\n\nA custom vector type which does not allocate for small numbers of elements. If the number of elements is known at compile time, it should be passed as a Tuple to the constructor.\n\n\n\n\n\n","category":"type"},{"location":"manual/variants/#SymbolicUtils.ShapeVecT","page":"Variant structure and types","title":"SymbolicUtils.ShapeVecT","text":"A small-buffer-optimized AbstractVector. Uses a Backing when the number of elements is within the size of Backing, and allocates a V when the number of elements exceed this limit.\n\n\n\n\n\n","category":"type"},{"location":"manual/variants/#SymbolicUtils.ShapeT","page":"Variant structure and types","title":"SymbolicUtils.ShapeT","text":"Type that represents the SymbolicUtils.shape of symbolics.\n\n\n\n\n\n","category":"type"},{"location":"manual/variants/#SymbolicUtils.TypeT","page":"Variant structure and types","title":"SymbolicUtils.TypeT","text":"mutable struct DataType <: Type{T}\n\nAllowed types for the SymbolicUtils.symtype of symbolics.\n\n\n\n\n\n","category":"type"},{"location":"manual/variants/#SymbolicUtils.ArgsT","page":"Variant structure and types","title":"SymbolicUtils.ArgsT","text":"The type of a mutable buffer containing symbolic arguments. Passing this to the\n[`SymbolicUtils.Term`](@ref) constructor will avoid allocating a new array.\n\n\n\n\n\n","category":"type"},{"location":"manual/variants/#SymbolicUtils.ROArgsT","page":"Variant structure and types","title":"SymbolicUtils.ROArgsT","text":"The type of a read-only buffer containing symbolic arguments. Passing this to the\n[`SymbolicUtils.Term`](@ref) constructor will avoid allocating a new array. This is\nthe type returned from [`TermInterface.arguments`](@ref).\n\n\n\n\n\n","category":"type"},{"location":"manual/variants/#SymbolicUtils.ACDict","page":"Variant structure and types","title":"SymbolicUtils.ACDict","text":"The type of the dictionary stored in [`BSImpl.AddMul`](@ref). Passing this to the\n[`SymbolicUtils.Add`](@ref) or [`SymbolicUtils.Mul`](@ref) constructors will avoid\nallocating a new dictionary.\n\n\n\n\n\n","category":"type"},{"location":"manual/variants/#SymbolicUtils.OutIdxT","page":"Variant structure and types","title":"SymbolicUtils.OutIdxT","text":"The type of the `output_idxs` field in [`BSImpl.ArrayOp`](@ref).\n\n\n\n\n\n","category":"type"},{"location":"manual/variants/#SymbolicUtils.RangesT","page":"Variant structure and types","title":"SymbolicUtils.RangesT","text":"The type of the `ranges` field in [`BSImpl.ArrayOp`](@ref).\n\n\n\n\n\n","category":"type"},{"location":"manual/codegen/#Code-generation","page":"Code generation","title":"Code generation","text":"","category":"section"},{"location":"manual/codegen/","page":"Code generation","title":"Code generation","text":"Note: this feature is experimental and the API might change frequently","category":"page"},{"location":"manual/codegen/","page":"Code generation","title":"Code generation","text":"toexpr(ex) turns any expression (ex) into the equivalent Expr which is suitable for eval. The SymbolicUtils.Code module provides some combinators which provides the ability to construct more complex expressions than just function calls. These include:","category":"page"},{"location":"manual/codegen/","page":"Code generation","title":"Code generation","text":"Let blocks\nFunctions with arguments and keyword arguments\nFunctions with arguments which are to be de-structured\nExpressions that set array elements in-place\nExpressions that create an array similar in type to a reference array (currently supports Array, StaticArrays.SArray, and LabelledArrays.SLArray)\nExpressions that create sparse arrays","category":"page"},{"location":"manual/codegen/","page":"Code generation","title":"Code generation","text":"Do using SymbolicUtils.Code to get the following bindings","category":"page"},{"location":"manual/codegen/#toexpr","page":"Code generation","title":"toexpr","text":"","category":"section"},{"location":"manual/codegen/#SymbolicUtils.Code.toexpr","page":"Code generation","title":"SymbolicUtils.Code.toexpr","text":"toexpr(ex, [st,])\n\nConvert a symbolic expression into an Expr, suitable to be passed into eval.\n\nFor example,\n\njulia> @syms a b\n(a, b)\n\njulia> toexpr(a+b)\n:((+)(a, b))\n\njulia> toexpr(a+b) |> dump\nExpr\n  head: Symbol call\n  args: Array{Any}((3,))\n    1: + (function of type typeof(+))\n    2: Symbol a\n    3: Symbol b\n\nNote that the function is an actual function object.\n\nFor more complex expressions, see other code-related combinators,\n\nNamely Assignment, Let, Func, SetArray, MakeArray, MakeSparseArray and MakeTuple.\n\nTo make your own type convertible to Expr using toexpr define toexpr(x, st) and forward the state st in internal calls to toexpr. st is state used to know when to leave something like y(t) as it is or when to make it var\"y(t)\". E.g. when y(t) is itself the argument of a function rather than y.\n\n\n\n\n\n","category":"function"},{"location":"manual/codegen/#Code-Combinators","page":"Code generation","title":"Code Combinators","text":"","category":"section"},{"location":"manual/codegen/","page":"Code generation","title":"Code generation","text":"These are all exported when you do using SymbolicUtils.Code","category":"page"},{"location":"manual/codegen/#SymbolicUtils.Code.Assignment","page":"Code generation","title":"SymbolicUtils.Code.Assignment","text":"Assignment(lhs, rhs)\n\nAn assignment expression. Shorthand lhs ← rhs (\\leftarrow)\n\n\n\n\n\n","category":"type"},{"location":"manual/codegen/#SymbolicUtils.Code.Let","page":"Code generation","title":"SymbolicUtils.Code.Let","text":"Let(assignments, body[, let_block])\n\nA Let block.\n\nassignments is a vector of Assignments\nbody is the body of the let block\nlet_block boolean (default=true) – do not create a let block if false.\n\n\n\n\n\n","category":"type"},{"location":"manual/codegen/#SymbolicUtils.Code.Func","page":"Code generation","title":"SymbolicUtils.Code.Func","text":"Func(args, kwargs, body[, pre])\n\nA function.\n\nargs is a vector of expressions\nkwargs is a vector of Assignments\nbody is the body of the function\npre a vector of expressions to be prepended to the function body,  for example, it could be [Expr(:meta, :inline), Expr(:meta, :propagate_inbounds)]  to create an @inline @propagate_inbounds function definition.\n\nSpecial features in args:\n\nargs can contain DestructuredArgs\ncall expressions\n\nFor example,\n\n\njulia> @syms a b c t f(d) x(t) y(t) z(t)\n(a, b, c, t, f(::Number)::Number, x(::Number)::Number, y(::Number)::Number, z(::Number)::Number)\n\njulia> func = Func([a,x(t), DestructuredArgs([b, y(t)]), f], # args\n                   [c ← 2, z(t) ← 42], # kwargs\n                   f((a + b + c) / x(t) + y(t) + z(t)));\n\njulia> toexpr(func)\n:(function (a, var\"x(t)\", var\"##arg#255\", f; c = 2, var\"z(t)\" = 42)\n      let b = var\"##arg#255\"[1], var\"y(t)\" = var\"##arg#255\"[2]\n          f((+)(var\"y(t)\", var\"z(t)\", (*)((+)(a, b, c), (inv)(var\"x(t)\"))))\n      end\n  end)\n\nthe second argument is a DestructuredArgs, in the Expr form, it is given a random name, and is expected to receive a vector or tuple of size 2 containing the values of b and y(t). The let block that is automatically generated \"destructures\" these arguments.\nx(t) and y(t) have been replaced with var\"x(t)\" and var\"y(t)\" symbols throughout\n\nthe generated Expr. This makes sure that we are not actually calling the expressions x(t) or y(t) but instead passing the right values in place of the whole expression.\n\nf is also a function-like symbol, same as x and y, but since the args array contains f as itself rather than as say, f(t), it does not become a var\"f(t)\". The generated function expects a function of one argument to be passed in the position of f.\n\nAn example invocation of this function is:\n\njulia> executable = eval(toexpr(func))\n#10 (generic function with 1 method)\n\njulia> executable(1, 2.0, [2,3.0], x->string(x); var\"z(t)\" = sqrt(42))\n\"11.98074069840786\"\n\n\n\n\n\n","category":"type"},{"location":"manual/codegen/#SymbolicUtils.Code.SpawnFetch","page":"Code generation","title":"SymbolicUtils.Code.SpawnFetch","text":"SpawnFetch{ParallelType}(funcs [, args], reduce)\n\nRun every expression in funcs in its own task, the expression should be a Func object and is passed to Threads.Task(f). If Func takes arguments, then the arguments must be passed in as args–a vector of vector of arguments to each function in funcs. We don't use @spawn in order to support RuntimeGeneratedFunctions which disallow closures, instead we interpolate these functions or closures as smaller RuntimeGeneratedFunctions.\n\nreduce function is used to combine the results of executing exprs. A SpawnFetch expression returns the reduced result.\n\nUse Symbolics.MultithreadedForm ParallelType from the Symbolics.jl package to get the RuntimeGeneratedFunction version SpawnFetch.\n\nParallelType can be used to define more parallelism types SymbolicUtils supports Multithreaded type. Which spawns threaded tasks.\n\n\n\n\n\n","category":"type"},{"location":"manual/codegen/#SymbolicUtils.Code.SetArray","page":"Code generation","title":"SymbolicUtils.Code.SetArray","text":"SetArray(inbounds::Bool, arr, elems[, return_arr::Bool])\n\nAn expression representing setting of elements of arr.\n\nBy default, every element of elems is copied over to arr,\n\nbut if elems contains AtIndex(i, val) objects, then arr[i] = val is performed in its place.\n\ninbounds is a boolean flag, true surrounds the resulting expression in an @inbounds.\n\nreturn_arr is a flag which controls whether the generated begin..end block returns the arr. Defaults to false, in which case the block returns nothing.\n\n\n\n\n\n","category":"type"},{"location":"manual/codegen/#SymbolicUtils.Code.MakeArray","page":"Code generation","title":"SymbolicUtils.Code.MakeArray","text":"MakeArray(elems, similarto, [output_eltype=nothing])\n\nAn expression which constructs an array.\n\nelems is the output array\nsimilarto can either be a type, or some symbol that is an array whose type needs to  be emulated. If similarto is a StaticArrays.SArray, then the output array is also  created as an SArray, similarly, an Array will result in an Array, and a  LabelledArrays.SLArray will result in a labelled static array.\noutput_eltype: if set, then forces the element type of the output array to be this.  by default, the output type is inferred automatically.\n\nYou can define:\n\n@inline function create_array(A::Type{<:MyArray},a\n                              ::Nothing, d::Val{dims}, elems...) where dims\n\n# and\n\n@inline function create_array(::Type{<:MyArray}, T, ::Val{dims}, elems...) where dims\n\nwhich creates an array of size dims using the elements elems and eltype T, to allow MakeArray to create arrays similarto MyArrays.\n\n\n\n\n\n","category":"type"},{"location":"manual/codegen/#SymbolicUtils.Code.MakeSparseArray","page":"Code generation","title":"SymbolicUtils.Code.MakeSparseArray","text":"MakeSpaseArray(array)\n\nAn expression which creates a SparseMatrixCSC or a SparseVector.\n\nThe generated expression contains the sparsity information of array,\n\nit only creates the nzval field at run time.\n\n\n\n\n\n","category":"type"},{"location":"manual/codegen/#SymbolicUtils.Code.MakeTuple","page":"Code generation","title":"SymbolicUtils.Code.MakeTuple","text":"MakeTuple(tup)\n\nMake a Tuple from a tuple of expressions.\n\n\n\n\n\n","category":"type"},{"location":"manual/codegen/#SymbolicUtils.Code.LiteralExpr","page":"Code generation","title":"SymbolicUtils.Code.LiteralExpr","text":"LiteralExpr(ex)\n\nLiterally ex, an Expr. toexpr on LiteralExpr recursively calls toexpr on any interpolated symbolic expressions.\n\n\n\n\n\n","category":"type"},{"location":"manual/codegen/#SymbolicUtils.Code.ForLoop","page":"Code generation","title":"SymbolicUtils.Code.ForLoop","text":"ForLoop(itervar, range, body)\n\nGenerate a for loop of the form\n\nfor itervar in range\n    body\nend\n\n\n\n\n\n","category":"type"},{"location":"manual/codegen/#Optimizations","page":"Code generation","title":"Optimizations","text":"","category":"section"},{"location":"manual/codegen/#Common-Subexpression-Elimination-(CSE)","page":"Code generation","title":"Common Subexpression Elimination (CSE)","text":"","category":"section"},{"location":"manual/codegen/","page":"Code generation","title":"Code generation","text":"SymbolicUtils can perform CSE on symbolic expressions, and codegen primitives composed of the above \"Code Combinators\". This ensures that common subexpressions in the expression are only computed once. Note that this assumes that all functions called within the expression are pure. SymbolicUtils can and will change the number and order of function calls.","category":"page"},{"location":"manual/codegen/#SymbolicUtils.Code.cse","page":"Code generation","title":"SymbolicUtils.Code.cse","text":"cse(expr) -> Any\n\n\nPerform common subexpression elimination on an expression.\n\nThis optimization identifies repeated subexpressions and replaces them with variables to avoid redundant computation.\n\nArguments\n\nexpr: The expression to optimize\n\nReturns\n\nAn optimized expression with common subexpressions eliminated\n\nExamples\n\njulia> expr = :(sin(x) + sin(x) * cos(y))\njulia> cse(expr)  # sin(x) is computed only once\n\n\n\n\n\n","category":"function"},{"location":"manual/codegen/#SymbolicUtils.Code.cse_inside_expr","page":"Code generation","title":"SymbolicUtils.Code.cse_inside_expr","text":"cse_inside_expr(sym, f) -> Bool\n\n\nReturn true if CSE should descend inside sym, which has operation f.\n\n\n\n\n\n","category":"function"},{"location":"manual/recursive_utils/#Recursive-utility-functions","page":"Recursive utility functions","title":"Recursive utility functions","text":"","category":"section"},{"location":"manual/recursive_utils/","page":"Recursive utility functions","title":"Recursive utility functions","text":"SymbolicUtils.jl provides several utility functions to perform common operations that require recursing over the expression tree.","category":"page"},{"location":"manual/recursive_utils/#SymbolicUtils.default_substitute_filter","page":"Recursive utility functions","title":"SymbolicUtils.default_substitute_filter","text":"default_substitute_filter(\n    ex::SymbolicUtils.BasicSymbolicImpl.var\"typeof(BasicSymbolicImpl)\"{T}\n) -> Bool\n\n\nThe default filter function used by substitute to determine whether to substitute within an expression. Returns false for expressions that are Terms with an Operator as the operation (preventing substitution within operator calls), and true otherwise.\n\nArguments\n\nex::BasicSymbolic{T}: The expression to check.\n\nReturns\n\nBool: false if the expression should not be substituted into, true otherwise.\n\n\n\n\n\n","category":"function"},{"location":"manual/recursive_utils/#SymbolicUtils.query","page":"Recursive utility functions","title":"SymbolicUtils.query","text":"query(\n    predicate,\n    expr::SymbolicUtils.BasicSymbolicImpl.var\"typeof(BasicSymbolicImpl)\"{T} where T;\n    recurse,\n    default\n) -> Any\n\n\nRecursively search an expression tree to determine if any subexpression satisfies a given predicate. This function traverses the expression tree and returns true if the predicate returns true for any node in the tree.\n\nArguments\n\npredicate::F: A function that takes an expression and returns a Bool.\nexpr::BasicSymbolic: The expression to search.\n\nKeyword Arguments\n\nrecurse::G=iscall: A function determining whether to recurse into a subexpression.\ndefault::Bool=false: The default value to return if the expression is not a call or recursion is prevented.\n\nReturns\n\nBool: true if any subexpression satisfies the predicate, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"manual/recursive_utils/#SymbolicUtils.search_variables!","page":"Recursive utility functions","title":"SymbolicUtils.search_variables!","text":"search_variables!(\n    buffer,\n    expr::SymbolicUtils.BasicSymbolicImpl.var\"typeof(BasicSymbolicImpl)\"{T} where T;\n    is_atomic,\n    recurse\n)\n\n\nFind all variables used in expr and add them to buffer. A variable is identified by the predicate is_atomic. The predicate recurse determines whether to search further inside expr if it is not a variable. Note that recurse must at least return false if iscall returns false.\n\nWrappers for BasicSymbolic should implement this function by unwrapping.\n\nSee also: default_is_atomic.\n\n\n\n\n\n","category":"function"},{"location":"manual/recursive_utils/#SymbolicUtils.default_is_atomic","page":"Recursive utility functions","title":"SymbolicUtils.default_is_atomic","text":"default_is_atomic(\n    ex::SymbolicUtils.BasicSymbolicImpl.var\"typeof(BasicSymbolicImpl)\"{T}\n) -> Bool\n\n\nThe default is_atomic predicate for search_variables!. ex is considered atomic if one of the following conditions is true:\n\nIt is a Sym and not an internal index variable for an arrayop\nIt is a Term, the operation is a BasicSymbolic and the operation represents a dependent variable according to is_function_symbolic.\nIt is a Term, the operation is getindex and the variable being indexed is atomic.\n\n\n\n\n\n","category":"function"},{"location":"manual/recursive_utils/#SymbolicUtils.scalarize","page":"Recursive utility functions","title":"SymbolicUtils.scalarize","text":"scalarize(\n    x::SymbolicUtils.BasicSymbolicImpl.var\"typeof(BasicSymbolicImpl)\"{T}\n) -> Any\nscalarize(\n    x::SymbolicUtils.BasicSymbolicImpl.var\"typeof(BasicSymbolicImpl)\"{T},\n    ::Val{toplevel}\n) -> Any\n\n\nConvert a symbolic expression with array operations into a fully scalarized form. This function expands array operations into element-wise operations, converting symbolic array expressions into arrays of scalar symbolic expressions.\n\nFor ArrayOp expressions, this function reduces eliminated indices and substitutes concrete values for output indices to generate scalar expressions for each array element.\n\nArguments\n\nx::BasicSymbolic{T}: The symbolic expression to scalarize.\n::Val{toplevel}=Val{false}(): Whether to evaluate constant expressions at the top level. When true, constant subexpressions are evaluated; when false, they are recursively scalarized.\n\nReturns\n\nThe scalarized expression. For array-shaped expressions, returns an array of scalar expressions. For scalar expressions, returns the expression unchanged or with recursively scalarized subexpressions.\n\n\n\n\n\n","category":"function"},{"location":"manual/recursive_utils/#SymbolicUtils.scalarization_function","page":"Recursive utility functions","title":"SymbolicUtils.scalarization_function","text":"scalarization_function(\n    _\n) -> typeof(SymbolicUtils._scalarize_norm)\n\n\nGiven a function f, return a function that will scalarize an expression with f as the head. The returned function is passed f, the expression with f as the head, and Val(true) or Val(false) indicating whether to recursively scalarize or not.\n\nThis function provides a dispatch mechanism for customizing scalarization behavior based on the operation type. Different operations may require different scalarization strategies (e.g., array operations, determinants, indexing operations).\n\nArguments\n\nf: The function/operation to get a scalarization function for.\n\nReturns\n\nA function that takes (f, x::BasicSymbolic{T}, ::Val{toplevel}) and returns the scalarized form of x.\n\n\n\n\n\n","category":"function"},{"location":"#SymbolicUtils.jl-—-Symbolic-programming-in-Julia","page":"SymbolicUtils.jl — Symbolic programming in Julia","title":"SymbolicUtils.jl — Symbolic programming in Julia","text":"","category":"section"},{"location":"#Features","page":"SymbolicUtils.jl — Symbolic programming in Julia","title":"Features","text":"","category":"section"},{"location":"","page":"SymbolicUtils.jl — Symbolic programming in Julia","title":"SymbolicUtils.jl — Symbolic programming in Julia","text":"Fast expressions\nA rule-based rewriting language.\nA combinator library for making rewriters.\nEfficient representation of numeric expressions\nType promotion:\nSymbols (Syms) carry type information. (read more)\nCompound expressions composed of Syms propagate type information. (read more)\nSet of extendable simplification rules.","category":"page"},{"location":"#Creating-symbolic-expressions","page":"SymbolicUtils.jl — Symbolic programming in Julia","title":"Creating symbolic expressions","text":"","category":"section"},{"location":"","page":"SymbolicUtils.jl — Symbolic programming in Julia","title":"SymbolicUtils.jl — Symbolic programming in Julia","text":"First, let's use the @syms macro to create a few symbols.","category":"page"},{"location":"","page":"SymbolicUtils.jl — Symbolic programming in Julia","title":"SymbolicUtils.jl — Symbolic programming in Julia","text":"using SymbolicUtils\n\n@syms w z α::Real β::Real\n\n(w, z, α, β) # hide\n","category":"page"},{"location":"","page":"SymbolicUtils.jl — Symbolic programming in Julia","title":"SymbolicUtils.jl — Symbolic programming in Julia","text":"Type annotations are optional when creating symbols. Here α, β behave like Real numbers. w and z behave like Number, which is the default. You can use the symtype function to find the type of a symbol.","category":"page"},{"location":"","page":"SymbolicUtils.jl — Symbolic programming in Julia","title":"SymbolicUtils.jl — Symbolic programming in Julia","text":"using SymbolicUtils: symtype\n\nsymtype(w), symtype(z),  symtype(α), symtype(β)","category":"page"},{"location":"","page":"SymbolicUtils.jl — Symbolic programming in Julia","title":"SymbolicUtils.jl — Symbolic programming in Julia","text":"Note however that they are not subtypes of these types!","category":"page"},{"location":"","page":"SymbolicUtils.jl — Symbolic programming in Julia","title":"SymbolicUtils.jl — Symbolic programming in Julia","text":"@show w isa Number\n@show α isa Real","category":"page"},{"location":"","page":"SymbolicUtils.jl — Symbolic programming in Julia","title":"SymbolicUtils.jl — Symbolic programming in Julia","text":"As their types are different:","category":"page"},{"location":"","page":"SymbolicUtils.jl — Symbolic programming in Julia","title":"SymbolicUtils.jl — Symbolic programming in Julia","text":"@show typeof(w)\n@show typeof(α)","category":"page"},{"location":"","page":"SymbolicUtils.jl — Symbolic programming in Julia","title":"SymbolicUtils.jl — Symbolic programming in Julia","text":"(see this post for why they are all not just subtypes of Number)","category":"page"},{"location":"","page":"SymbolicUtils.jl — Symbolic programming in Julia","title":"SymbolicUtils.jl — Symbolic programming in Julia","text":"You can do basic arithmetic on symbols to get symbolic expressions:","category":"page"},{"location":"","page":"SymbolicUtils.jl — Symbolic programming in Julia","title":"SymbolicUtils.jl — Symbolic programming in Julia","text":"expr1 = α*sin(w)^2 + β*cos(z)^2\nexpr2 = α*cos(z)^2 + β*sin(w)^2\n\nexpr1 + expr2","category":"page"},{"location":"","page":"SymbolicUtils.jl — Symbolic programming in Julia","title":"SymbolicUtils.jl — Symbolic programming in Julia","text":"SymbolicUtils automatically simplifies","category":"page"},{"location":"","page":"SymbolicUtils.jl — Symbolic programming in Julia","title":"SymbolicUtils.jl — Symbolic programming in Julia","text":"2w + 3w - 3z + α","category":"page"},{"location":"","page":"SymbolicUtils.jl — Symbolic programming in Julia","title":"SymbolicUtils.jl — Symbolic programming in Julia","text":"and reorders","category":"page"},{"location":"","page":"SymbolicUtils.jl — Symbolic programming in Julia","title":"SymbolicUtils.jl — Symbolic programming in Julia","text":"(z + w)*(α + β)","category":"page"},{"location":"","page":"SymbolicUtils.jl — Symbolic programming in Julia","title":"SymbolicUtils.jl — Symbolic programming in Julia","text":"expressions of type Symbolic{<:Number} (which includes Sym{Real}) when they are created. It also does constant elimination (including rational numbers)","category":"page"},{"location":"","page":"SymbolicUtils.jl — Symbolic programming in Julia","title":"SymbolicUtils.jl — Symbolic programming in Julia","text":"5 + 2w - 3z + α - (β + 5//3) + 3w - 2 + 3//2 * β","category":"page"},{"location":"","page":"SymbolicUtils.jl — Symbolic programming in Julia","title":"SymbolicUtils.jl — Symbolic programming in Julia","text":"It's worth remembering that the expression may be transformed with respect to the input when it's created.","category":"page"},{"location":"#Function-like-symbols","page":"SymbolicUtils.jl — Symbolic programming in Julia","title":"Function-like symbols","text":"","category":"section"},{"location":"","page":"SymbolicUtils.jl — Symbolic programming in Julia","title":"SymbolicUtils.jl — Symbolic programming in Julia","text":"Symbols can be defined to behave like functions. Both the input and output types for the function can be specified. Any application to that function will only admit either values of those types or symbols of the same symtype.","category":"page"},{"location":"","page":"SymbolicUtils.jl — Symbolic programming in Julia","title":"SymbolicUtils.jl — Symbolic programming in Julia","text":"using SymbolicUtils\n@syms f(x) g(x::Real, y::Real)::Real\n\nf(z) + g(1, α) + sin(w)","category":"page"},{"location":"","page":"SymbolicUtils.jl — Symbolic programming in Julia","title":"SymbolicUtils.jl — Symbolic programming in Julia","text":"This does not work since z is a Number, not a Real.","category":"page"},{"location":"","page":"SymbolicUtils.jl — Symbolic programming in Julia","title":"SymbolicUtils.jl — Symbolic programming in Julia","text":"g(1, z)","category":"page"},{"location":"","page":"SymbolicUtils.jl — Symbolic programming in Julia","title":"SymbolicUtils.jl — Symbolic programming in Julia","text":"This works because g \"returns\" a Real.","category":"page"},{"location":"","page":"SymbolicUtils.jl — Symbolic programming in Julia","title":"SymbolicUtils.jl — Symbolic programming in Julia","text":"g(2//5, g(1, β))","category":"page"},{"location":"#Expression-interface","page":"SymbolicUtils.jl — Symbolic programming in Julia","title":"Expression interface","text":"","category":"section"},{"location":"","page":"SymbolicUtils.jl — Symbolic programming in Julia","title":"SymbolicUtils.jl — Symbolic programming in Julia","text":"Symbolic expressions are of type Term{T}, Add{T}, Mul{T}, Pow{T} or Div{T} and denote some function call where one or more arguments are themselves such expressions or Syms. See more about the representation here.","category":"page"},{"location":"","page":"SymbolicUtils.jl — Symbolic programming in Julia","title":"SymbolicUtils.jl — Symbolic programming in Julia","text":"All the expression types support the TermInterface.jl interface. Please refer to the package for the complete reference of the interface.","category":"page"},{"location":"#Term-rewriting","page":"SymbolicUtils.jl — Symbolic programming in Julia","title":"Term rewriting","text":"","category":"section"},{"location":"","page":"SymbolicUtils.jl — Symbolic programming in Julia","title":"SymbolicUtils.jl — Symbolic programming in Julia","text":"SymbolicUtils contains a rule-based rewriting language for easy pattern matching and rewriting of expression. There is also a combinator library to combine rules to chain, branch and loop over rules.","category":"page"},{"location":"#Simplification","page":"SymbolicUtils.jl — Symbolic programming in Julia","title":"Simplification","text":"","category":"section"},{"location":"","page":"SymbolicUtils.jl — Symbolic programming in Julia","title":"SymbolicUtils.jl — Symbolic programming in Julia","text":"By default +, * and ^ operations apply the most basic simplification upon construction of the expression.","category":"page"},{"location":"","page":"SymbolicUtils.jl — Symbolic programming in Julia","title":"SymbolicUtils.jl — Symbolic programming in Julia","text":"The rules with which the canonical form of Symbolic{<:Number} terms are constructed are the next (where x isa Symbolic and c isa Number)","category":"page"},{"location":"","page":"SymbolicUtils.jl — Symbolic programming in Julia","title":"SymbolicUtils.jl — Symbolic programming in Julia","text":"0 + x, 1 * x and x^1 always gives x\n0 * x always gives 0 and x ^ 0 gives 1\n-x becomes (-1)*x\ncommutativity and associativity over + and * are assumed. Re-ordering of terms will be done under a total order\np/q * x or x * p/q results in (p*x)/q\np/q * x/y results in (p*x)/(q*y)\nx + ... + x will be fused into n*x with type Mul\nx * ... * x will be fused into x^n with type Pow\nsum of Add's are fused\nproduct of Mul's are fused\nc * (c₁x₁ + ... + cₙxₙ) will be converted into c*c₁*x₁ + ... + c*cₙ*xₙ\n(x₁^c₁ * ... * xₙ^cₙ)^c will be converted into x₁^(c*c₁) * ... * xₙ^(c*cₙ)\nthere are come other simplifications on construction that you can check here","category":"page"},{"location":"","page":"SymbolicUtils.jl — Symbolic programming in Julia","title":"SymbolicUtils.jl — Symbolic programming in Julia","text":"Here is an example of this","category":"page"},{"location":"","page":"SymbolicUtils.jl — Symbolic programming in Julia","title":"SymbolicUtils.jl — Symbolic programming in Julia","text":"2 * (w+w+α+β + sin(z)^2 + cos(z)^2 - 1)","category":"page"},{"location":"","page":"SymbolicUtils.jl — Symbolic programming in Julia","title":"SymbolicUtils.jl — Symbolic programming in Julia","text":"The simplify function applies a built-in set of rules to rewrite expressions in order to simplify it.","category":"page"},{"location":"","page":"SymbolicUtils.jl — Symbolic programming in Julia","title":"SymbolicUtils.jl — Symbolic programming in Julia","text":"simplify(2 * (w+w+α+β + sin(z)^2 + cos(z)^2 - 1))","category":"page"},{"location":"","page":"SymbolicUtils.jl — Symbolic programming in Julia","title":"SymbolicUtils.jl — Symbolic programming in Julia","text":"The rules in the default simplify applies simple constant elimination and trigonometric identities.","category":"page"},{"location":"","page":"SymbolicUtils.jl — Symbolic programming in Julia","title":"SymbolicUtils.jl — Symbolic programming in Julia","text":"If you read the previous section on the rules DSL, you should be able to read and understand the rules that are used by simplify.","category":"page"},{"location":"#Code-generation","page":"SymbolicUtils.jl — Symbolic programming in Julia","title":"Code generation","text":"","category":"section"},{"location":"","page":"SymbolicUtils.jl — Symbolic programming in Julia","title":"SymbolicUtils.jl — Symbolic programming in Julia","text":"Experimental feature","category":"page"},{"location":"","page":"SymbolicUtils.jl — Symbolic programming in Julia","title":"SymbolicUtils.jl — Symbolic programming in Julia","text":"It is common to want to generate executable code from symbolic expressions and blocks of them. We are working on experimental support for turning Symbolic expressions into executable functions with specific focus on array input and output and performance which is critical to the Differential Equations ecosystem which is making heavy use of this package.","category":"page"},{"location":"","page":"SymbolicUtils.jl — Symbolic programming in Julia","title":"SymbolicUtils.jl — Symbolic programming in Julia","text":"See Code generation for more about this.","category":"page"},{"location":"#Learn-more","page":"SymbolicUtils.jl — Symbolic programming in Julia","title":"Learn more","text":"","category":"section"},{"location":"","page":"SymbolicUtils.jl — Symbolic programming in Julia","title":"SymbolicUtils.jl — Symbolic programming in Julia","text":"If you have a package that you would like to utilize rule-based rewriting in, look at the suggestions in the Interfacing section to find out how you can do that without any fundamental changes to your package. Look at the API documentation for docstrings about specific functions or macros.","category":"page"},{"location":"","page":"SymbolicUtils.jl — Symbolic programming in Julia","title":"SymbolicUtils.jl — Symbolic programming in Julia","text":"Head over to the github repository to ask questions and report problems! Join the Zulip stream to chat!","category":"page"},{"location":"manual/interface/#Interfacing-with-SymbolicUtils.jl","page":"Interfacing with SymbolicUtils.jl","title":"Interfacing with SymbolicUtils.jl","text":"","category":"section"},{"location":"manual/interface/","page":"Interfacing with SymbolicUtils.jl","title":"Interfacing with SymbolicUtils.jl","text":"This section is for Julia package developers who may want to use the simplify and rule rewriting system on their own expression types.","category":"page"},{"location":"manual/interface/#Defining-the-interface","page":"Interfacing with SymbolicUtils.jl","title":"Defining the interface","text":"","category":"section"},{"location":"manual/interface/","page":"Interfacing with SymbolicUtils.jl","title":"Interfacing with SymbolicUtils.jl","text":"SymbolicUtils matchers can match any Julia object that implements an interface to traverse it as a tree. The interface in question, is defined in the TermInterface.jl package. Its purpose is to provide a shared interface between various symbolic programming Julia packages. ","category":"page"},{"location":"manual/interface/","page":"Interfacing with SymbolicUtils.jl","title":"Interfacing with SymbolicUtils.jl","text":"In particular, you should define methods from TermInterface.jl for an expression tree type T with symbol types S to  work with SymbolicUtils.jl","category":"page"},{"location":"manual/interface/","page":"Interfacing with SymbolicUtils.jl","title":"Interfacing with SymbolicUtils.jl","text":"You can read the documentation of TermInterface.jl on the Github repository.","category":"page"}]
}
