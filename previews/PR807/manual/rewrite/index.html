<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Term Rewriting · SymbolicUtils.jl</title><meta name="title" content="Term Rewriting · SymbolicUtils.jl"/><meta property="og:title" content="Term Rewriting · SymbolicUtils.jl"/><meta property="twitter:title" content="Term Rewriting · SymbolicUtils.jl"/><meta name="description" content="Documentation for SymbolicUtils.jl."/><meta property="og:description" content="Documentation for SymbolicUtils.jl."/><meta property="twitter:description" content="Documentation for SymbolicUtils.jl."/><meta property="og:url" content="https://docs.sciml.ai/SymbolicUtils/stable/manual/rewrite/"/><meta property="twitter:url" content="https://docs.sciml.ai/SymbolicUtils/stable/manual/rewrite/"/><link rel="canonical" href="https://docs.sciml.ai/SymbolicUtils/stable/manual/rewrite/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">SymbolicUtils.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">SymbolicUtils.jl — Symbolic programming in Julia</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../variants/">Variant structure and types</a></li><li class="is-active"><a class="tocitem" href>Term Rewriting</a><ul class="internal"><li><a class="tocitem" href="#Rule-based-rewriting"><span>Rule-based rewriting</span></a></li><li><a class="tocitem" href="#Composing-rewriters"><span>Composing rewriters</span></a></li></ul></li><li><a class="tocitem" href="../interface/">Interfacing with SymbolicUtils.jl</a></li><li><a class="tocitem" href="../codegen/">Code generation</a></li><li><a class="tocitem" href="../caching/">Caching recursive functions</a></li><li><a class="tocitem" href="../recursive_utils/">Recursive utility functions</a></li></ul></li><li><a class="tocitem" href="../../api/">API Reference</a></li><li><a class="tocitem" href="../../upgrade/">Upgrade to SymbolicUtils v1</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Term Rewriting</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Term Rewriting</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/master/docs/src/manual/rewrite.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Term-Rewriting"><a class="docs-heading-anchor" href="#Term-Rewriting">Term Rewriting</a><a id="Term-Rewriting-1"></a><a class="docs-heading-anchor-permalink" href="#Term-Rewriting" title="Permalink"></a></h1><h2 id="Rule-based-rewriting"><a class="docs-heading-anchor" href="#Rule-based-rewriting">Rule-based rewriting</a><a id="Rule-based-rewriting-1"></a><a class="docs-heading-anchor-permalink" href="#Rule-based-rewriting" title="Permalink"></a></h2><p>Rewrite rules match and transform an expression. A rule is written using either the <code>@rule</code> macro or the <code>@acrule</code> macro. It creates a callable <code>Rule</code> object.</p><h3 id="Basics-of-rule-based-term-rewriting-in-SymbolicUtils"><a class="docs-heading-anchor" href="#Basics-of-rule-based-term-rewriting-in-SymbolicUtils">Basics of rule-based term rewriting in SymbolicUtils</a><a id="Basics-of-rule-based-term-rewriting-in-SymbolicUtils-1"></a><a class="docs-heading-anchor-permalink" href="#Basics-of-rule-based-term-rewriting-in-SymbolicUtils" title="Permalink"></a></h3><p>Here is a simple rewrite rule, that uses formula for the double angle of the sine function:</p><pre><code class="language-julia hljs">using SymbolicUtils

@syms w z α::Real β::Real d(..)


r1 = @rule sin(2(~x)) =&gt; 2sin(~x)*cos(~x)

r1(sin(2z))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr34">2</span>sin(z)*cos(z)</code></pre><p>The <code>@rule</code> macro takes a pair of patterns – the <em>matcher</em> and the <em>consequent</em> (<code>@rule matcher =&gt; consequent</code>). If an expression matches the matcher pattern, it is rewritten to the consequent pattern. <code>@rule</code> returns a callable object that applies the rule to an expression.</p><p><code>~x</code> in the example is what is a <strong>slot variable</strong> named <code>x</code>. In a matcher pattern, slot variables are placeholders that match exactly one expression. When used on the consequent side, they stand in for the matched expression. If a slot variable appears twice in a matcher pattern, all corresponding matches must be equal (as tested by <code>Base.isequal</code> function).</p><p>If you try to apply this rule to an expression with triple angle, it will return <code>nothing</code> – this is the way a rule signifies failure to match.</p><pre><code class="language-julia hljs">r1(sin(3z))</code></pre><p>Slot variable (matcher) is not necessary a single variable:</p><pre><code class="language-julia hljs">r1(sin(2*(w-z)))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr34">2</span>sin(w - z)*cos(w - z)</code></pre><p>And can also match a function:</p><pre><code class="language-julia hljs">r = @rule (~f)(z+1) =&gt; ~f

r(sin(z+1))</code></pre><p>Rules are of course not limited to single slot variable</p><pre><code class="language-julia hljs">r2 = @rule sin(~x + ~y) =&gt; sin(~x)*cos(~y) + cos(~x)*sin(~y);

r2(sin(α+β))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">sin(β)*cos(α) + cos(β)*sin(α)</code></pre><p>Now let&#39;s say you want to catch the coefficients of a second degree polynomial in z. You can do that with:</p><pre><code class="language-julia hljs">c2d = @rule ~a + ~b*z + ~c*z^2 =&gt; (~a, ~b, ~c)

2d(3 + 2z + 5z^2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr34">2</span>d(<span class="sgr34">3</span> + <span class="sgr34">2</span>z + <span class="sgr34">5</span>(z^2))</code></pre><p>Great! But if you try:</p><pre><code class="language-julia hljs">c2d(3 + 2z + z^2)</code></pre><p>the rule is not applied. This is because in the input polynomial there isn&#39;t a multiplication in front of the <code>z^2</code>. For this you can use <strong>defslot variables</strong>, with syntax <code>~!a</code>:</p><pre><code class="language-julia hljs">c2d = @rule ~!a + ~!b*z + ~!c*z^2 =&gt; (~a, ~b, ~c)

2d(3 + 2z + z^2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr34">2</span>d(<span class="sgr34">3</span> + <span class="sgr34">2</span>z + z^2)</code></pre><p>They work like normal slot variables, but if they are not present they take a default value depending on the operation they are in, in the above example <code>~b = 1</code>. Currently defslot variables can be defined in:</p><table><tr><th style="text-align: right">Operation</th><th style="text-align: right">Default value</th></tr><tr><td style="text-align: right">multiplication <code>*</code></td><td style="text-align: right">1</td></tr><tr><td style="text-align: right">addition <code>+</code></td><td style="text-align: right">0</td></tr><tr><td style="text-align: right">2nd argument of <code>^</code></td><td style="text-align: right">1</td></tr></table><p>If you want to match a variable number of subexpressions at once, you will need a <strong>segment variable</strong>. <code>~~xs</code> in the following example is a segment variable:</p><pre><code class="language-julia hljs">@syms x y z
@rule(+(~~xs) =&gt; ~~xs)(x + y + z)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element view(::ReadOnlyArrays.ReadOnlyVector{SymbolicUtils.BasicSymbolicImpl.var&quot;typeof(BasicSymbolicImpl)&quot;{SymReal}, SymbolicUtils.SmallVec{SymbolicUtils.BasicSymbolicImpl.var&quot;typeof(BasicSymbolicImpl)&quot;{SymReal}, Vector{SymbolicUtils.BasicSymbolicImpl.var&quot;typeof(BasicSymbolicImpl)&quot;{SymReal}}}}, 1:3) with eltype SymbolicUtils.BasicSymbolicImpl.var&quot;typeof(BasicSymbolicImpl)&quot;{SymReal}:
 x
 y
 z</code></pre><p><code>~~xs</code> is a vector of subexpressions matched. You can use it to construct something more useful:</p><pre><code class="language-julia hljs">r3 = @rule ~x * +(~~ys) =&gt; sum(map(y-&gt; ~x * y, ~~ys));

r3(2 * (w+w+α+β))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr34">4</span>w + <span class="sgr34">2</span>α + <span class="sgr34">2</span>β</code></pre><p>Notice that the expression was autosimplified before application of the rule.</p><pre><code class="language-julia hljs">2 * (w+w+α+β)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr34">2</span>(<span class="sgr34">2</span>w + α + β)</code></pre><p>Note that writing a single tilde <code>~</code> as consequent, will make the rule return a dictionary of [slot variable, expression matched].</p><pre><code class="language-julia hljs">r = @rule (~x + (~y)^(~m)) =&gt; ~

r(z+w^α)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Base.ImmutableDict{Symbol, Any} with 5 entries:
  :MATCH =&gt; z + w^α
  :m     =&gt; α
  :y     =&gt; w
  :x     =&gt; z
  :____  =&gt; nothing</code></pre><h3 id="Predicates-for-matching"><a class="docs-heading-anchor" href="#Predicates-for-matching">Predicates for matching</a><a id="Predicates-for-matching-1"></a><a class="docs-heading-anchor-permalink" href="#Predicates-for-matching" title="Permalink"></a></h3><p>Matcher pattern may contain slot variables with attached predicates, written as <code>~x::f</code> where <code>f</code> is a function that takes a matched expression and returns a boolean value. Such a slot will be considered a match only if <code>f</code> returns true.</p><p>Similarly <code>~~x::g</code> is a way of attaching a predicate <code>g</code> to a segment variable. In the case of segment variables <code>g</code> gets a vector of 0 or more expressions and must return a boolean value. If the same slot or segment variable appears twice in the matcher pattern, then at most one of the occurrence should have a predicate.</p><p>For example,</p><pre><code class="language-julia hljs">using SymbolicUtils
@syms a b c d

r = @rule ~x + ~~y::(ys-&gt;iseven(length(ys))) =&gt; &quot;odd terms&quot;;

@show r(a + b + c + d)
@show r(b + c + d)
@show r(b + c + b)
@show r(a + b)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">r(a + b + c + d) = nothing
r(b + c + d) = &quot;odd terms&quot;
r(b + c + b) = nothing
r(a + b) = nothing</code></pre><h3 id="Associative-Commutative-Rules"><a class="docs-heading-anchor" href="#Associative-Commutative-Rules">Associative-Commutative Rules</a><a id="Associative-Commutative-Rules-1"></a><a class="docs-heading-anchor-permalink" href="#Associative-Commutative-Rules" title="Permalink"></a></h3><p>Given an expression <code>f(x, f(y, z, u), v, w)</code>, a <code>f</code> is said to be associative if the expression is equivalent to <code>f(x, y, z, u, v, w)</code> and commutative if the order of arguments does not matter.  SymbolicUtils has a special <code>@acrule</code> macro meant for rules on functions which are associate and commutative such as addition and multiplication of real and complex numbers.</p><pre><code class="language-julia hljs">using SymbolicUtils
@syms x y z

acr = @acrule((~a)^(~x) * (~a)^(~y) =&gt; (~a)^(~x + ~y))

acr(x^y * x^z)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">x^(y + z)</code></pre><p>although in case of <code>Number</code> it also works the same way with regular <code>@rule</code> since autosimplification orders and applies associativity and commutativity to the expression.</p><h3 id="Example-of-applying-the-rules-to-simplify-expression"><a class="docs-heading-anchor" href="#Example-of-applying-the-rules-to-simplify-expression">Example of applying the rules to simplify expression</a><a id="Example-of-applying-the-rules-to-simplify-expression-1"></a><a class="docs-heading-anchor-permalink" href="#Example-of-applying-the-rules-to-simplify-expression" title="Permalink"></a></h3><p>Consider expression <code>(cos(x) + sin(x))^2</code> that we would like simplify by applying some trigonometric rules. First, we need rule to expand square of <code>cos(x) + sin(x)</code>. First we try the simplest rule to expand square of the sum and try it on simple expression</p><pre><code class="language-julia hljs">using SymbolicUtils

@syms x::Real y::Real

sqexpand = @rule (~x + ~y)^2 =&gt; (~x)^2 + (~y)^2 + 2 * ~x * ~y

sqexpand((cos(x) + sin(x))^2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">sin(x)^2 + <span class="sgr34">2</span>sin(x)*cos(x) + cos(x)^2</code></pre><p>It works. This can be further simplified using Pythagorean identity and check it</p><pre><code class="language-julia hljs">pyid = @rule sin(~x)^2 + cos(~x)^2 =&gt; 1

pyid(sin(x)^2 + 2sin(x)*cos(x) + cos(x)^2)===nothing</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>Why does it return <code>nothing</code>? If we look at the expression, we see that we have an additional addend <code>+ 2sin(x)*cos(x)</code>. Therefore, in order to work, the rule needs to be associative-commutative.</p><pre><code class="language-julia hljs">acpyid = @acrule sin(~x)^2 + cos(~x)^2 =&gt; 1

acpyid(cos(x)^2 + sin(x)^2 + 2cos(x)*sin(x))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr34">1</span> + <span class="sgr34">2</span>sin(x)*cos(x)</code></pre><p>It has been some work. Fortunately rules may be <a href="#chaining rewriters">chained together</a> into more sophisticated rewriters to avoid manual application of the rules.</p><h2 id="Composing-rewriters"><a class="docs-heading-anchor" href="#Composing-rewriters">Composing rewriters</a><a id="Composing-rewriters-1"></a><a class="docs-heading-anchor-permalink" href="#Composing-rewriters" title="Permalink"></a></h2><p>A rewriter is any callable object which takes an expression and returns an expression or <code>nothing</code>. If <code>nothing</code> is returned that means there was no changes applicable to the input expression. The Rules we created above are rewriters.</p><p>The <code>SymbolicUtils.Rewriters</code> module contains some types which create and transform rewriters.</p><ul><li><code>Empty()</code> is a rewriter which always returns <code>nothing</code></li><li><code>Chain(itr)</code> chain an iterator of rewriters into a single rewriter which applies  each chained rewriter in the given order.  If a rewriter returns <code>nothing</code> this is treated as a no-change.</li><li><code>RestartedChain(itr)</code> like <code>Chain(itr)</code> but restarts from the first rewriter once on the  first successful application of one of the chained rewriters.</li><li><code>IfElse(cond, rw1, rw2)</code> runs the <code>cond</code> function on the input, applies <code>rw1</code> if cond  returns true, <code>rw2</code> if it returns false</li><li><code>If(cond, rw)</code> is the same as <code>IfElse(cond, rw, Empty())</code></li><li><code>Prewalk(rw; threaded=false, thread_cutoff=100)</code> returns a rewriter which does a pre-order   (<em>from top to bottom and from left to right</em>) traversal of a given expression and applies   the rewriter <code>rw</code>. <code>threaded=true</code> will use multi threading for traversal.  Note that if <code>rw</code> returns <code>nothing</code> when a match is not found, then <code>Prewalk(rw)</code> will  also return nothing unless a match is found at every level of the walk. If you are  applying multiple rules, then <code>Chain</code> already has the appropriate passthrough behavior.  If you only want to apply one rule, then consider using <code>PassThrough</code>.  <code>thread_cutoff</code>   is the minimum number of nodes in a subtree which should be walked in a threaded spawn.</li><li><code>Postwalk(rw; threaded=false, thread_cutoff=100)</code> similarly does post-order   (<em>from left to right and from bottom to top</em>) traversal.</li><li><code>Fixpoint(rw)</code> returns a rewriter which applies <code>rw</code> repeatedly until there are no changes to be made.</li><li><code>PassThrough(rw)</code> returns a rewriter which if <code>rw(x)</code> returns <code>nothing</code> will instead  return <code>x</code> otherwise will return <code>rw(x)</code>.</li></ul><h3 id="Chaining-rewriters"><a class="docs-heading-anchor" href="#Chaining-rewriters">Chaining rewriters</a><a id="Chaining-rewriters-1"></a><a class="docs-heading-anchor-permalink" href="#Chaining-rewriters" title="Permalink"></a></h3><p>Several rules may be chained to give chain of rules. Chain is an array of rules which are subsequently applied to the expression.</p><p>To check that, we will combine rules from <a href="#example of applying the rules to simplify expression">previous example</a> into a chain</p><pre><code class="language-julia hljs">using SymbolicUtils
using SymbolicUtils.Rewriters

@syms x

sqexpand = @rule (~x + ~y)^2 =&gt; (~x)^2 + (~y)^2 + 2 * ~x * ~y
acpyid = @acrule sin(~x)^2 + cos(~x)^2 =&gt; 1

csa = Chain([sqexpand, acpyid])

csa((cos(x) + sin(x))^2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr34">1</span> + <span class="sgr34">2</span>sin(x)*cos(x)</code></pre><p>Important feature of <code>Chain</code> is that it returns the expression instead of <code>nothing</code> if it doesn&#39;t change the expression</p><pre><code class="language-julia hljs">Chain([@acrule sin(~x)^2 + cos(~x)^2 =&gt; 1])((cos(x) + sin(x))^2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(sin(x) + cos(x))^2</code></pre><p>it&#39;s important to notice, that chain is ordered, so if rules are in different order it wouldn&#39;t work the same as in earlier example</p><pre><code class="language-julia hljs">cas = Chain([acpyid, sqexpand])

cas((cos(x) + sin(x))^2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">sin(x)^2 + <span class="sgr34">2</span>sin(x)*cos(x) + cos(x)^2</code></pre><p>since Pythagorean identity is applied before square expansion, so it is unable to match squares of sine and cosine.</p><p>One way to circumvent the problem of order of applying rules in chain is to use <code>RestartedChain</code></p><pre><code class="language-julia hljs">using SymbolicUtils.Rewriters: RestartedChain

rcas = RestartedChain([acpyid, sqexpand])

rcas((cos(x) + sin(x))^2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr34">1</span> + <span class="sgr34">2</span>sin(x)*cos(x)</code></pre><p>It restarts the chain after each successful application of a rule, so after <code>sqexpand</code> is hit it (re)starts again and successfully applies <code>acpyid</code> to resulting expression.</p><p>You can also use <code>Fixpoint</code> to apply the rules until there are no changes.</p><pre><code class="language-julia hljs">Fixpoint(cas)((cos(x) + sin(x))^2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr34">1</span> + <span class="sgr34">2</span>sin(x)*cos(x)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../variants/">« Variant structure and types</a><a class="docs-footer-nextpage" href="../interface/">Interfacing with SymbolicUtils.jl »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.15.0 on <span class="colophon-date" title="Friday 31 October 2025 16:36">Friday 31 October 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
