<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Variant structure and types · SymbolicUtils.jl</title><meta name="title" content="Variant structure and types · SymbolicUtils.jl"/><meta property="og:title" content="Variant structure and types · SymbolicUtils.jl"/><meta property="twitter:title" content="Variant structure and types · SymbolicUtils.jl"/><meta name="description" content="Documentation for SymbolicUtils.jl."/><meta property="og:description" content="Documentation for SymbolicUtils.jl."/><meta property="twitter:description" content="Documentation for SymbolicUtils.jl."/><meta property="og:url" content="https://docs.sciml.ai/SymbolicUtils/stable/manual/variants/"/><meta property="twitter:url" content="https://docs.sciml.ai/SymbolicUtils/stable/manual/variants/"/><link rel="canonical" href="https://docs.sciml.ai/SymbolicUtils/stable/manual/variants/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">SymbolicUtils.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">SymbolicUtils.jl — Symbolic programming in Julia</a></li><li><span class="tocitem">Manual</span><ul><li class="is-active"><a class="tocitem" href>Variant structure and types</a><ul class="internal"><li><a class="tocitem" href="#Expression-symtypes"><span>Expression symtypes</span></a></li><li><a class="tocitem" href="#Expression-shapes"><span>Expression shapes</span></a></li><li><a class="tocitem" href="#Variants"><span>Variants</span></a></li><li><a class="tocitem" href="#Array-arithmetic"><span>Array arithmetic</span></a></li><li><a class="tocitem" href="#Symbolic-functions-and-dependent-variables"><span>Symbolic functions and dependent variables</span></a></li><li><a class="tocitem" href="#API"><span>API</span></a></li></ul></li><li><a class="tocitem" href="../rewrite/">Term Rewriting</a></li><li><a class="tocitem" href="../interface/">Interfacing with SymbolicUtils.jl</a></li><li><a class="tocitem" href="../codegen/">Code generation</a></li><li><a class="tocitem" href="../caching/">Caching recursive functions</a></li><li><a class="tocitem" href="../recursive_utils/">Recursive utility functions</a></li></ul></li><li><a class="tocitem" href="../../api/">API Reference</a></li><li><a class="tocitem" href="../../upgrade/">Upgrade to SymbolicUtils v1</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Variant structure and types</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Variant structure and types</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/master/docs/src/manual/variants.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Variant-structure-and-types"><a class="docs-heading-anchor" href="#Variant-structure-and-types">Variant structure and types</a><a id="Variant-structure-and-types-1"></a><a class="docs-heading-anchor-permalink" href="#Variant-structure-and-types" title="Permalink"></a></h1><p>This document aims to describe the structure of the Algebraic Data Type (ADT) used to represent a symbolic tree, along with several utility types to allow robustly interacting with it.</p><p>SymbolicUtils uses Moshi.jl&#39;s ADT structure. The ADT is named <code>BasicSymbolicImpl</code>, and an alias <code>BSImpl</code> is available for convenience. The actual type of a variable is <code>BSImpl.Type</code>, aliased as <code>BasicSymbolic</code>. A <code>BasicSymbolic</code> is considered immutable. Mutating its fields is unsafe behavior.</p><p>In SymbolicUtils v3, the type <code>T</code> in <code>BasicSymbolic{T}</code> was the type represented by the symbolic variable. In other words, <code>T</code> was the <a href="#SymbolicUtils.symtype"><code>SymbolicUtils.symtype</code></a> of the variable.</p><p>In SymbolicUtils v4, the <code>symtype</code> is not stored in the type, and is instead a field of the struct. This allows for greatly increased type-stability. The type <code>T</code> in <code>BasicSymbolic{T}</code> now represents a tag known as thw <a href="#SymbolicUtils.vartype"><code>vartype</code></a>. This flag determines the assumptions made about the symbolic algebra. It can take one of three values:</p><ul><li><a href="#SymbolicUtils.SymReal"><code>SymReal</code></a>: The default behavior.</li><li><a href="#SymbolicUtils.SafeReal"><code>SafeReal</code></a>: Idential to <code>SymReal</code>, but common factors in the numerator and denominator of a division are not cancelled.</li><li><a href="#SymbolicUtils.TreeReal"><code>TreeReal</code></a>: Assumes nothing about the algebra, and always uses the <code>Term</code> variant to represent an expression.</li></ul><p>A given expression must be pure in its <code>vartype</code>. In other words, no operation supports operands of different <code>vartype</code>s.</p><div class="admonition is-warning" id="A-short-note-on-(im-)mutability-ba895d93a18f772c"><header class="admonition-header">A short note on (im-)mutability<a class="admonition-anchor" href="#A-short-note-on-(im-)mutability-ba895d93a18f772c" title="Permalink"></a></header><div class="admonition-body"></div></div><p>While <code>ismutabletype(BasicSymbolic)</code> returns <code>true</code>, symbolic types are IMMUTABLE.   Any mutation is undefined behavior and can lead to very confusing and hard-to-debug issues.   This includes internal mutation, such as mutating <code>AddMul.dict</code>. The arrays returned from   <code>TermInterface.arguments</code> and <code>TermInterface.sorted_arguments</code> are read-only arrays for this   reason.</p><h2 id="Expression-symtypes"><a class="docs-heading-anchor" href="#Expression-symtypes">Expression symtypes</a><a id="Expression-symtypes-1"></a><a class="docs-heading-anchor-permalink" href="#Expression-symtypes" title="Permalink"></a></h2><p>The &quot;symtype&quot; of a symbolic variable/expression is the Julia type that the variable/expression represents. It can be queried with <a href="#SymbolicUtils.symtype"><code>SymbolicUtils.symtype</code></a>. Note that this query is unstable - the returned type cannot be inferred.</p><h2 id="Expression-shapes"><a class="docs-heading-anchor" href="#Expression-shapes">Expression shapes</a><a id="Expression-shapes-1"></a><a class="docs-heading-anchor-permalink" href="#Expression-shapes" title="Permalink"></a></h2><p>In SymbolicUtils v4, arrays are first-class citizens. This is implemented by storing the shape of the symbolic. The shape can be queried using <a href="#SymbolicUtils.shape"><code>SymbolicUtils.shape</code></a> and is one of two types.</p><h3 id="Symbolics-with-known-shape"><a class="docs-heading-anchor" href="#Symbolics-with-known-shape">Symbolics with known shape</a><a id="Symbolics-with-known-shape-1"></a><a class="docs-heading-anchor-permalink" href="#Symbolics-with-known-shape" title="Permalink"></a></h3><p>The most common case is when the shape of a symbolic variable is known. For example:</p><pre><code class="language-julia hljs">@syms x[1:2] y[-3:6, 4:7] z</code></pre><p>All of the variables created above have known shape. In this case, <code>SymbolicUtils.shape</code> returns a (custom) vector of <code>UnitRange{Int}</code> semantically equivalent to <code>Base.axes</code>. This does not return a <code>Tuple</code> since the number of dimensions cannot be inferred and thus returning a tuple would introduce type-instability. All array operations will perform validation on the shapes of their inputs (e.g. matrix multiplication) and calculates the shape of their outputs.</p><p>Scalar variables return an empty vector as their shape.</p><h3 id="Symbolics-with-known-ndims"><a class="docs-heading-anchor" href="#Symbolics-with-known-ndims">Symbolics with known <code>ndims</code></a><a id="Symbolics-with-known-ndims-1"></a><a class="docs-heading-anchor-permalink" href="#Symbolics-with-known-ndims" title="Permalink"></a></h3><p>The next most common case is when the exact shape/size of the symbolic is unknown but the number of dimensions is known. For example:</p><pre><code class="language-julia hljs">@syms x::Vector{Number} y::Matrix{Number} z::Array{Number, 3}</code></pre><p>In this case, <code>SymbolicUtils.shape</code> returns a value of type <a href="#SymbolicUtils.Unknown"><code>SymbolicUtils.Unknown</code></a>. This has a single field <code>ndims::Int</code> storing the number of dimensions of the symbolic. Note that a shape of <code>SymbolicUtils.Unknown(0)</code> does not represent a scalar. All array operations will perform as much validation as possible on their arguments. The shape of the result will be calculated on a best-effort basis.</p><h3 id="Symbolics-with-unknown-ndims"><a class="docs-heading-anchor" href="#Symbolics-with-unknown-ndims">Symbolics with unknown <code>ndims</code></a><a id="Symbolics-with-unknown-ndims-1"></a><a class="docs-heading-anchor-permalink" href="#Symbolics-with-unknown-ndims" title="Permalink"></a></h3><p>In this case, nothing is known about the symbolic except that it is an array. For example:</p><pre><code class="language-julia hljs">@syms x::Array{Number}</code></pre><p><code>Symbolics.shape(x)</code> will return <code>SymbolicUtils.Unknown(-1)</code>. This effectively disables most shape checking for array operations.</p><h2 id="Variants"><a class="docs-heading-anchor" href="#Variants">Variants</a><a id="Variants-1"></a><a class="docs-heading-anchor-permalink" href="#Variants" title="Permalink"></a></h2><pre><code class="language-julia hljs">struct Const
    const val::Any
    # ...
end</code></pre><p>Any non-symbolic values in an expression are stored in a <code>Const</code> variant. This is crucial for type-stability, but it does mean that obtaining the value out of a <code>Const</code> is unstable and should be avoided. This value can be obtained by pattern matching using <code>Moshi.Match.@match</code> or using the <a href="#SymbolicUtils.unwrap_const"><code>unwrap_const</code></a> utility. <code>unwrap_const</code> will act as an identity function for any input that is not <code>Const</code>, including non-symbolic inputs. <code>Const</code> is the only variant which does not have metadata.</p><p><a href="#SymbolicUtils.isconst"><code>SymbolicUtils.isconst</code></a> can be used to check if a <code>BasicSymbolic</code> is the <code>Const</code> variant. This variant can be constructed using <code>Const{T}(val)</code> or <code>BSImpl.Const{T}(val)</code>, where <code>T</code> is the appropriate <code>vartype</code>.</p><p>The <code>Const</code> constructors have an additional special behavior. If given an array of symbolics (or array of array of ... symbolics), it will return a <code>Term</code> (see below) with <a href="#SymbolicUtils.array_literal"><code>SymbolicUtils.array_literal</code></a> as the operation. This allows standard symbolic operations (such as <a href="../../api/#SymbolicUtils.substitute"><code>substitute</code></a>) to work on arrays of symbolics without excessive special-case handling and improved type-stability.</p><pre><code class="language-julia hljs">struct Sym
    const name::Symbol
    const metadata::MetadataT
    const shape::ShapeT
    const type::TypeT
    # ...
end</code></pre><p><code>Sym</code> represents a symbolic quantity with a given <code>name</code>. This and <code>Const</code> are the two atomic variants. <code>metadata</code> is the symbolic metadata associated with this variable. <code>type</code> is the tag for the type of quantity represented here. <code>shape</code> stores the shape if the variable is an array symbolic.</p><ul><li><code>metadata</code> is either <code>nothing</code> or a map from <code>DataType</code> keys to arbitrary values. Any</li></ul><p>interaction with metadata should be done by providing such a mapping during construction or using <a href="../../api/#SymbolicUtils.getmetadata"><code>getmetadata</code></a>, <a href="../../api/#SymbolicUtils.setmetadata"><code>setmetadata</code></a>, <a href="../../api/#SymbolicUtils.hasmetadata"><code>hasmetadata</code></a>.</p><ul><li><code>type</code> is a Julia type.</li><li><code>shape</code> is as described above.</li></ul><p>These three fields are present in all subsequent variants as well.</p><p>A <code>Sym</code> can be constructed using <code>Sym{T}(name::Symbol; type, shape, metadata)</code> or <code>BSImpl.Sym{T}(name::Symbol; type, shape, metadata)</code>.</p><pre><code class="language-julia hljs">struct Term
    const f::Any
    const args::SmallV{BasicSymbolicImpl.Type{T}}
    const metadata::MetadataT
    const shape::ShapeT
    const type::TypeT
    # ...
end</code></pre><p><code>Term</code> is the generic expression form for an operation <code>f</code> applied to the arguments in <code>args</code>. In other words, this represents <code>f(args...)</code>. Any constant (non-symbolic) arguments (including arrays of symbolics) are converted to symbolics and wrapped in <code>Const</code>.</p><p>A <code>Term</code> can be constructed using <code>Term{T}(f, args; type, shape, metadata)</code> or <code>BSImpl.Term{T}(f, args; type, shape, metadata)</code>.</p><pre><code class="language-julia hljs">struct AddMul
    const coeff::Any
    const dict::ACDict{T}
    const variant::AddMulVariant.T
    const metadata::MetadataT
    const shape::ShapeT
    const type::TypeT
    # ...
end</code></pre><p><code>AddMul</code> is a specialized representation for associative-commutative addition and multiplication. The two operations are distinguised using the <a href="@ref"><code>AddMulVariant</code></a> EnumX.jl enum. It has two variants: <code>AddMulVariant.ADD</code> and <code>AddMulVariant.MUL</code>.</p><p>For multiplication terms, <code>coeff</code> is a constant non-symbolic coefficient multipled with the expression. <code>dict</code> is a map from terms being multiplied to their exponents. For example, <code>2x^2 * (y + z)^3</code> is represented with <code>coeff = 2</code> and <code>dict = ACDict{T}(x =&gt; 2, (y + z) =&gt; 3)</code>. A valid multiplication term is subject to the following constraints:</p><ul><li><code>coeff</code> must be non-symbolic.</li><li>The values of <code>dict</code> must be non-symbolic.</li><li>The keys of <code>dict</code> must not be expressions with <code>^</code> as the operation UNLESS the exponent is symbolic. For example, <code>x^x * y^2</code> is represented with <code>dict = ACDict{T}((x^x) =&gt; 1, y =&gt; 2)</code>.</li><li><code>dict</code> must not be empty.</li><li><code>coeff</code> must not be zero.</li><li>If <code>dict</code> has only one element, <code>coeff</code> must not be one. Such a case should be represented as a power term (with <code>^</code> as the operation).</li><li>If <code>dict</code> has only one element where the key is an addition, <code>coeff</code> must not be negative one. Such a case should be represented by distributing the negation.</li></ul><p>The <code>Mul{T}(coeff, dict; type, shape, metadata)</code> constructor validates these constraints and automatically returns the appropriate alternative form where applicable. It should be preferred. <code>BSImpl.AddMul{T}(coeff, dict, variant; type, shape, metadata)</code> is faster but does not validate the constraints and should be used with caution. Incorrect usage can and will lead to both invalid expressions and undefined behavior.</p><p>For addition terms, <code>coeff</code> is a constant non-symbolic coefficient added to the expression. <code>dict</code> is a map from terms being added to the constant non-symbolic coefficients they are multiplied by. For example, to represent <code>1 + 2x + 3y * z</code> <code>coeff</code> would be <code>1</code> and <code>dict</code> would be <code>Dict(x =&gt; 2, (y * z) =&gt; 3)</code>. A valid addition term is subject to the following constraints:</p><ul><li><code>coeff</code> must be non-symbolic.</li><li>The values of <code>dict</code> must be non-symbolic.</li><li>The keys of <code>dict</code> must not be additions expressions represented with <code>AddMul</code>.</li><li><code>dict</code> must not be empty.</li><li>If <code>dict</code> has only one element, <code>coeff</code> must not be zero. Such a case should be represented using the appropriate multiplication form.</li></ul><p>The <code>Add{T}(coeff, dict; type, shape, metadata)</code> constructor validates these constraints and automatically returns the appropriate alternative form where applicable. It should be preferred. <code>BSImpl.AddMul{T}(coeff, dict, variant; type, shape, metadata)</code> is faster but does not validate the constraints and should be used with caution. Incorrect usage can and will lead to both invalid expressions and undefined behavior.</p><pre><code class="language-julia hljs">struct Div
    const num::BasicSymbolicImpl.Type{T}
    const den::BasicSymbolicImpl.Type{T}
    const simplified::Bool
    const metadata::MetadataT
    const shape::ShapeT
    const type::TypeT
    # ...
end</code></pre><p>The <code>Div</code> variant represents division (where the operation is <code>/</code>). <code>num</code> is the numerator and <code>den</code> is the denominator expression. <code>simplified</code> is a boolean indicating whether this expression is in the most simplified form possible. If it is <code>true</code>, certain algorithms in <a href="../../api/#SymbolicUtils.simplify_fractions"><code>simplify_fractions</code></a> will not inspect this term. In almost all cases, it should be provided as <code>false</code>. A valid division term is subject to the following constraints:</p><ul><li>Both the numerator and denominator cannot be <code>Const</code> variants. This should instead be represented as a <code>Const</code> variant wrapping the result of division.</li><li>The numerator cannot be zero. This should instead be represented as a <code>Const</code> wrapping the appropriate zero.</li><li>The denominator cannot be one. This should instead be represented as the numerator, possibly wrapped in a <code>Const</code>.</li><li>The denominator cannot be zero. This should instead be represented as a <code>Const</code> with some form of infinity.</li><li>The denominator cannot be negative one. This should instead be represented as the negation of the numerator.</li><li>Non-symbolic coefficients should be propagated to the numerator if it is a constant or multiplication term.</li></ul><p>The <code>Div{T}(num, den, simplified; type, shape, metadata)</code> constructor can be used to build this form. If <code>T</code> is <code>SymReal</code>, the constructor will use <a href="../../api/#SymbolicUtils.quick_cancel"><code>quick_cancel</code></a> to cancel trivially identifiable common factors in the numerator and denominator. It will also perform validation of the above constraints and return the appropriate alternative form where applicable. Some of the constraints can be relaxed for non-scalar algebras. The <code>BSImpl.Div{T}(num, den, simplified; type, shape, metadata)</code> does not perform such validation or transformation.</p><pre><code class="language-julia hljs">struct ArrayOp
    const output_idx::SmallV{Union{Int, BasicSymbolicImpl.Type{T}}}
    const expr::BasicSymbolicImpl.Type{T}
    const reduce::Any
    const term::Union{BasicSymbolicImpl.Type{T}, Nothing}
    const ranges::Dict{BasicSymbolicImpl.Type{T}, StepRange{Int, Int}}
    const metadata::MetadataT
    const shape::ShapeT
    const type::TypeT
end</code></pre><p><code>ArrayOp</code> is used to represent vectorized operations. This variant should not be created manually. Instead, the <a href="#SymbolicUtils.@arrayop"><code>@arrayop</code></a> macro constructs this using a generalized Einstein-summation notation, similar to that of Tullio.jl. Consider the following example:</p><pre><code class="language-julia hljs">ex = @arrayop (i, j) A[i, k] * B[k, j] + C[i, j]</code></pre><p>This represents <code>A * B + C</code> for matrices <code>A, B, C</code> as a vectorized array operation. Some operations, such as broadcasts, are automatically represented as such a form internally. The following description of the fields assumes familiarity with the <code>@arrayop</code> macro.</p><p>When processing this macro, the indices <code>i, j, k</code> are converted to use a common global index variable to avoid potential name conflicts with other symbolic variables named <code>i, j, k</code> if <code>ex</code> is used in a larger expression. The <code>output_idx</code> field stores <code>[i, j]</code>. <code>expr</code> stores the expression <code>A[i, k] * B[k, j] + C[i, j]</code>, with <code>i, j, k</code> replaced by the common global index variable. <code>reduce</code> is the operation used to reduce indices not present in <code>output_idx</code> (in this example, <code>k</code>). By default, it is <code>+</code>. <code>term</code> stores an expression that represents an equivalent computation to use for printing/code-generation. For example, here <code>A * B + C</code> would be a valid value for <code>term</code>. By default, <code>term</code> is <code>nothing</code> except when the expression is generated via <code>broadcast</code> or a similar operation. <code>ranges</code> is a dictionary mapping indices used in <code>expr</code> (converted to the common global index) to the range of indices over which they should iterate, in case such a range is explicitly provided.</p><div class="admonition is-info" id="Note-d580e91f1d7518fc"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-d580e91f1d7518fc" title="Permalink"></a></header><div class="admonition-body"></div></div><p>The common global index variable is printed as <code>_1</code>, <code>_2</code>, ... in arrayops. It is not   a valid symbolic variable outside of an <code>ArrayOp</code>&#39;s <code>expr</code>.</p><p>A valid <code>ArrayOp</code> satisfies the following conditions:</p><ul><li><code>output_idx</code> only contains the integer <code>1</code> or variants of the common global index variable.</li><li>Any top-level indexing operations in <code>expr</code> use common global indices. A top-level indexing operation is a term whose operation is <code>getindex</code>, and which is not a descendant of any other term whose operation is <code>getindex</code>.</li><li><code>reduce</code> must be a valid reduction operation that can be passed to <code>Base.reduce</code>.</li><li>If <code>term</code> is not <code>nothing</code>, it must be an expression with shape <code>shape</code> and type <code>type</code>.</li><li>The keys of <code>ranges</code> must be variants of the common global index variable, and must be present in <code>expr</code>.</li></ul><p>The <code>@arrayop</code> macro should be heavily preferred for creating <code>ArrayOp</code>s. In case this is not possible (such as in recursive functions like <code>substitute</code>) the <code>ArrayOp</code> constructor should be preferred. This does not allow specifying the <code>type</code> and <code>shape</code>, since these values are tied to the fields of the variant and are thus determined. The <code>BSImpl.ArrayOp</code> constructor should be used with extreme caution, since it does not validate input.</p><h2 id="Array-arithmetic"><a class="docs-heading-anchor" href="#Array-arithmetic">Array arithmetic</a><a id="Array-arithmetic-1"></a><a class="docs-heading-anchor-permalink" href="#Array-arithmetic" title="Permalink"></a></h2><p>SymbolicUtils implements a simple array algebra in addition to the default scalar algebra. Similar to how <a href="#SymbolicUtils.promote_symtype"><code>SymbolicUtils.promote_symtype</code></a> given a function and symtypes of its arguments returns the symtype of the result, <a href="#SymbolicUtils.promote_shape"><code>SymbolicUtils.promote_shape</code></a> does the same for the shapes of the arguments. Implementing <em>both</em> methods is cruicial for correctly using custom functions in symbolic expressions. Without <code>promote_shape</code>, SymbolicUtils will use <code>Unknown(-1)</code> as the shape.</p><p>The array algebra implemented aims to mimic that of base <code>Array</code>s as closely as possible. For example, a symbolic <code>adjoint(::Vector) * (::Vector)</code> will return a symbolic scalar instead of a one-element symbolic vector. <code>promote_shape</code> implementations will propagate the shape information on a best-effort basis. Invalid shapes (such as attempting to multiply a 3-dimensional array) will error. Following are notable exceptions to Base-like behavior:</p><ul><li><code>map</code> and <code>mapreduce</code> require that all input arrays have the same <code>shape</code></li><li><code>promote_symtype</code> and <code>promote_shape</code> is not implemented for <code>map</code> and <code>mapreduce</code>, since doing so requires the function(s) passed to <code>map</code> and <code>mapreduce</code> instead of their types or shapes.</li><li>Since <code>ndims</code> information is not present in the type, <code>eachindex</code>, <code>iterate</code>, <code>size</code>, <code>axes</code>, <code>ndims</code>, <code>collect</code> are type-unstable. <a href="#SymbolicUtils.stable_eachindex"><code>SymbolicUtils.stable_eachindex</code></a> is useful as a type-stable iteration alternative.</li><li><code>ifelse</code> requires that both the true and false cases have identical shape.</li><li>Symbolic arrays <em>only</em> support cartesian indexing. For example, given <code>@syms x[1:3, 1:3]</code> accessing <code>x[4]</code> is invalid and <code>x[1, 2]</code> should be used. Valid indices are <code>Int</code>, <code>Colon</code>, <code>AbstractRange{Int}</code> and symbolic expressions with integer <code>symtype</code>. A single <code>CartesianIndex</code> of appropriate dimension can also be used to symbolically index arrays.</li></ul><p>Symbolic array operations are also supported on arrays of symbolics. However, at least one of the arguments to the function must be a symbolic (instead of an array of symbolics) to allow the dispatches defined in SymbolicUtils to be targeted instead of those in Base. To aid in constructing arrays of symbolics, the <a href="#SymbolicUtils.BS"><code>BS</code></a> utility is provided. Similar to the <code>T[...]</code> syntax for constructing an array of etype <code>T</code>, <code>BS[...]</code> will construct an array of <code>BasicSymbolic</code>s. At least one value in the array must be a symbolic value to infer <code>T</code> in <code>Array{BasicSymbolic{T}, N}</code>. To explicitly specify the <code>vartype</code>, use <code>BS{T}[...]</code>.</p><h2 id="Symbolic-functions-and-dependent-variables"><a class="docs-heading-anchor" href="#Symbolic-functions-and-dependent-variables">Symbolic functions and dependent variables</a><a id="Symbolic-functions-and-dependent-variables-1"></a><a class="docs-heading-anchor-permalink" href="#Symbolic-functions-and-dependent-variables" title="Permalink"></a></h2><p>SymbolicUtils defines <code>FnType{A, R, T}</code> for symbolic functions and dependent variables. Here, <code>A</code> is a <code>Tuple{...}</code> of the symtypes of arguments and <code>R</code> is the type returned by the symbolic function. <code>T</code> is the type that the function itself subtypes, or <code>Nothing</code>.</p><p>The syntax</p><pre><code class="language-julia hljs">@syms f(::T1, ::T2)::R</code></pre><p>creates <code>f</code> with a symtype of <code>FnType{Tuple{T1, T2}, R, Nothing}</code>. This is a symbolic function taking arguments of type <code>T1</code> and <code>T2</code>, and returning <code>R</code>. <code>Nothing</code> is a sentinel indicating that the supertype of the function is unknown. By contrast,</p><pre><code class="language-julia hljs">@syms f(..)::R</code></pre><p>creates <code>f</code> with a symtype of <code>FnType{Tuple, R, Nothing}</code>. SymbolicUtils considers this case to be a dependent variable with as-yet unspecified independent variables. In other words,</p><pre><code class="language-julia hljs">@syms x f1(::Real)::Real f2(..)::Real</code></pre><p>Here, <code>f1(x)</code> is considered a symbolic function <code>f1</code> called with the argument <code>x</code> and <code>f2(x)</code> is considered a dependent variable that depends on <code>x</code>. The utilities <a href="#SymbolicUtils.is_function_symbolic"><code>SymbolicUtils.is_function_symbolic</code></a>, <a href="#SymbolicUtils.is_function_symtype"><code>SymbolicUtils.is_function_symtype</code></a>, <a href="#SymbolicUtils.is_called_function_symbolic"><code>SymbolicUtils.is_called_function_symbolic</code></a> can be used to differentiate between these cases.</p><h2 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h2><h3 id="Basics"><a class="docs-heading-anchor" href="#Basics">Basics</a><a id="Basics-1"></a><a class="docs-heading-anchor-permalink" href="#Basics" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.BasicSymbolic" href="#SymbolicUtils.BasicSymbolic"><code>SymbolicUtils.BasicSymbolic</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Alias for `SymbolicUtils.BasicSymbolicImpl.Type`.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/cf062a946a1ae95b5e55b2aa29595987a13a9202/src/types.jl#L223-L225">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.@syms" href="#SymbolicUtils.@syms"><code>SymbolicUtils.@syms</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@syms &lt;lhs_expr&gt;[::T1] &lt;lhs_expr&gt;[::T2]...</code></pre><p>For instance:</p><pre><code class="language-julia hljs">@syms foo::Real bar baz(x, y::Real)::Complex</code></pre><p>Create one or more variables. <code>&lt;lhs_expr&gt;</code> can be just a symbol in which case it will be the name of the variable, or a function call in which case a function-like variable which has the same name as the function being called. The Sym type, or in the case of a function-like Sym, the output type of calling the function can be set using the <code>::T</code> syntax.</p><p><strong>Examples:</strong></p><ul><li><code>@syms foo bar::Real baz::Int</code> will create</li></ul><p>variable <code>foo</code> of symtype <code>Number</code> (the default), <code>bar</code> of symtype <code>Real</code> and <code>baz</code> of symtype <code>Int</code></p><ul><li><code>@syms f(x) g(y::Real, x)::Int h(a::Int, f(b))</code> creates 1-arg <code>f</code> 2-arg <code>g</code></li></ul><p>and 2 arg <code>h</code>. The second argument to <code>h</code> must be a one argument function-like variable. So, <code>h(1, g)</code> will fail and <code>h(1, f)</code> will work.</p><p><strong>Formal syntax</strong></p><p>Following is a semi-formal CFG of the syntax accepted by this macro:</p><pre><code class="language-python hljs"># any variable accepted by this macro must be a `var`.
# `var` can represent a quantity (`value`) or a function `(fn)`.
var = value | fn
# A `value` is represented as a name followed by a suffix
value = name suffix
# A `name` can be a valid Julia identifier
name = ident |
# Or it can be an interpolated variable, in which case `ident` is assumed to refer to
# a variable in the current scope of type `Symbol` containing the name of this variable.
# Note that in this case the created symbolic variable will be bound to a randomized
# Julia identifier.
       &quot;$&quot; ident |
# Or it can be of the form `Foo.Bar.baz` referencing a value accessible as `Foo.Bar.baz`
# in the current scope.
       getproperty_literal
getproperty_literal = ident &quot;.&quot; getproperty_literal | ident &quot;.&quot; ident
# The `suffix` can be empty (no suffix) which defaults the type to `Number`
suffix = &quot;&quot; |
# or it can be a type annotation (setting the type of the prefix). The shape of the result
# is inferred from the type as best it can be. In particular, `Array{T, N}` is inferred
# to have shape `Unknown(N)`.
         &quot;::&quot; type |
# or it can be a shape annotation, which sets the shape to the one specified by `ranges`.
# The type defaults to `Array{Number, length(ranges)}`
         &quot;[&quot; ranges &quot;]&quot; |
# lastly, it can be a combined shape and type annotation. Here, the type annotation
# sets the `eltype` of the symbolic array.
         &quot;[&quot; ranges &quot;]::&quot; type
# `ranges` is either a single `range` or a single range followed by one or more `ranges`.
ranges = range | range &quot;,&quot; ranges
# A `range` is simply two bounds separated by a colon, as standard Julia ranges work.
# The range must be non-empty. Each bound can be a literal integer or an identifier
# representing an integer in the current scope.
range = (int | ident) &quot;:&quot; (int | ident) |
# Alternatively, a range can be a Julia expression that evaluates to a range. All identifiers
# used in `expr` are assumed to exist in the current scope.
        expr |
# Alternatively, a range can be a Julia expression evaluating to an iterable of ranges,
# followed by the splat operator.
        expr &quot;...&quot;
# A function is represented by a function-call syntax `fncall` followed by the `suffix`
# above. The type and shape from `suffix` represent the type and shape of the value
# returned by the symbolic function.
fn = fncall suffix
# a function call is a call `head` followed by a parenthesized list of arguments.
fncall = head &quot;(&quot; args &quot;)&quot;
# A function call head can be a name, representing the name of the symbolic function.
head = ident |
# Alternatively, it can be a parenthesized type-annotated name, where the type annotation
# represents the intended supertype of the function. In other words, if this symbolic
# function were to be replaced by an &quot;actual&quot; function, the type-annotation constrains the
# type of the &quot;actual&quot; function.
       &quot;(&quot; ident &quot;::&quot; type &quot;)&quot;
# Arguments to a function is a list of one or more arguments
args = arg | arg &quot;,&quot; args
# An argument can take the syntax of a variable (which means we can represent functions of
# functions of functions of...). The type of the variable constrains the type of the
# corresponding argument of the function. The name and shape information is discarded.
arg = var |
# Or an argument can be an unnamed type-annotation, which constrains the type without
# requiring a name.
      &quot;::&quot; type |
# Or an argument can be the identifier `..`, which is used as a stand-in for `Vararg{Any}`
      &quot;..&quot; |
# Or an argument can be a type-annotated `..`, representing `Vararg{type}`. Note that this
# and the previous version of `arg` can only be the last element in `args` due to Julia&#39;s
# `Tuple` semantics.
      &quot;(..)::&quot; type |
# Or an argument can be a Julia expression followed by a splat operator. This assumes the
# expression evaluates to an iterable of symbolic variables whose `symtype` should be used
# as the argument types. Note that `expr` may be evaluated multiple times in the macro
# expansion.
      expr &quot;...&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/cf062a946a1ae95b5e55b2aa29595987a13a9202/src/syms.jl#L1-L102">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.symtype" href="#SymbolicUtils.symtype"><code>SymbolicUtils.symtype</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">symtype(
    x::SymbolicUtils.BasicSymbolicImpl.var&quot;typeof(BasicSymbolicImpl)&quot;{T} where T
) -&gt; DataType
</code></pre><p>Return the Julia type that the given symbolic expression <code>x</code> represents. Can also be called on non-symbolic values, in which case it is equivalent to <code>typeof</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/cf062a946a1ae95b5e55b2aa29595987a13a9202/src/types.jl#L306-L312">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.vartype" href="#SymbolicUtils.vartype"><code>SymbolicUtils.vartype</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vartype(x)</code></pre><p>defined at <a href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/tree/cf062a946a1ae95b5e55b2aa29595987a13a9202//src/types.jl#L331"><code>/home/runner/work/SymbolicUtils.jl/SymbolicUtils.jl/src/types.jl:331</code></a>.</p><pre><code class="language-julia hljs">vartype(_)</code></pre><p>defined at <a href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/tree/cf062a946a1ae95b5e55b2aa29595987a13a9202//src/types.jl#L332"><code>/home/runner/work/SymbolicUtils.jl/SymbolicUtils.jl/src/types.jl:332</code></a>.</p><p>Extract the variant type of a <code>BasicSymbolic</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/cf062a946a1ae95b5e55b2aa29595987a13a9202/src/types.jl#L326-L330">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.SymReal" href="#SymbolicUtils.SymReal"><code>SymbolicUtils.SymReal</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type SymReal &lt;: SymbolicUtils.SymVariant</code></pre><p>One of three possible values of the <a href="#SymbolicUtils.vartype"><code>vartype</code></a>. This variant is the default and behaves as a typical ideal scalar algebra would be expected to.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/cf062a946a1ae95b5e55b2aa29595987a13a9202/src/types.jl#L4-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.SafeReal" href="#SymbolicUtils.SafeReal"><code>SymbolicUtils.SafeReal</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type SafeReal &lt;: SymbolicUtils.SymVariant</code></pre><p>One of three possible values of the <a href="#SymbolicUtils.vartype"><code>vartype</code></a>. This variant is identical to <a href="#SymbolicUtils.SymReal"><code>SymReal</code></a> except common terms in the numerator and denominator of a division are not cancelled out.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/cf062a946a1ae95b5e55b2aa29595987a13a9202/src/types.jl#L11-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.TreeReal" href="#SymbolicUtils.TreeReal"><code>SymbolicUtils.TreeReal</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type TreeReal &lt;: SymbolicUtils.SymVariant</code></pre><p>One of three possible values of the <a href="#SymbolicUtils.vartype"><code>vartype</code></a>. This variant does not assume anything about the algebra and always uses the default tree form for expressions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/cf062a946a1ae95b5e55b2aa29595987a13a9202/src/types.jl#L19-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.shape" href="#SymbolicUtils.shape"><code>SymbolicUtils.shape</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">shape(x)</code></pre><p>Get the shape of a value or symbolic expression. Generally equivalent to <code>axes</code> for non-symbolic <code>x</code>, but also works on non-array values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/cf062a946a1ae95b5e55b2aa29595987a13a9202/src/types.jl#L334-L339">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.Unknown" href="#SymbolicUtils.Unknown"><code>SymbolicUtils.Unknown</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Unknown</code></pre><p>A struct used as the <code>shape</code> of symbolic expressions with unknown size.</p><p><strong>Fields</strong></p><ul><li><code>ndims::Int64</code>: An integer &gt;= -1 indicating the number of dimensions of the symbolic expression of unknown size. A value of <code>-1</code> indicates the number of dimensions is also unknown.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/cf062a946a1ae95b5e55b2aa29595987a13a9202/src/types.jl#L33-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.AddMulVariant" href="#SymbolicUtils.AddMulVariant"><code>SymbolicUtils.AddMulVariant</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>An EnumX.jl enum used to distinguish between addition and multiplication in <a href="#SymbolicUtils.BasicSymbolicImpl.AddMul"><code>SymbolicUtils.BSImpl.AddMul</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/cf062a946a1ae95b5e55b2aa29595987a13a9202/src/types.jl#L123-L128">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.unwrap_const" href="#SymbolicUtils.unwrap_const"><code>SymbolicUtils.unwrap_const</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unwrap_const(x) -&gt; Any
</code></pre><p>Extract the constant value from a <code>Const</code> variant, or return the input unchanged.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: Any value, potentially a <code>BasicSymbolic</code> with a <code>Const</code> variant</li></ul><p><strong>Returns</strong></p><ul><li>The wrapped constant value if <code>x</code> is a <code>Const</code> variant of <code>BasicSymbolic</code></li><li>The input <code>x</code> unchanged otherwise</li></ul><p><strong>Details</strong></p><p>This function unwraps constant symbolic expressions to their underlying values. It handles all three symbolic variants (<code>SymReal</code>, <code>SafeReal</code>, <code>TreeReal</code>). For non-<code>Const</code> symbolic expressions or non-symbolic values, returns the input unchanged.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/cf062a946a1ae95b5e55b2aa29595987a13a9202/src/types.jl#L2481-L2497">source</a></section></article><h3 id="Inner-constructors"><a class="docs-heading-anchor" href="#Inner-constructors">Inner constructors</a><a id="Inner-constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Inner-constructors" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.array_literal" href="#SymbolicUtils.array_literal"><code>SymbolicUtils.array_literal</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">array_literal(sz::NTuple{N, Int64}, args...) -&gt; Any
</code></pre><p>Utility function used as the operation of expressions representing an array of symbolic values. See <a href="#SymbolicUtils.BasicSymbolicImpl.Const"><code>SymbolicUtils.BSImpl.Const</code></a> for more details.</p><p>The first argument <code>sz</code> is the <code>size</code> of the represented array. <code>args...</code> is <code>prod(sz)</code> elements representing the elements of the array in column-major order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/cf062a946a1ae95b5e55b2aa29595987a13a9202/src/types.jl#L1581-L1589">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.BasicSymbolicImpl.Const" href="#SymbolicUtils.BasicSymbolicImpl.Const"><code>SymbolicUtils.BasicSymbolicImpl.Const</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BSImpl.Const{T}(val) where {T}</code></pre><p>Constructor for a symbolic expression that wraps a constant value <code>val</code>. Also converts arrays/tuples of symbolics to symbolic expressions.</p><p><strong>Arguments</strong></p><ul><li><code>val</code>: The value to wrap (can be any type including arrays and tuples)</li></ul><p><strong>Returns</strong></p><ul><li><code>BasicSymbolic{T}</code>: A <code>Const</code> variant or specialized representation</li></ul><p><strong>Details</strong></p><p>This is the low-level constructor for constant expressions. It handles several special cases:</p><ol><li>If <code>val</code> is already a <code>BasicSymbolic{T}</code>, returns it unchanged</li><li>If <code>val</code> is a <code>BasicSymbolic</code> of a different variant type, throws an error</li><li>If <code>val</code> is an array containing symbolic elements, creates a <code>Term</code> with <a href="#SymbolicUtils.array_literal"><code>SymbolicUtils.array_literal</code></a> operation</li><li>If <code>val</code> is a tuple containing symbolic elements, creates a <code>Term</code> with <code>tuple</code> operation</li><li>Otherwise, creates a <code>Const</code> variant wrapping the value</li></ol><p><strong>Extended help</strong></p><p>The <code>unsafe</code> flag skips hash consing for performance in internal operations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/cf062a946a1ae95b5e55b2aa29595987a13a9202/src/types.jl#L1592-L1616">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.BasicSymbolicImpl.Sym" href="#SymbolicUtils.BasicSymbolicImpl.Sym"><code>SymbolicUtils.BasicSymbolicImpl.Sym</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BSImpl.Sym{T}(name::Symbol; metadata = nothing, type, shape = default_shape(type)) where {T}</code></pre><p>Internal constructor for symbolic variables.</p><p><strong>Arguments</strong></p><ul><li><code>name::Symbol</code>: The name of the symbolic variable</li><li><code>metadata</code>: Optional metadata dictionary (default: <code>nothing</code>)</li><li><code>type</code>: The symbolic type of the variable (required keyword argument)</li><li><code>shape</code>: The shape of the variable (default: inferred from <code>type</code>)</li></ul><p><strong>Returns</strong></p><ul><li><code>BasicSymbolic{T}</code>: A <code>Sym</code> variant representing the symbolic variable</li></ul><p><strong>Details</strong></p><p>This is the low-level constructor for symbolic variables. It normalizes the metadata and shape inputs, populates default properties using <code>ordered_override_properties</code>, and performs hash consing. The <code>type</code> parameter determines the Julia type that this symbolic variable represents.</p><p><strong>Extended help</strong></p><p>The <code>unsafe</code> keyword argument (default: <code>false</code>) can be used to skip hash consing for performance in internal operations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/cf062a946a1ae95b5e55b2aa29595987a13a9202/src/types.jl#L1658-L1682">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.BasicSymbolicImpl.Term" href="#SymbolicUtils.BasicSymbolicImpl.Term"><code>SymbolicUtils.BasicSymbolicImpl.Term</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BSImpl.Term{T}(f, args; metadata = nothing, type, shape = default_shape(type)) where {T}</code></pre><p>Internal constructor for function application terms.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: The function or operation to apply</li><li><code>args</code>: The arguments to the function (normalized to <code>ArgsT{T}</code>)</li><li><code>metadata</code>: Optional metadata dictionary (default: <code>nothing</code>)</li><li><code>type</code>: The result type of the function application (required keyword argument)</li><li><code>shape</code>: The shape of the result (default: inferred from <code>type</code>)</li></ul><p><strong>Returns</strong></p><ul><li><code>BasicSymbolic{T}</code>: A <code>Term</code> variant representing the function application</li></ul><p><strong>Details</strong></p><p>This is the low-level constructor for function application expressions. It represents <code>f(args...)</code> symbolically. The constructor normalizes metadata, shape, and arguments, populates default properties, and performs hash consing. The <code>type</code> parameter should be the expected return type of calling <code>f</code> with <code>args</code>.</p><p><strong>Extended help</strong></p><p>The <code>unsafe</code> keyword argument (default: <code>false</code>) can be used to skip hash consing for performance in internal operations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/cf062a946a1ae95b5e55b2aa29595987a13a9202/src/types.jl#L1694-L1719">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.BasicSymbolicImpl.AddMul" href="#SymbolicUtils.BasicSymbolicImpl.AddMul"><code>SymbolicUtils.BasicSymbolicImpl.AddMul</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BSImpl.AddMul{T}(coeff, dict, variant::AddMulVariant.T; metadata = nothing, type, shape = default_shape(type)) where {T}</code></pre><p>Internal constructor for addition and multiplication expressions.</p><p><strong>Arguments</strong></p><ul><li><code>coeff</code>: The leading coefficient (for addition) or coefficient (for multiplication)</li><li><code>dict</code>: Dictionary mapping terms to their coefficients/exponents (normalized to <code>ACDict{T}</code>)</li><li><code>variant::AddMulVariant.T</code>: Either <code>AddMulVariant.ADD</code> or <code>AddMulVariant.MUL</code></li><li><code>metadata</code>: Optional metadata dictionary (default: <code>nothing</code>)</li><li><code>type</code>: The result type of the operation (required keyword argument)</li><li><code>shape</code>: The shape of the result (default: inferred from <code>type</code>)</li></ul><p><strong>Returns</strong></p><ul><li><code>BasicSymbolic{T}</code>: An <code>AddMul</code> variant representing the sum or product</li></ul><p><strong>Details</strong></p><p>This is the low-level constructor for optimized addition and multiplication expressions. For addition, represents <code>coeff + sum(k * v for (k, v) in dict)</code>. For multiplication, represents <code>coeff * prod(k ^ v for (k, v) in dict)</code>. The constructor normalizes all inputs and performs hash consing.</p><p><strong>Extended help</strong></p><p>The <code>unsafe</code> keyword argument (default: <code>false</code>) can be used to skip hash consing for performance in internal operations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/cf062a946a1ae95b5e55b2aa29595987a13a9202/src/types.jl#L1732-L1758">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.BasicSymbolicImpl.Div" href="#SymbolicUtils.BasicSymbolicImpl.Div"><code>SymbolicUtils.BasicSymbolicImpl.Div</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BSImpl.Div{T}(num, den, simplified::Bool; metadata = nothing, type, shape = default_shape(type)) where {T}</code></pre><p>Internal constructor for division expressions.</p><p><strong>Arguments</strong></p><ul><li><code>num</code>: The numerator (converted to <code>Const{T}</code>)</li><li><code>den</code>: The denominator (converted to <code>Const{T}</code>)</li><li><code>simplified::Bool</code>: Whether the division has been simplified</li><li><code>metadata</code>: Optional metadata dictionary (default: <code>nothing</code>)</li><li><code>type</code>: The result type of the division (required keyword argument)</li><li><code>shape</code>: The shape of the result (default: inferred from <code>type</code>)</li></ul><p><strong>Returns</strong></p><ul><li><code>BasicSymbolic{T}</code>: A <code>Div</code> variant representing the division</li></ul><p><strong>Details</strong></p><p>This is the low-level constructor for division expressions. It represents <code>num / den</code> symbolically. Both numerator and denominator are automatically wrapped in <code>Const{T}</code> if not already symbolic. The <code>simplified</code> flag tracks whether simplification has been attempted. The constructor normalizes all inputs and performs hash consing.</p><p><strong>Extended help</strong></p><p>The <code>unsafe</code> keyword argument (default: <code>false</code>) can be used to skip hash consing for performance in internal operations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/cf062a946a1ae95b5e55b2aa29595987a13a9202/src/types.jl#L1772-L1798">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.BasicSymbolicImpl.ArrayOp" href="#SymbolicUtils.BasicSymbolicImpl.ArrayOp"><code>SymbolicUtils.BasicSymbolicImpl.ArrayOp</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BSImpl.ArrayOp{T}(output_idx, expr::BasicSymbolic{T}, reduce, term, ranges = default_ranges(T); metadata = nothing, type, shape = default_shape(type)) where {T}</code></pre><p>Internal constructor for array operation expressions.</p><p><strong>Arguments</strong></p><ul><li><code>output_idx</code>: Output indices defining the result array dimensions (normalized to <code>OutIdxT{T}</code>)</li><li><code>expr::BasicSymbolic{T}</code>: The expression to evaluate for each index combination</li><li><code>reduce</code>: Reduction operation to apply (or <code>nothing</code> for direct assignment)</li><li><code>term</code>: Optional term for accumulation (or <code>nothing</code>)</li><li><code>ranges</code>: Dictionary mapping index variables to their ranges (default: empty)</li><li><code>metadata</code>: Optional metadata dictionary (default: <code>nothing</code>)</li><li><code>type</code>: The result type (required keyword argument, typically an array type)</li><li><code>shape</code>: The shape of the result (default: inferred from <code>type</code>)</li></ul><p><strong>Returns</strong></p><ul><li><code>BasicSymbolic{T}</code>: An <code>ArrayOp</code> variant representing the array operation</li></ul><p><strong>Details</strong></p><p>This is the low-level constructor for array comprehension-like operations. It represents operations like <code>[expr for i in range1, j in range2]</code> with optional reduction. The constructor normalizes all inputs, unwraps constants where appropriate, and optionally performs hash consing.</p><p>The <a href="#SymbolicUtils.ArrayOp"><code>ArrayOp</code></a> constructor should be strongly preferred.</p><p><strong>Extended help</strong></p><p>The <code>unsafe</code> keyword argument (default: <code>false</code>) can be used to skip hash consing for performance in internal operations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/cf062a946a1ae95b5e55b2aa29595987a13a9202/src/types.jl#L1820-L1850">source</a></section></article><h3 id="High-level-constructors"><a class="docs-heading-anchor" href="#High-level-constructors">High-level constructors</a><a id="High-level-constructors-1"></a><a class="docs-heading-anchor-permalink" href="#High-level-constructors" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.Const" href="#SymbolicUtils.Const"><code>SymbolicUtils.Const</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Const{T}(val) where {T}</code></pre><p>Alias for <a href="#SymbolicUtils.BasicSymbolicImpl.Const"><code>BSImpl.Const{T}</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/cf062a946a1ae95b5e55b2aa29595987a13a9202/src/types.jl#L1873-L1877">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.Sym" href="#SymbolicUtils.Sym"><code>SymbolicUtils.Sym</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Sym{T}(name; kw...) where {T}</code></pre><p>Alias for <a href="#SymbolicUtils.BasicSymbolicImpl.Sym"><code>BSImpl.Sym{T}</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/cf062a946a1ae95b5e55b2aa29595987a13a9202/src/types.jl#L1880-L1884">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.Term" href="#SymbolicUtils.Term"><code>SymbolicUtils.Term</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Term{T}(f, args; type = _promote_symtype(f, args), kw...) where {T}</code></pre><p>Alias for <a href="#SymbolicUtils.BasicSymbolicImpl.Term"><code>BSImpl.Term{T}</code></a> except it also unwraps <code>args</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/cf062a946a1ae95b5e55b2aa29595987a13a9202/src/types.jl#L1887-L1891">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.Add" href="#SymbolicUtils.Add"><code>SymbolicUtils.Add</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Add{T}(coeff, dict; kw...) where {T}</code></pre><p>High-level constructor for addition expressions.</p><p><strong>Arguments</strong></p><ul><li><code>coeff</code>: The constant term (additive offset)</li><li><code>dict</code>: Dictionary mapping terms to their coefficients</li><li><code>kw...</code>: Additional keyword arguments (e.g., <code>type</code>, <code>shape</code>, <code>metadata</code>, <code>unsafe</code>)</li></ul><p><strong>Returns</strong></p><ul><li><code>BasicSymbolic{T}</code>: An optimized representation of <code>coeff + sum(k * v for (k, v) in dict)</code></li></ul><p><strong>Details</strong></p><p>This constructor maintains invariants required by the <code>AddMul</code> variant. This should be preferred over the <code>BSImpl.AddMul{T}</code> constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/cf062a946a1ae95b5e55b2aa29595987a13a9202/src/types.jl#L1897-L1914">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.Mul" href="#SymbolicUtils.Mul"><code>SymbolicUtils.Mul</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Mul{T}(coeff, dict; kw...) where {T}</code></pre><p>High-level constructor for multiplication expressions.</p><p><strong>Arguments</strong></p><ul><li><code>coeff</code>: The multiplicative coefficient</li><li><code>dict</code>: Dictionary mapping base terms to their exponents</li><li><code>kw...</code>: Additional keyword arguments (e.g., <code>type</code>, <code>shape</code>, <code>metadata</code>, <code>unsafe</code>)</li></ul><p><strong>Returns</strong></p><ul><li><code>BasicSymbolic{T}</code>: An optimized representation of <code>coeff * prod(k ^ v for (k, v) in dict)</code></li></ul><p><strong>Details</strong></p><p>This constructor maintains invariants required by the <code>AddMul</code> variant. This should be preferred over the <code>BSImpl.AddMul{T}</code> constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/cf062a946a1ae95b5e55b2aa29595987a13a9202/src/types.jl#L1933-L1950">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.Div" href="#SymbolicUtils.Div"><code>SymbolicUtils.Div</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Div{T}(n, d, simplified; type = promote_symtype(/, symtype(n), symtype(d)), kw...) where {T}</code></pre><p>High-level constructor for division expressions with simplification.</p><p><strong>Arguments</strong></p><ul><li><code>n</code>: The numerator</li><li><code>d</code>: The denominator</li><li><code>simplified::Bool</code>: Whether simplification has been attempted</li><li><code>type</code>: The result type (default: inferred using <code>promote_symtype</code>)</li><li><code>kw...</code>: Additional keyword arguments (e.g., <code>shape</code>, <code>metadata</code>, <code>unsafe</code>)</li></ul><p><strong>Returns</strong></p><ul><li><code>BasicSymbolic{T}</code>: An optimized representation of <code>n / d</code></li></ul><p><strong>Details</strong></p><p>This constructor creates symbolic division expressions with extensive simplification:</p><ul><li>Zero numerator returns zero</li><li>Unit denominator returns the numerator</li><li>Zero denominator returns <code>Const{T}(1 // 0)</code> (infinity). Any infinity may be returned.</li><li>Nested divisions are flattened</li><li>Constant divisions are evaluated</li><li>Rational coefficients are simplified</li><li>Multiplications in numerator/denominator are handled specially</li></ul><p>For non-<code>SafeReal</code> variants, automatic cancellation is attempted using <code>quick_cancel</code>. The <code>simplified</code> flag prevents infinite simplification loops.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/cf062a946a1ae95b5e55b2aa29595987a13a9202/src/types.jl#L2031-L2059">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.ArrayOp" href="#SymbolicUtils.ArrayOp"><code>SymbolicUtils.ArrayOp</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ArrayOp{T}(output_idx, expr, reduce, term, ranges; metadata = nothing) where {T}</code></pre><p>High-level constructor for array operation expressions.</p><p><strong>Arguments</strong></p><ul><li><code>output_idx</code>: Output indices defining result dimensions</li><li><code>expr</code>: Expression to evaluate for each index combination</li><li><code>reduce</code>: Reduction operation (or <code>nothing</code>)</li><li><code>term</code>: Optional accumulation term (or <code>nothing</code>)</li><li><code>ranges</code>: Dictionary mapping index variables to ranges</li><li><code>metadata</code>: Optional metadata (default: <code>nothing</code>)</li></ul><p><strong>Returns</strong></p><ul><li><code>BasicSymbolic{T}</code>: An <code>ArrayOp</code> representing the array comprehension</li></ul><p><strong>Details</strong></p><p>This constructor validates and parses fields of the <code>ArrayOp</code> variant. It is usually never called directly. Prefer using the <a href="#SymbolicUtils.@arrayop"><code>@arrayop</code></a> macro.</p><p><strong>Extended help</strong></p><p>The <code>unsafe</code> keyword argument (default: <code>false</code>) can be used to skip hash consing for performance in internal operations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/cf062a946a1ae95b5e55b2aa29595987a13a9202/src/types.jl#L2416-L2441">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.@arrayop" href="#SymbolicUtils.@arrayop"><code>SymbolicUtils.@arrayop</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@arrayop (idxs...,) expr [idx in range, ...] [options...]</code></pre><p>Construct a vectorized array operation using Tullio.jl-like generalized Einstein notation. <code>idxs</code> is a tuple corresponding to the indices in the result. <code>expr</code> is the indexed expression. Indices used in <code>expr</code> not present in <code>idxs</code> will be collapsed using the <code>reduce</code> function, which defaults to <code>+</code>. For example, matrix multiplication can be expressed as follows:</p><pre><code class="language-julia hljs">@syms A[1:5, 1:5] B[1:5, 1:5]
matmul = @arrayop (i, j) A[i, k] * B[k, j]</code></pre><p>Here the elements of the collapsed dimension <code>k</code> are reduced using the <code>+</code> operation. To use a different reducer, the <code>reduce</code> option can be supplied:</p><pre><code class="language-julia hljs">C = @arrayop (i, j) A[i, k] * B[k, j] reduce=max</code></pre><p>Now, <code>C[i, j]</code> is the maximum value of <code>A[i, k] * B[k, j]</code> for across all <code>k</code>.</p><p><strong>Singleton dimensions</strong></p><p>Arbitrary singleton dimensions can be added in the result by inserting <code>1</code> at the desired position in <code>idxs</code>:</p><pre><code class="language-julia hljs">C = @arrayop (i, 1, j, 1) A[i, k] * B[k, j]</code></pre><p>Here, <code>C</code> is a symbolic array of size <code>(5, 1, 5, 1)</code>.</p><p><strong>Restricted ranges</strong></p><p>For any index variable <code>i</code> in <code>expr</code>, all its usages in <code>expr</code> must correspond to axes of identical length. For example:</p><pre><code class="language-julia hljs">@syms D[1:3, 1:5]
@arrayop (i, j) A[i, k] * D[k, j]</code></pre><p>The above usage is invalid, since <code>k</code> in <code>A</code> is used to index an axis of length <code>5</code> and in <code>D</code> is used to index an axis of length <code>3</code>. The iteration range of variables can be manually restricted:</p><pre><code class="language-julia hljs">@arrayop (i, j) A[i, k] * D[k, j] k in 1:3</code></pre><p>This expression is valid. Note that when manually restricting iteration ranges, the range must be a subset of the axes where the iteration variable is used. Here <code>1:3</code> is a subset of both <code>1:5</code> and <code>1:3</code>.</p><p><strong>Axis offsets</strong></p><p>The usages of index variables can be offset.</p><pre><code class="language-julia hljs">A2 = @arrayop (i, j) A[i + 1, j] + A[i, j + 1]</code></pre><p>Here, <code>A2</code> will have size <code>(4, 4)</code> since SymbolicUtils.jl is able to recognize that <code>i</code> and <code>j</code> can only iterate in the range <code>1:4</code>. For trivial offsets of the form <code>idx + offset</code> (<code>offset</code> can be negative), the bounds of <code>idx</code> can be inferred. More complicated offsets can be used, but this requires manually specifying ranges of the involved index variables.</p><pre><code class="language-julia hljs">A3 = @arrayop (i, j) A[2i - 1, j] i in 1:3</code></pre><p>In this scenario, it is the responsibility of the user to ensure the arrays are always accessed within their bounds.</p><p><strong>Usage with non-standard axes</strong></p><p>The index variables are &quot;idealized&quot; indices. This means that as long as the length of all axes where an index variable is used is identical, the bounds of the axes are irrelevant.</p><pre><code class="language-julia hljs">@syms E[0:4, 0:4]
F = @arrayop (i, j) A[i, k] * E[k, j]</code></pre><p>Despite <code>axes(A, 2)</code> being <code>1:5</code> and <code>axes(E, 1)</code> being <code>0:4</code>, the above expression is valid since <code>length(1:5) == 5 == length(0:4)</code>. When generating code, index variables will be appropriately offset to index the involved axes.</p><p>If the range of an index variable is manually specified, the index variable is no longer &quot;idealized&quot; and the user is responsible for offsetting appropriately. The above example with a manual range for <code>k</code> should be written as:</p><pre><code class="language-julia hljs">F2 = @arrayop (i, j) A[i, k] * E[k - 1, j] k in 1:5</code></pre><p><strong>Result shape</strong></p><p>The result is always 1-indexed with axes of appropriate lengths, regardless of the shape of the inputs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/cf062a946a1ae95b5e55b2aa29595987a13a9202/src/arrayop.jl#L10-L113">source</a></section></article><h3 id="Variant-checking"><a class="docs-heading-anchor" href="#Variant-checking">Variant checking</a><a id="Variant-checking-1"></a><a class="docs-heading-anchor-permalink" href="#Variant-checking" title="Permalink"></a></h3><p>Note that while these utilities are useful, prefer using <code>Moshi.Match.@match</code> to pattern match against different variant types and access their fields.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.isconst" href="#SymbolicUtils.isconst"><code>SymbolicUtils.isconst</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isconst(
    x::SymbolicUtils.BasicSymbolicImpl.var&quot;typeof(BasicSymbolicImpl)&quot;{T} where T
) -&gt; Bool
</code></pre><p>Check if a value is a <code>Const</code> variant of <code>BasicSymbolic</code>.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: Value to check (for <code>BasicSymbolic</code> input returns true if <code>Const</code>, for others returns false)</li></ul><p><strong>Returns</strong></p><ul><li><code>true</code> if <code>x</code> is a <code>BasicSymbolic</code> with <code>Const</code> variant, <code>false</code> otherwise</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/cf062a946a1ae95b5e55b2aa29595987a13a9202/src/types.jl#L716-L726">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.issym" href="#SymbolicUtils.issym"><code>SymbolicUtils.issym</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">issym(
    x::SymbolicUtils.BasicSymbolicImpl.var&quot;typeof(BasicSymbolicImpl)&quot;{T} where T
) -&gt; Bool
</code></pre><p>Check if a value is a <code>Sym</code> variant of <code>BasicSymbolic</code>.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: Value to check (for <code>BasicSymbolic</code> input returns true if <code>Sym</code>, for others returns false)</li></ul><p><strong>Returns</strong></p><ul><li><code>true</code> if <code>x</code> is a <code>BasicSymbolic</code> with <code>Sym</code> variant, <code>false</code> otherwise</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/cf062a946a1ae95b5e55b2aa29595987a13a9202/src/types.jl#L729-L739">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.isterm" href="#SymbolicUtils.isterm"><code>SymbolicUtils.isterm</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isterm(
    x::SymbolicUtils.BasicSymbolicImpl.var&quot;typeof(BasicSymbolicImpl)&quot;{T} where T
) -&gt; Bool
</code></pre><p>Check if a value is a <code>Term</code> variant of <code>BasicSymbolic</code>.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: Value to check (for <code>BasicSymbolic</code> input returns true if <code>Term</code>, for others returns false)</li></ul><p><strong>Returns</strong></p><ul><li><code>true</code> if <code>x</code> is a <code>BasicSymbolic</code> with <code>Term</code> variant, <code>false</code> otherwise</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/cf062a946a1ae95b5e55b2aa29595987a13a9202/src/types.jl#L742-L752">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.isaddmul" href="#SymbolicUtils.isaddmul"><code>SymbolicUtils.isaddmul</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isaddmul(
    x::SymbolicUtils.BasicSymbolicImpl.var&quot;typeof(BasicSymbolicImpl)&quot;{T} where T
) -&gt; Bool
</code></pre><p>Check if a value is an <code>AddMul</code> variant of <code>BasicSymbolic</code>.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: Value to check (for <code>BasicSymbolic</code> input returns true if <code>AddMul</code>, for others returns false)</li></ul><p><strong>Returns</strong></p><ul><li><code>true</code> if <code>x</code> is a <code>BasicSymbolic</code> with <code>AddMul</code> variant, <code>false</code> otherwise</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/cf062a946a1ae95b5e55b2aa29595987a13a9202/src/types.jl#L755-L765">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.isadd" href="#SymbolicUtils.isadd"><code>SymbolicUtils.isadd</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isadd(
    x::SymbolicUtils.BasicSymbolicImpl.var&quot;typeof(BasicSymbolicImpl)&quot;{T} where T
) -&gt; Bool
</code></pre><p>Check if a value is an addition (<code>AddMul</code> with ADD variant).</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: Value to check (for <code>BasicSymbolic</code> input returns true if addition, for others returns false)</li></ul><p><strong>Returns</strong></p><ul><li><code>true</code> if <code>x</code> is an <code>AddMul</code> with <code>ADD</code> variant, <code>false</code> otherwise</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/cf062a946a1ae95b5e55b2aa29595987a13a9202/src/types.jl#L768-L778">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.ismul" href="#SymbolicUtils.ismul"><code>SymbolicUtils.ismul</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ismul(
    x::SymbolicUtils.BasicSymbolicImpl.var&quot;typeof(BasicSymbolicImpl)&quot;{T} where T
) -&gt; Bool
</code></pre><p>Check if a value is a multiplication (<code>AddMul</code> with MUL variant).</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: Value to check (for <code>BasicSymbolic</code> input returns true if multiplication, for others returns false)</li></ul><p><strong>Returns</strong></p><ul><li><code>true</code> if <code>x</code> is an <code>AddMul</code> with <code>MUL</code> variant, <code>false</code> otherwise</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/cf062a946a1ae95b5e55b2aa29595987a13a9202/src/types.jl#L781-L791">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.isdiv" href="#SymbolicUtils.isdiv"><code>SymbolicUtils.isdiv</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isdiv(
    x::SymbolicUtils.BasicSymbolicImpl.var&quot;typeof(BasicSymbolicImpl)&quot;{T} where T
) -&gt; Bool
</code></pre><p>Check if a value is a <code>Div</code> variant of <code>BasicSymbolic</code>.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: Value to check (for <code>BasicSymbolic</code> input returns true if <code>Div</code>, for others returns false)</li></ul><p><strong>Returns</strong></p><ul><li><code>true</code> if <code>x</code> is a <code>BasicSymbolic</code> with <code>Div</code> variant, <code>false</code> otherwise</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/cf062a946a1ae95b5e55b2aa29595987a13a9202/src/types.jl#L794-L804">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.ispow" href="#SymbolicUtils.ispow"><code>SymbolicUtils.ispow</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ispow(
    x::SymbolicUtils.BasicSymbolicImpl.var&quot;typeof(BasicSymbolicImpl)&quot;{T} where T
) -&gt; Bool
</code></pre><p>Check if a value is a power expression (<code>Term</code> with <code>^</code> operation).</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: Value to check (for <code>BasicSymbolic</code> input returns true if power, for others returns false)</li></ul><p><strong>Returns</strong></p><ul><li><code>true</code> if <code>x</code> is a <code>Term</code> with exponentiation operation, <code>false</code> otherwise</li></ul><p><strong>Details</strong></p><p>Power expressions are <code>Term</code> variants where the operation is <code>^</code> (6 uses).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/cf062a946a1ae95b5e55b2aa29595987a13a9202/src/types.jl#L807-L820">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.isarrayop" href="#SymbolicUtils.isarrayop"><code>SymbolicUtils.isarrayop</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isarrayop(
    x::SymbolicUtils.BasicSymbolicImpl.var&quot;typeof(BasicSymbolicImpl)&quot;{T} where T
) -&gt; Bool
</code></pre><p>Check if a value is an <code>ArrayOp</code> variant of <code>BasicSymbolic</code>.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: Value to check (for <code>BasicSymbolic</code> input returns true if <code>ArrayOp</code>, for others returns false).</li></ul><p><strong>Returns</strong></p><ul><li><code>true</code> if <code>x</code> is a <code>BasicSymbolic</code> with <code>ArrayOp</code> variant, <code>false</code> otherwise.</li></ul><p><strong>Details</strong></p><p>Array operations represent vectorized computations created by the <code>@arrayop</code> macro.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/cf062a946a1ae95b5e55b2aa29595987a13a9202/src/types.jl#L823-L836">source</a></section></article><h3 id="Using-custom-functions-in-expressions"><a class="docs-heading-anchor" href="#Using-custom-functions-in-expressions">Using custom functions in expressions</a><a id="Using-custom-functions-in-expressions-1"></a><a class="docs-heading-anchor-permalink" href="#Using-custom-functions-in-expressions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.promote_symtype" href="#SymbolicUtils.promote_symtype"><code>SymbolicUtils.promote_symtype</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">promote_symtype(f, Ts...) -&gt; Type{Bool}
</code></pre><p>The result of applying <code>f</code> to arguments of <a href="#SymbolicUtils.symtype"><code>SymbolicUtils.symtype</code></a> <code>Ts...</code></p><pre><code class="language-julia hljs">julia&gt; promote_symtype(+, Real, Real)
Real

julia&gt; promote_symtype(+, Complex, Real)
Number

julia&gt; @syms f(x)::Complex
(f(::Number)::Complex,)

julia&gt; promote_symtype(f, Number)
Complex</code></pre><p>When constructing expressions without an explicit symtype, <code>promote_symtype</code> is used to figure out the symtype of the Term.</p><p>It is recommended that all type arguments be annotated with <a href="#SymbolicUtils.TypeT"><code>SymbolicUtils.TypeT</code></a> and one method be implemented for any combination of <code>f</code> and the number of arguments. For example, one method is implemented for unary <code>-</code> and one method for binary <code>-</code>. Each method has an <code>if..elseif</code> chain to handle possible types. Any call to <code>promote_type</code> should be typeasserted with <code>::TypeT</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/cf062a946a1ae95b5e55b2aa29595987a13a9202/src/types.jl#L2786-L2813">source</a></section><section><div><pre><code class="language-julia hljs">promote_symtype(f::FnType{X,Y}, arg_symtypes...)</code></pre><p>The output symtype of applying variable <code>f</code> to arguments of symtype <code>arg_symtypes...</code>. if the arguments are of the wrong type then this function will error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/cf062a946a1ae95b5e55b2aa29595987a13a9202/src/types.jl#L2890-L2895">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.promote_shape" href="#SymbolicUtils.promote_shape"><code>SymbolicUtils.promote_shape</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">promote_shape(f, shs::ShapeT...)</code></pre><p>The shape of the result of applying <code>f</code> to arguments of <a href="#SymbolicUtils.shape"><code>shape</code></a> <code>shs...</code>. It is recommended that implemented methods <code>@nospecialize</code> all the shape arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/cf062a946a1ae95b5e55b2aa29595987a13a9202/src/types.jl#L2816-L2821">source</a></section></article><h3 id="Symbolic-array-utilities"><a class="docs-heading-anchor" href="#Symbolic-array-utilities">Symbolic array utilities</a><a id="Symbolic-array-utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Symbolic-array-utilities" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.stable_eachindex" href="#SymbolicUtils.stable_eachindex"><code>SymbolicUtils.stable_eachindex</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">stable_eachindex(
    x::SymbolicUtils.BasicSymbolicImpl.var&quot;typeof(BasicSymbolicImpl)&quot;{T} where T
) -&gt; SymbolicUtils.StableIndices
</code></pre><p>Returns a type-stable iterator over all indices of a symbolic array <code>x</code>.</p><p>This function provides an efficient, allocation-friendly way to iterate over multi-dimensional symbolic arrays. Unlike <code>Base.eachindex</code>, which returns <code>CartesianIndices</code> with type parameters that may be uninferrable for symbolic arrays, <code>stable_eachindex</code> returns a <a href="#SymbolicUtils.StableIndices"><code>StableIndices</code></a> iterator that produces <a href="#SymbolicUtils.StableIndex"><code>StableIndex</code></a> values in a fully type-stable manner.</p><p>Note that the returned iterator does not match the shape of <code>x</code>. In other words, <code>collect(stable_eachindex(x))</code> will be a vector regardless of the shape of <code>x</code>.</p><p><strong>Arguments</strong></p><ul><li><code>x::BasicSymbolic</code>: A symbolic array expression with a known concrete shape.</li></ul><p><strong>Returns</strong></p><ul><li><code>StableIndices</code>: An iterator that yields <code>StableIndex</code> values for each position in the array.</li></ul><p><strong>Throws</strong></p><ul><li>This function assumes <code>x</code> has a concrete shape (i.e., <code>shape(x)</code> is a <code>ShapeVecT</code>, not <code>Unknown</code>). If the shape is unknown, it will error.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using SymbolicUtils

# Create a symbolic 2×3 matrix
@variables x[1:2, 1:3]

# Iterate over all indices in a type-stable manner
for idx in stable_eachindex(x)
    println(&quot;Index: &quot;, idx, &quot; -&gt; Value: &quot;, x[idx])
end

# Compare with regular eachindex
for idx in eachindex(x)  # Returns CartesianIndices
    println(&quot;Index: &quot;, idx, &quot; -&gt; Value: &quot;, x[idx])
end</code></pre><p><strong>See also</strong></p><ul><li><a href="#SymbolicUtils.StableIndices"><code>StableIndices</code></a>: The iterator type returned by this function</li><li><a href="#SymbolicUtils.StableIndex"><code>StableIndex</code></a>: The index type produced by <code>StableIndices</code></li><li><code>Base.eachindex</code>: The standard Julia function for iterating over array indices</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/cf062a946a1ae95b5e55b2aa29595987a13a9202/src/methods.jl#L661-L708">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.StableIndices" href="#SymbolicUtils.StableIndices"><code>SymbolicUtils.StableIndices</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct StableIndices</code></pre><p>An iterator that produces <a href="#SymbolicUtils.StableIndex"><code>StableIndex</code></a> values representing all possible multi-dimensional indices for a given shape in a type-stable, allocation-efficient manner.</p><p>This type is used to iterate over multi-dimensional index spaces where each dimension can have its own range (stored in <code>sh</code>). The iterator produces all combinations of indices in column-major order, similar to <code>CartesianIndices</code>, but with better type stability and allocation characteristics.</p><p>This is similar to <code>CartesianIndices</code> for symbolic arrays, but avoids type-instability due to the type parameters of <code>CartesianIndices</code> being uninferrable. Note that iterator iterates over multidimensional indices, but is not a multidimensional iterator. In other words, <code>collect</code>ing this iterator will return a vector regardless of the number of dimensions it iterates over.</p><p><strong>Fields</strong></p><ul><li><code>sh::SymbolicUtils.SmallVec{UnitRange{Int64}, Vector{UnitRange{Int64}}}</code>: A small vector of <code>UnitRange{Int}</code> values, one for each dimension, defining the range of valid indices for that dimension.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">sh = ShapeVecT([1:2, 1:3])
indices = StableIndices(sh)
for idx in indices
    # idx is a StableIndex with values like [1,1], [1,2], [1,3], [2,1], [2,2], [2,3]
end</code></pre><p><strong>See also</strong></p><ul><li><a href="#SymbolicUtils.StableIndex"><code>StableIndex</code></a>: The index type produced by this iterator.</li><li><a href="#SymbolicUtils.stable_eachindex"><code>stable_eachindex</code></a>: Convenience function that returns a <code>StableIndices</code> iterator for a symbolic array.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/cf062a946a1ae95b5e55b2aa29595987a13a9202/src/methods.jl#L582-L614">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.StableIndex" href="#SymbolicUtils.StableIndex"><code>SymbolicUtils.StableIndex</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct StableIndex</code></pre><p>A wrapper around a small vector of integer indices that provides a stable, allocation-efficient representation of multi-dimensional array indices.</p><p>This type is used in conjunction with <a href="#SymbolicUtils.StableIndices"><code>StableIndices</code></a> to iterate over multi-dimensional index spaces in a type-stable manner. It implements the standard iteration and indexing interfaces.</p><p>This is effectively equivalent to <code>CartesianIndex</code> for symbolic arrays, but avoids type-instability due to <code>N</code> in <code>CartesianIndex{N}</code> being uninferrable.</p><p><strong>Fields</strong></p><ul><li><code>idxs::SymbolicUtils.SmallVec{Int64, Vector{Int64}}</code>: A small vector storing the indices for each dimension.</li></ul><p><strong>See also</strong></p><ul><li><a href="#SymbolicUtils.StableIndices"><code>StableIndices</code></a>: An iterator that produces <code>StableIndex</code> values.</li><li><a href="#SymbolicUtils.stable_eachindex"><code>stable_eachindex</code></a>: Returns a <code>StableIndices</code> iterator for a symbolic array.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/cf062a946a1ae95b5e55b2aa29595987a13a9202/src/types.jl#L4053-L4072">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.BS" href="#SymbolicUtils.BS"><code>SymbolicUtils.BS</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BS[...]
BS{T}[...]</code></pre><p><code>BS</code> is a utility defined in SymbolicUtils for constructing arrays of symbolics. Similar to how <code>T[...]</code> creates an <code>Array</code> of eltype <code>T</code>, <code>BS[...]</code> creates an array of eltype <code>BasicSymbolic{T}</code>. To infer the <a href="#SymbolicUtils.vartype"><code>vartype</code></a> of the result, at least one of the values in <code>...</code> must be a symbolic. <code>BS{T}[...]</code> can be used to explicitly specify the <code>vartype</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/cf062a946a1ae95b5e55b2aa29595987a13a9202/src/syms.jl#L326-L334">source</a></section></article><h3 id="Symbolic-function-utilities"><a class="docs-heading-anchor" href="#Symbolic-function-utilities">Symbolic function utilities</a><a id="Symbolic-function-utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Symbolic-function-utilities" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.is_function_symbolic" href="#SymbolicUtils.is_function_symbolic"><code>SymbolicUtils.is_function_symbolic</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_function_symbolic(
    x::SymbolicUtils.BasicSymbolicImpl.var&quot;typeof(BasicSymbolicImpl)&quot;{T} where T
) -&gt; Bool
</code></pre><p>Check if <code>x</code> is a symbolic representing a function (as opposed to a dependent variable). A symbolic function either has a defined signature or the function type defined. For example, all of the below are considered symbolic functions:</p><pre><code class="language-julia hljs">@syms f(::Real, ::Real) g(::Real)::Integer h(::Real)[1:2]::Integer (ff::MyCallableT)(..)</code></pre><p>However, the following is considered a dependent variable with unspecified independent variable:</p><pre><code class="language-julia hljs">@syms x(..)</code></pre><p>See also: <a href="#SymbolicUtils.is_function_symtype"><code>SymbolicUtils.is_function_symtype</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/cf062a946a1ae95b5e55b2aa29595987a13a9202/src/types.jl#L2844-L2863">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.is_function_symtype" href="#SymbolicUtils.is_function_symtype"><code>SymbolicUtils.is_function_symtype</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_function_symtype(_::Type{T}) -&gt; Bool
</code></pre><p>Check if the given <code>symtype</code> represents a function (as opposed to a dependent variable).</p><p>See also: <a href="#SymbolicUtils.is_function_symbolic"><code>SymbolicUtils.is_function_symbolic</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/cf062a946a1ae95b5e55b2aa29595987a13a9202/src/types.jl#L2865-L2871">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.is_called_function_symbolic" href="#SymbolicUtils.is_called_function_symbolic"><code>SymbolicUtils.is_called_function_symbolic</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_called_function_symbolic(
    x::SymbolicUtils.BasicSymbolicImpl.var&quot;typeof(BasicSymbolicImpl)&quot;{T}
) -&gt; Bool
</code></pre><p>Check if the given symbolic <code>x</code> is the result of calling a symbolic function (as opposed to a dependent variable).</p><p>See also: <a href="#SymbolicUtils.is_function_symbolic"><code>SymbolicUtils.is_function_symbolic</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/cf062a946a1ae95b5e55b2aa29595987a13a9202/src/types.jl#L2875-L2882">source</a></section></article><h3 id="TermInterface.jl-interface"><a class="docs-heading-anchor" href="#TermInterface.jl-interface">TermInterface.jl interface</a><a id="TermInterface.jl-interface-1"></a><a class="docs-heading-anchor-permalink" href="#TermInterface.jl-interface" title="Permalink"></a></h3><div class="admonition is-warning" id="Missing-docstring.-41a7b48fc7a6f2c6"><header class="admonition-header">Missing docstring.<a class="admonition-anchor" href="#Missing-docstring.-41a7b48fc7a6f2c6" title="Permalink"></a></header><div class="admonition-body"><p>Missing docstring for <code>TermInterface.iscall</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning" id="Missing-docstring.-642f265effd1be72"><header class="admonition-header">Missing docstring.<a class="admonition-anchor" href="#Missing-docstring.-642f265effd1be72" title="Permalink"></a></header><div class="admonition-body"><p>Missing docstring for <code>TermInterface.operation</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning" id="Missing-docstring.-e304b20620639e71"><header class="admonition-header">Missing docstring.<a class="admonition-anchor" href="#Missing-docstring.-e304b20620639e71" title="Permalink"></a></header><div class="admonition-body"><p>Missing docstring for <code>TermInterface.arguments</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning" id="Missing-docstring.-a93d9c2e370962a5"><header class="admonition-header">Missing docstring.<a class="admonition-anchor" href="#Missing-docstring.-a93d9c2e370962a5" title="Permalink"></a></header><div class="admonition-body"><p>Missing docstring for <code>TermInterface.sorted_arguments</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning" id="Missing-docstring.-4a7d11c12e2690bf"><header class="admonition-header">Missing docstring.<a class="admonition-anchor" href="#Missing-docstring.-4a7d11c12e2690bf" title="Permalink"></a></header><div class="admonition-body"><p>Missing docstring for <code>TermInterface.maketerm</code>. Check Documenter&#39;s build log for details.</p></div></div><h3 id="Miscellaneous-utilities"><a class="docs-heading-anchor" href="#Miscellaneous-utilities">Miscellaneous utilities</a><a id="Miscellaneous-utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Miscellaneous-utilities" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.zero_of_vartype" href="#SymbolicUtils.zero_of_vartype"><code>SymbolicUtils.zero_of_vartype</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">zero_of_vartype(
    _::Type{SymReal}
) -&gt; SymbolicUtils.BasicSymbolicImpl.var&quot;typeof(BasicSymbolicImpl)&quot;{SymReal}
</code></pre><p>Return a <code>Const</code> representing <code>0</code> with the provided <code>vartype</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/cf062a946a1ae95b5e55b2aa29595987a13a9202/src/types.jl#L1282-L1286">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.one_of_vartype" href="#SymbolicUtils.one_of_vartype"><code>SymbolicUtils.one_of_vartype</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">one_of_vartype(
    _::Type{SymReal}
) -&gt; SymbolicUtils.BasicSymbolicImpl.var&quot;typeof(BasicSymbolicImpl)&quot;{SymReal}
</code></pre><p>Return a <code>Const</code> representing <code>1</code> with the provided <code>vartype</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/cf062a946a1ae95b5e55b2aa29595987a13a9202/src/types.jl#L1290-L1294">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.get_mul_coefficient" href="#SymbolicUtils.get_mul_coefficient"><code>SymbolicUtils.get_mul_coefficient</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_mul_coefficient(x) -&gt; Any
</code></pre><p>Extract the numeric coefficient from a multiplication expression.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: A symbolic expression that must be a multiplication</li></ul><p><strong>Returns</strong></p><ul><li>The numeric coefficient of the multiplication</li></ul><p><strong>Details</strong></p><p>This function extracts the leading numeric coefficient from a multiplication expression. For <code>Term</code> variants, it recursively searches for nested multiplications. For <code>AddMul</code> variants with <code>MUL</code> operation, it returns the stored coefficient. Throws an error if the input is not a multiplication expression.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/cf062a946a1ae95b5e55b2aa29595987a13a9202/src/types.jl#L1299-L1315">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.term" href="#SymbolicUtils.term"><code>SymbolicUtils.term</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">term(f, args...; vartype = SymReal, type = promote_symtype(f, symtype.(args)...), shape = promote_shape(f, SymbolicUtils.shape.(args)...))</code></pre><p>Create a symbolic term with operation <code>f</code> and arguments <code>args</code>.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: The operation or function head of the term</li><li><code>args...</code>: The arguments to the operation</li><li><code>vartype</code>: The variant type for the term (default: <code>SymReal</code>)</li><li><code>type</code>: The symbolic type of the term. If not provided, it is inferred using <code>promote_symtype</code> on the function and argument types.</li><li><code>shape</code>: The shape of the term. If not provided, it is inferred using <code>promote_shape</code> on the function and argument shapes.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; @syms x y
(x, y)

julia&gt; term(+, x, y)
x + y

julia&gt; term(sin, x)
sin(x)

julia&gt; term(^, x, 2)
x^2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/cf062a946a1ae95b5e55b2aa29595987a13a9202/src/types.jl#L2520-L2546">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.add_worker" href="#SymbolicUtils.add_worker"><code>SymbolicUtils.add_worker</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_worker(_, terms)</code></pre><p>defined at <a href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/tree/cf062a946a1ae95b5e55b2aa29595987a13a9202//src/types.jl#L3066"><code>/home/runner/work/SymbolicUtils.jl/SymbolicUtils.jl/src/types.jl:3066</code></a>.</p><p>Add an indexable list or tuple of terms <code>terms</code> with the given vartype. Applicable only for symbolic expressions with numeric or array of numeric symtype.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/cf062a946a1ae95b5e55b2aa29595987a13a9202/src/types.jl#L3060-L3065">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.mul_worker" href="#SymbolicUtils.mul_worker"><code>SymbolicUtils.mul_worker</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mul_worker(_, terms)</code></pre><p>defined at <a href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/tree/cf062a946a1ae95b5e55b2aa29595987a13a9202//src/types.jl#L3544"><code>/home/runner/work/SymbolicUtils.jl/SymbolicUtils.jl/src/types.jl:3544</code></a>.</p><p>Multiply an indexable list or tuple of terms <code>terms</code> with the given vartype. Applicable only for symbolic expressions with numeric or array of numeric symtype.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/cf062a946a1ae95b5e55b2aa29595987a13a9202/src/types.jl#L3538-L3543">source</a></section></article><h3 id="Utility-types"><a class="docs-heading-anchor" href="#Utility-types">Utility types</a><a id="Utility-types-1"></a><a class="docs-heading-anchor-permalink" href="#Utility-types" title="Permalink"></a></h3><p>SymbolicUtils exposes a plethora of type aliases to allow easily interacting with common types used internally.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.MetadataT" href="#SymbolicUtils.MetadataT"><code>SymbolicUtils.MetadataT</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Type of metadata field for symbolics.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/cf062a946a1ae95b5e55b2aa29595987a13a9202/src/types.jl#L57-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.SmallV" href="#SymbolicUtils.SmallV"><code>SymbolicUtils.SmallV</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mutable struct SmallVec{T, Array{T, 1}} &lt;: AbstractArray{T, 1}</code></pre><p>A custom vector type which does not allocate for small numbers of elements. If the number of elements is known at compile time, it should be passed as a <code>Tuple</code> to the constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/cf062a946a1ae95b5e55b2aa29595987a13a9202/src/types.jl#L63-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.ShapeVecT" href="#SymbolicUtils.ShapeVecT"><code>SymbolicUtils.ShapeVecT</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A small-buffer-optimized <code>AbstractVector</code>. Uses a <code>Backing</code> when the number of elements is within the size of <code>Backing</code>, and allocates a <code>V</code> when the number of elements exceed this limit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/cf062a946a1ae95b5e55b2aa29595987a13a9202/src/small_array.jl#L226-L232">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.ShapeT" href="#SymbolicUtils.ShapeT"><code>SymbolicUtils.ShapeT</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Type that represents the <a href="#SymbolicUtils.shape"><code>SymbolicUtils.shape</code></a> of symbolics.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/cf062a946a1ae95b5e55b2aa29595987a13a9202/src/types.jl#L71-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.TypeT" href="#SymbolicUtils.TypeT"><code>SymbolicUtils.TypeT</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mutable struct DataType &lt;: Type{T}</code></pre><p>Allowed types for the <a href="#SymbolicUtils.symtype"><code>SymbolicUtils.symtype</code></a> of symbolics.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/cf062a946a1ae95b5e55b2aa29595987a13a9202/src/types.jl#L87-L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.ArgsT" href="#SymbolicUtils.ArgsT"><code>SymbolicUtils.ArgsT</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">The type of a mutable buffer containing symbolic arguments. Passing this to the
[`SymbolicUtils.Term`](@ref) constructor will avoid allocating a new array.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/cf062a946a1ae95b5e55b2aa29595987a13a9202/src/types.jl#L227-L230">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.ROArgsT" href="#SymbolicUtils.ROArgsT"><code>SymbolicUtils.ROArgsT</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">The type of a read-only buffer containing symbolic arguments. Passing this to the
[`SymbolicUtils.Term`](@ref) constructor will avoid allocating a new array. This is
the type returned from [`TermInterface.arguments`](@ref).</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/cf062a946a1ae95b5e55b2aa29595987a13a9202/src/types.jl#L232-L236">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.ACDict" href="#SymbolicUtils.ACDict"><code>SymbolicUtils.ACDict</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">The type of the dictionary stored in [`BSImpl.AddMul`](@ref). Passing this to the
[`SymbolicUtils.Add`](@ref) or [`SymbolicUtils.Mul`](@ref) constructors will avoid
allocating a new dictionary.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/cf062a946a1ae95b5e55b2aa29595987a13a9202/src/types.jl#L238-L242">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.OutIdxT" href="#SymbolicUtils.OutIdxT"><code>SymbolicUtils.OutIdxT</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">The type of the `output_idxs` field in [`BSImpl.ArrayOp`](@ref).</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/cf062a946a1ae95b5e55b2aa29595987a13a9202/src/types.jl#L244-L246">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.RangesT" href="#SymbolicUtils.RangesT"><code>SymbolicUtils.RangesT</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">The type of the `ranges` field in [`BSImpl.ArrayOp`](@ref).</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/cf062a946a1ae95b5e55b2aa29595987a13a9202/src/types.jl#L248-L250">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« SymbolicUtils.jl — Symbolic programming in Julia</a><a class="docs-footer-nextpage" href="../rewrite/">Term Rewriting »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.15.0 on <span class="colophon-date" title="Friday 31 October 2025 18:26">Friday 31 October 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
