<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Code generation · SymbolicUtils.jl</title><meta name="title" content="Code generation · SymbolicUtils.jl"/><meta property="og:title" content="Code generation · SymbolicUtils.jl"/><meta property="twitter:title" content="Code generation · SymbolicUtils.jl"/><meta name="description" content="Documentation for SymbolicUtils.jl."/><meta property="og:description" content="Documentation for SymbolicUtils.jl."/><meta property="twitter:description" content="Documentation for SymbolicUtils.jl."/><meta property="og:url" content="https://docs.sciml.ai/SymbolicUtils/stable/manual/codegen/"/><meta property="twitter:url" content="https://docs.sciml.ai/SymbolicUtils/stable/manual/codegen/"/><link rel="canonical" href="https://docs.sciml.ai/SymbolicUtils/stable/manual/codegen/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">SymbolicUtils.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">SymbolicUtils.jl — Symbolic programming in Julia</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../variants/">Variant structure and types</a></li><li><a class="tocitem" href="../rewrite/">Term Rewriting</a></li><li><a class="tocitem" href="../interface/">Interfacing with SymbolicUtils.jl</a></li><li class="is-active"><a class="tocitem" href>Code generation</a><ul class="internal"><li><a class="tocitem" href="#toexpr"><span><code>toexpr</code></span></a></li><li><a class="tocitem" href="#Code-Combinators"><span>Code Combinators</span></a></li><li><a class="tocitem" href="#Optimizations"><span>Optimizations</span></a></li></ul></li><li><a class="tocitem" href="../caching/">Caching recursive functions</a></li><li><a class="tocitem" href="../recursive_utils/">Recursive utility functions</a></li></ul></li><li><a class="tocitem" href="../../api/">API Reference</a></li><li><a class="tocitem" href="../../upgrade/">Upgrade to SymbolicUtils v1</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Code generation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Code generation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/master/docs/src/manual/codegen.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Code-generation"><a class="docs-heading-anchor" href="#Code-generation">Code generation</a><a id="Code-generation-1"></a><a class="docs-heading-anchor-permalink" href="#Code-generation" title="Permalink"></a></h1><p><strong>Note: this feature is experimental and the API might change frequently</strong></p><p><code>toexpr(ex)</code> turns any expression (<code>ex</code>) into the equivalent <code>Expr</code> which is suitable for <code>eval</code>. The <code>SymbolicUtils.Code</code> module provides some combinators which provides the ability to construct more complex expressions than just function calls. These include:</p><ul><li>Let blocks</li><li>Functions with arguments and keyword arguments<ul><li>Functions with arguments which are to be de-structured</li></ul></li><li>Expressions that set array elements in-place</li><li>Expressions that create an array similar in type to a reference array (currently supports <code>Array</code>, <code>StaticArrays.SArray</code>, and <code>LabelledArrays.SLArray</code>)</li><li>Expressions that create sparse arrays</li></ul><p><strong>Do <code>using SymbolicUtils.Code</code> to get the following bindings</strong></p><h2 id="toexpr"><a class="docs-heading-anchor" href="#toexpr"><code>toexpr</code></a><a id="toexpr-1"></a><a class="docs-heading-anchor-permalink" href="#toexpr" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="SymbolicUtils.Code.toexpr"><a class="docstring-binding" href="#SymbolicUtils.Code.toexpr"><code>SymbolicUtils.Code.toexpr</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">toexpr(ex, [st,])</code></pre><p>Convert a symbolic expression into an <code>Expr</code>, suitable to be passed into <code>eval</code>.</p><p>For example,</p><pre><code class="language-julia hljs">julia&gt; @syms a b
(a, b)

julia&gt; toexpr(a+b)
:((+)(a, b))

julia&gt; toexpr(a+b) |&gt; dump
Expr
  head: Symbol call
  args: Array{Any}((3,))
    1: + (function of type typeof(+))
    2: Symbol a
    3: Symbol b</code></pre><p>Note that the function is an actual function object.</p><p>For more complex expressions, see other code-related combinators,</p><p>Namely <code>Assignment</code>, <code>Let</code>, <code>Func</code>, <code>SetArray</code>, <code>MakeArray</code>, <code>MakeSparseArray</code> and <code>MakeTuple</code>.</p><p>To make your own type convertible to Expr using <code>toexpr</code> define <code>toexpr(x, st)</code> and forward the state <code>st</code> in internal calls to <code>toexpr</code>. <code>st</code> is state used to know when to leave something like <code>y(t)</code> as it is or when to make it <code>var&quot;y(t)&quot;</code>. E.g. when <code>y(t)</code> is itself the argument of a function rather than <code>y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/b1a9945e0bc3561f25c2431cdcca7e0cd3752f8c/src/code.jl#L51-L86">source</a></section></details></article><h2 id="Code-Combinators"><a class="docs-heading-anchor" href="#Code-Combinators">Code Combinators</a><a id="Code-Combinators-1"></a><a class="docs-heading-anchor-permalink" href="#Code-Combinators" title="Permalink"></a></h2><p>These are all exported when you do <code>using SymbolicUtils.Code</code></p><article><details class="docstring" open="true"><summary id="SymbolicUtils.Code.Assignment"><a class="docstring-binding" href="#SymbolicUtils.Code.Assignment"><code>SymbolicUtils.Code.Assignment</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Assignment(lhs, rhs)</code></pre><p>An assignment expression. Shorthand <code>lhs ← rhs</code> (<code>\leftarrow</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/b1a9945e0bc3561f25c2431cdcca7e0cd3752f8c/src/code.jl#L94-L98">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SymbolicUtils.Code.Let"><a class="docstring-binding" href="#SymbolicUtils.Code.Let"><code>SymbolicUtils.Code.Let</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Let(assignments, body[, let_block])</code></pre><p>A Let block.</p><ul><li><code>assignments</code> is a vector of <code>Assignment</code>s</li><li><code>body</code> is the body of the let block</li><li><code>let_block</code> boolean (default=true) – do not create a let block if false.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/b1a9945e0bc3561f25c2431cdcca7e0cd3752f8c/src/code.jl#L412-L420">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SymbolicUtils.Code.Func"><a class="docstring-binding" href="#SymbolicUtils.Code.Func"><code>SymbolicUtils.Code.Func</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Func(args, kwargs, body[, pre])</code></pre><p>A function.</p><ul><li><code>args</code> is a vector of expressions</li><li><code>kwargs</code> is a vector of <code>Assignment</code>s</li><li><code>body</code> is the body of the function</li><li><code>pre</code> a vector of expressions to be prepended to the function body,  for example, it could be <code>[Expr(:meta, :inline), Expr(:meta, :propagate_inbounds)]</code>  to create an <code>@inline @propagate_inbounds</code> function definition.</li></ul><p><strong>Special features in <code>args</code></strong>:</p><ul><li>args can contain <code>DestructuredArgs</code></li><li>call expressions</li></ul><p>For example,</p><pre><code class="language-julia hljs">
julia&gt; @syms a b c t f(d) x(t) y(t) z(t)
(a, b, c, t, f(::Number)::Number, x(::Number)::Number, y(::Number)::Number, z(::Number)::Number)

julia&gt; func = Func([a,x(t), DestructuredArgs([b, y(t)]), f], # args
                   [c ← 2, z(t) ← 42], # kwargs
                   f((a + b + c) / x(t) + y(t) + z(t)));

julia&gt; toexpr(func)
:(function (a, var&quot;x(t)&quot;, var&quot;##arg#255&quot;, f; c = 2, var&quot;z(t)&quot; = 42)
      let b = var&quot;##arg#255&quot;[1], var&quot;y(t)&quot; = var&quot;##arg#255&quot;[2]
          f((+)(var&quot;y(t)&quot;, var&quot;z(t)&quot;, (*)((+)(a, b, c), (inv)(var&quot;x(t)&quot;))))
      end
  end)</code></pre><ul><li>the second argument is a <code>DestructuredArgs</code>, in the <code>Expr</code> form, it is given a random name, and is expected to receive a vector or tuple of size 2 containing the values of <code>b</code> and <code>y(t)</code>. The let block that is automatically generated &quot;destructures&quot; these arguments.</li><li><code>x(t)</code> and <code>y(t)</code> have been replaced with <code>var&quot;x(t)&quot;</code> and <code>var&quot;y(t)&quot;</code> symbols throughout</li></ul><p>the generated Expr. This makes sure that we are not actually calling the expressions <code>x(t)</code> or <code>y(t)</code> but instead passing the right values in place of the whole expression.</p><ul><li><code>f</code> is also a function-like symbol, same as <code>x</code> and <code>y</code>, but since the <code>args</code> array contains <code>f</code> as itself rather than as say, <code>f(t)</code>, it does not become a <code>var&quot;f(t)&quot;</code>. The generated function expects a function of one argument to be passed in the position of <code>f</code>.</li></ul><p>An example invocation of this function is:</p><pre><code class="language-julia hljs">julia&gt; executable = eval(toexpr(func))
#10 (generic function with 1 method)

julia&gt; executable(1, 2.0, [2,3.0], x-&gt;string(x); var&quot;z(t)&quot; = sqrt(42))
&quot;11.98074069840786&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/b1a9945e0bc3561f25c2431cdcca7e0cd3752f8c/src/code.jl#L475-L525">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SymbolicUtils.Code.SpawnFetch"><a class="docstring-binding" href="#SymbolicUtils.Code.SpawnFetch"><code>SymbolicUtils.Code.SpawnFetch</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SpawnFetch{ParallelType}(funcs [, args], reduce)</code></pre><p>Run every expression in <code>funcs</code> in its own task, the expression should be a <code>Func</code> object and is passed to <code>Threads.Task(f)</code>. If <code>Func</code> takes arguments, then the arguments must be passed in as <code>args</code>–a vector of vector of arguments to each function in <code>funcs</code>. We don&#39;t use <code>@spawn</code> in order to support RuntimeGeneratedFunctions which disallow closures, instead we interpolate these functions or closures as smaller RuntimeGeneratedFunctions.</p><p><code>reduce</code> function is used to combine the results of executing <code>exprs</code>. A SpawnFetch expression returns the reduced result.</p><p>Use <code>Symbolics.MultithreadedForm</code> ParallelType from the Symbolics.jl package to get the RuntimeGeneratedFunction version SpawnFetch.</p><p><code>ParallelType</code> can be used to define more parallelism types SymbolicUtils supports <code>Multithreaded</code> type. Which spawns threaded tasks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/b1a9945e0bc3561f25c2431cdcca7e0cd3752f8c/src/code.jl#L816-L831">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SymbolicUtils.Code.SetArray"><a class="docstring-binding" href="#SymbolicUtils.Code.SetArray"><code>SymbolicUtils.Code.SetArray</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SetArray(inbounds::Bool, arr, elems[, return_arr::Bool])</code></pre><p>An expression representing setting of elements of <code>arr</code>.</p><p>By default, every element of <code>elems</code> is copied over to <code>arr</code>,</p><p>but if <code>elems</code> contains <code>AtIndex(i, val)</code> objects, then <code>arr[i] = val</code> is performed in its place.</p><p><code>inbounds</code> is a boolean flag, <code>true</code> surrounds the resulting expression in an <code>@inbounds</code>.</p><p><code>return_arr</code> is a flag which controls whether the generated <code>begin..end</code> block returns the <code>arr</code>. Defaults to <code>false</code>, in which case the block returns <code>nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/b1a9945e0bc3561f25c2431cdcca7e0cd3752f8c/src/code.jl#L560-L575">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SymbolicUtils.Code.MakeArray"><a class="docstring-binding" href="#SymbolicUtils.Code.MakeArray"><code>SymbolicUtils.Code.MakeArray</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MakeArray(elems, similarto, [output_eltype=nothing])</code></pre><p>An expression which constructs an array.</p><ul><li><code>elems</code> is the output array</li><li><code>similarto</code> can either be a type, or some symbol that is an array whose type needs to  be emulated. If <code>similarto</code> is a StaticArrays.SArray, then the output array is also  created as an <code>SArray</code>, similarly, an <code>Array</code> will result in an <code>Array</code>, and a  <code>LabelledArrays.SLArray</code> will result in a labelled static array.</li><li><code>output_eltype</code>: if set, then forces the element type of the output array to be this.  by default, the output type is inferred automatically.</li></ul><p>You can define:</p><pre><code class="language-julia hljs">@inline function create_array(A::Type{&lt;:MyArray},a
                              ::Nothing, d::Val{dims}, elems...) where dims

# and

@inline function create_array(::Type{&lt;:MyArray}, T, ::Val{dims}, elems...) where dims</code></pre><p>which creates an array of size <code>dims</code> using the elements <code>elems</code> and eltype <code>T</code>, to allow <code>MakeArray</code> to create arrays similarto <code>MyArray</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/b1a9945e0bc3561f25c2431cdcca7e0cd3752f8c/src/code.jl#L604-L630">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SymbolicUtils.Code.MakeSparseArray"><a class="docstring-binding" href="#SymbolicUtils.Code.MakeSparseArray"><code>SymbolicUtils.Code.MakeSparseArray</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MakeSpaseArray(array)</code></pre><p>An expression which creates a <code>SparseMatrixCSC</code> or a <code>SparseVector</code>.</p><p>The generated expression contains the sparsity information of <code>array</code>,</p><p>it only creates the <code>nzval</code> field at run time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/b1a9945e0bc3561f25c2431cdcca7e0cd3752f8c/src/code.jl#L758-L766">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SymbolicUtils.Code.MakeTuple"><a class="docstring-binding" href="#SymbolicUtils.Code.MakeTuple"><code>SymbolicUtils.Code.MakeTuple</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MakeTuple(tup)</code></pre><p>Make a Tuple from a tuple of expressions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/b1a9945e0bc3561f25c2431cdcca7e0cd3752f8c/src/code.jl#L789-L793">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SymbolicUtils.Code.LiteralExpr"><a class="docstring-binding" href="#SymbolicUtils.Code.LiteralExpr"><code>SymbolicUtils.Code.LiteralExpr</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LiteralExpr(ex)</code></pre><p>Literally <code>ex</code>, an <code>Expr</code>. <code>toexpr</code> on <code>LiteralExpr</code> recursively calls <code>toexpr</code> on any interpolated symbolic expressions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/b1a9945e0bc3561f25c2431cdcca7e0cd3752f8c/src/code.jl#L850-L855">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SymbolicUtils.Code.ForLoop"><a class="docstring-binding" href="#SymbolicUtils.Code.ForLoop"><code>SymbolicUtils.Code.ForLoop</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ForLoop(itervar, range, body)</code></pre><p>Generate a <code>for</code> loop of the form</p><pre><code class="language-julia hljs">for itervar in range
    body
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/b1a9945e0bc3561f25c2431cdcca7e0cd3752f8c/src/code.jl#L867-L876">source</a></section></details></article><h2 id="Optimizations"><a class="docs-heading-anchor" href="#Optimizations">Optimizations</a><a id="Optimizations-1"></a><a class="docs-heading-anchor-permalink" href="#Optimizations" title="Permalink"></a></h2><h3 id="Common-Subexpression-Elimination-(CSE)"><a class="docs-heading-anchor" href="#Common-Subexpression-Elimination-(CSE)">Common Subexpression Elimination (CSE)</a><a id="Common-Subexpression-Elimination-(CSE)-1"></a><a class="docs-heading-anchor-permalink" href="#Common-Subexpression-Elimination-(CSE)" title="Permalink"></a></h3><p>SymbolicUtils can perform CSE on symbolic expressions, and codegen primitives composed of the above &quot;Code Combinators&quot;. This ensures that common subexpressions in the expression are only computed once. Note that this assumes that all functions called within the expression are pure. SymbolicUtils can and will change the number and order of function calls.</p><article><details class="docstring" open="true"><summary id="SymbolicUtils.Code.cse"><a class="docstring-binding" href="#SymbolicUtils.Code.cse"><code>SymbolicUtils.Code.cse</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">cse(expr) -&gt; Any
</code></pre><p>Perform common subexpression elimination on an expression.</p><p>This optimization identifies repeated subexpressions and replaces them with variables to avoid redundant computation.</p><p><strong>Arguments</strong></p><ul><li><code>expr</code>: The expression to optimize</li></ul><p><strong>Returns</strong></p><p>An optimized expression with common subexpressions eliminated</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; expr = :(sin(x) + sin(x) * cos(y))
julia&gt; cse(expr)  # sin(x) is computed only once</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/b1a9945e0bc3561f25c2431cdcca7e0cd3752f8c/src/code.jl#L980-L999">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SymbolicUtils.Code.cse_inside_expr"><a class="docstring-binding" href="#SymbolicUtils.Code.cse_inside_expr"><code>SymbolicUtils.Code.cse_inside_expr</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">cse_inside_expr(sym, f) -&gt; Bool
</code></pre><p>Return <code>true</code> if CSE should descend inside <code>sym</code>, which has operation <code>f</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/b1a9945e0bc3561f25c2431cdcca7e0cd3752f8c/src/code.jl#L905-L909">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../interface/">« Interfacing with SymbolicUtils.jl</a><a class="docs-footer-nextpage" href="../caching/">Caching recursive functions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Thursday 11 December 2025 12:08">Thursday 11 December 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
